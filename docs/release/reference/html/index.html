<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>The Inverno Framework | Reference Documentation</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
        <meta name="author" content="Jeremy KUHN (jeremy.kuhn@inverno.io)" />
        <link rel="icon" type="image/svg" href="../../../../img/snowflake.svg" />
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-F3w7mX95PdgyTmZZMECAngseQB83DfGTowi0iMjiWaeVhAn4FJkqJByhZMI3AhiU" crossorigin="anonymous" />
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css" />
        <link rel="stylesheet" type="text/css" href="../../../../styles/styles.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/stackoverflow-dark.min.css" media="screen" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/ascetic.min.css" media="print" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    </head>
    <body data-bs-spy="scroll" data-bs-target="#toc" data-bs-offset="0" tabindex="0">
        <header class="header">
            <div class="container-fluid border-bottom bg-light">
                <nav class="navbar navbar-expand-lg navbar-light container p-0 py-2 p-lg-1"><a class="navbar-brand p-0" href="../../../../"> <img class="logo" src="../../../../img/inverno_portable.svg" alt="The Inverno Framework" /> </a> <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#smallNavMenu" aria-controls="smallNavMenu" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button>
                    <div class="collapse" id="smallNavMenu" style="flex-basis: 100%;">
                        <ul class="navbar-nav border-top mt-2">
                            <li class="nav-item mt-2"><h5>Documentation</h5>
                              <ul class="nav flex-column">
                              <li class="nav-item ms-4"><a class="nav-link" href="../../../../docs/release/reference/html/index.html">Reference Guide</a></li>
                              <li class="nav-item ms-4"><a class="nav-link" href="../../../../docs/release/api/index.html">API Doc</a></li>
                              <li>
                              <hr class="dropdown-divider" /></li>
                              <li><h6 class="dropdown-header">User guides</h6></li>
                              <li class="nav-item ms-4"><a class="nav-link" href="../../../../docs/getting-started/html/index.html">Getting Started</a></li>
                              <li class="nav-item ms-4"><a class="nav-link" href="../../../../docs/redis-vue3-fullstack/html/index.html">Build a Full-Stack application</a></li>
                              </ul></li>
                            <li class="nav-item mt-2"><h5>Projects</h5>
                              <ul class="nav flex-column">
                              <li class="nav-item ms-4"><a class="nav-link" href="https://github.com/inverno-io/inverno-core">Core</a></li>
                              <li class="nav-item ms-4"><a class="nav-link" href="https://github.com/inverno-io/inverno-mods">Modules</a></li>
                              <li class="nav-item ms-4"><a class="nav-link" href="https://github.com/inverno-io/inverno-dist">Distribution</a></li>
                              <li class="nav-item ms-4"><a class="nav-link" href="https://github.com/inverno-io/inverno-tools">Tools</a></li>
                              <li class="nav-item ms-4"><a class="nav-link" href="https://github.com/inverno-io/inverno-examples">Examples</a></li>
                              <li class="nav-item ms-4"><a class="nav-link" href="https://github.com/inverno-io/inverno-apps">Apps</a></li>
                              </ul></li>
                        </ul>
                    </div>
                    <ul class="navbar-nav d-none d-sm-none d-lg-flex flex-fill justify-content-end align-self-stretch">
                        <li class="nav-item dropdown d-flex align-items-center me-3"><a class="nav-link dropdown-toggle text-decoration-none" href="#" id="documentationMenu" role="button" data-bs-toggle="dropdown" aria-expanded="false">Documentation</a>
                            <ul class="dropdown-menu mt-1 border-0 shadow p-3 mb-5 bg-body rounded" aria-labelledby="documentationMenu">
                              <li><a class="dropdown-item" href="../../../../docs/release/reference/html/index.html">Reference Guide</a></li>
                              <li><a class="dropdown-item" href="../../../../docs/release/api/index.html">API Doc</a></li>
                              <li>
                              <hr class="dropdown-divider" /></li>
                              <li><h6 class="dropdown-header">User guides</h6></li>
                              <li><a class="dropdown-item" href="../../../../docs/getting-started/html/index.html">Getting Started</a></li>
                              <li><a class="dropdown-item" href="../../../../docs/redis-vue3-fullstack/html/index.html">Build a Full-Stack application</a></li>
                            </ul></li>
                        <li class="nav-item dropdown d-flex align-items-center"><a class="nav-link dropdown-toggle text-decoration-none" href="#" id="projectsMenu" role="button" data-bs-toggle="dropdown" aria-expanded="false">Projects</a>
                            <ul class="dropdown-menu mt-1 border-0 shadow p-3 mb-5 bg-body rounded" aria-labelledby="projectsMenu">
                              <li><a class="dropdown-item" href="https://github.com/inverno-io/inverno-core">Core</a></li>
                              <li><a class="dropdown-item" href="https://github.com/inverno-io/inverno-mods">Modules</a></li>
                              <li><a class="dropdown-item" href="https://github.com/inverno-io/inverno-dist">Distribution</a></li>
                              <li><a class="dropdown-item" href="https://github.com/inverno-io/inverno-tools">Tools</a></li>
                              <li><a class="dropdown-item" href="https://github.com/inverno-io/inverno-examples">Examples</a></li>
                              <li><a class="dropdown-item" href="https://github.com/inverno-io/inverno-apps">Apps</a></li>
                            </ul></li>
                    </ul>
                </nav>
            </div>
        </header>
        <main id="main" class="main container">
            <div class="heading">
                <h1 class="heading-title">Inverno Framework Documentation</h1>
                <p class="heading-subtitle">Version: 1.5.2</p>
                <p class="heading-subtitle">Author: <a href="mailto:jeremy.kuhn@inverno.io">Jeremy Kuhn</a></p> <a class="btn btn-primary d-none d-lg-inline-block d-print-none m-5 position-absolute bottom-0 end-0" href="../reference.pdf" role="button" download="inverno-framework-documentation-1.5.2.pdf"><i class="bi bi-download"></i> Inverno Documentation.pdf</a>
            </div>
            <div class="d-lg-flex">
                <section class="toc col-12 col-lg-3">
                    <h2 class="d-none">Table of contents</h2><button class="toc-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#toc" aria-controls="toc" aria-expanded="false" aria-label="Toggle Table of Contents"><span class="toc-toggler-icon"></span></button>
                    <nav id="toc" class="navbar navbar-light toc-navbar toc-navbar-collapse collapse scrollbar-thin" onclick="this.className = 'navbar navbar-light toc-navbar toc-navbar-collapse collapse scrollbar-thin'">
                        <nav class="nav nav-pills flex-column">
                            <a class="nav-link" href="#introduction">Introduction</a>
                            <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#design-principles">Design principles</a><a class="nav-link" href="#getting-help">Getting help</a>
                            </nav><a class="nav-link" href="#overview">Overview</a>
                            <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#inverno-core">Inverno Core</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#creating-an-inverno-module">Creating an Inverno module</a>
                              </nav><a class="nav-link" href="#inverno-modules">Inverno Modules</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#using-a-module">Using a module</a><a class="nav-link" href="#available-modules">Available modules</a>
                              </nav><a class="nav-link" href="#inverno-tools">Inverno Tools</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#inverno-maven-plugin">Inverno Maven Plugin</a>
                              </nav>
                            </nav><a class="nav-link" href="#inverno-distribution">Inverno Distribution</a>
                            <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#requirements">Requirements</a><a class="nav-link" href="#creating-an-inverno-project">Creating an Inverno project</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#developing-a-simple-inverno-application">Developing a simple Inverno application</a><a class="nav-link" href="#configuring-logging">Configuring logging</a><a class="nav-link" href="#running-the-application">Running the application</a><a class="nav-link" href="#building-the-application-image">Building the application image</a>
                              </nav>
                            </nav><a class="nav-link" href="#inverno-core-1">Inverno Core</a>
                            <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#motivation">Motivation</a><a class="nav-link" href="#prerequisites">Prerequisites</a><a class="nav-link" href="#overview-1">Overview</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#modules-and-beans">Modules and Beans</a><a class="nav-link" href="#java-module-system">Java module system</a>
                              </nav><a class="nav-link" href="#project-setup">Project Setup</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#maven">Maven</a><a class="nav-link" href="#gradle">Gradle</a>
                              </nav><a class="nav-link" href="#bean">Bean</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#module-bean">Module Bean</a><a class="nav-link" href="#wrapper-bean">Wrapper Bean</a><a class="nav-link" href="#nested-bean">Nested Bean</a><a class="nav-link" href="#overridable">Overridable</a><a class="nav-link" href="#lifecycle">Lifecycle</a><a class="nav-link" href="#visibility">Visibility</a><a class="nav-link" href="#strategy">Strategy</a>
                              </nav><a class="nav-link" href="#module">Module</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#the-module-class">The module class</a><a class="nav-link" href="#lifecycle-1">Lifecycle</a><a class="nav-link" href="#module-as-component">Module as component</a><a class="nav-link" href="#module-as-application">Module as application</a>
                              </nav><a class="nav-link" href="#dependency-injection">Dependency Injection</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#bean-socket">Bean Socket</a><a class="nav-link" href="#socket-bean">Socket Bean</a><a class="nav-link" href="#wiring">Wiring</a>
                              </nav><a class="nav-link" href="#modular-application">Modular application</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#composite-module">Composite module</a><a class="nav-link" href="#provided-type">Provided type</a>
                              </nav>
                            </nav><a class="nav-link" href="#inverno-modules-1">Inverno Modules</a>
                            <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#motivation-1">Motivation</a><a class="nav-link" href="#prerequisites-1">Prerequisites</a><a class="nav-link" href="#overview-2">Overview</a><a class="nav-link" href="#base">Base</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#converter-api">Converter API</a><a class="nav-link" href="#net-api">Net API</a><a class="nav-link" href="#reflection-api">Reflection API</a><a class="nav-link" href="#resource-api">Resource API</a>
                              </nav><a class="nav-link" href="#boot">Boot</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#configuration">Configuration</a><a class="nav-link" href="#reactor">Reactor</a><a class="nav-link" href="#net-service">Net service</a><a class="nav-link" href="#media-type-service">Media type service</a><a class="nav-link" href="#resource-service">Resource service</a><a class="nav-link" href="#converters">Converters</a><a class="nav-link" href="#worker-pool">Worker pool</a><a class="nav-link" href="#object-mapper">Object mapper</a>
                              </nav><a class="nav-link" href="#configuration-1">Configuration</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#configuration-source">Configuration source</a><a class="nav-link" href="#configuration-loader">Configuration loader</a>
                              </nav><a class="nav-link" href="#http-base">HTTP Base</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#http-base-api">HTTP base API</a><a class="nav-link" href="#http-header-service">HTTP header service</a>
                              </nav><a class="nav-link" href="#http-server">HTTP Server</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#configuration-2">Configuration</a><a class="nav-link" href="#server-controller">Server Controller</a><a class="nav-link" href="#http-server-api">HTTP Server API</a><a class="nav-link" href="#websocket">WebSocket</a><a class="nav-link" href="#extending-http-services">Extending HTTP services</a><a class="nav-link" href="#wrap-up">Wrap-up</a>
                              </nav><a class="nav-link" href="#web">Web</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#web-routing-api">Web Routing API</a><a class="nav-link" href="#web-server">Web Server</a><a class="nav-link" href="#web-controller">Web Controller</a>
                              </nav><a class="nav-link" href="#reactive-template">Reactive Template</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#creates-an-irt-template">Creates an .irt template</a><a class="nav-link" href="#irt-syntax">.irt syntax</a><a class="nav-link" href="#pipes">Pipes</a><a class="nav-link" href="#modes">Modes</a>
                              </nav><a class="nav-link" href="#sql-client">SQL Client</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#sql-client-api">SQL client API</a><a class="nav-link" href="#vertx-sql-client-implementation">Vert.x SQL Client implementation</a>
                              </nav><a class="nav-link" href="#redis-client">Redis Client</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#redis-client-api">Redis Client API</a><a class="nav-link" href="#lettuce-redis-client-implementation">Lettuce Redis Client implementation</a>
                              </nav><a class="nav-link" href="#ldap">LDAP</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#configuration-3">Configuration</a><a class="nav-link" href="#ldap-client-api">LDAP Client API</a><a class="nav-link" href="#ldap-client-bean">LDAP Client bean</a>
                              </nav><a class="nav-link" href="#security">Security</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#security-manager">Security Manager</a><a class="nav-link" href="#security-context">Security Context</a>
                              </nav><a class="nav-link" href="#security-http">Security HTTP</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#security-interceptor">Security Interceptor</a><a class="nav-link" href="#access-control-interceptor">Access Control Interceptor</a><a class="nav-link" href="#http-authentication">HTTP authentication</a><a class="nav-link" href="#cross-origin-resource-sharing-cors">Cross-origin resource sharing (CORS)</a><a class="nav-link" href="#cross-site-request-forgery-protection-csrf">Cross-site request forgery protection (CSRF)</a>
                              </nav><a class="nav-link" href="#security-ldap">Security LDAP</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#ldap-authenticator">LDAP authenticator</a><a class="nav-link" href="#active-directory-authenticator">Active Directory authenticator</a><a class="nav-link" href="#ldap-identity">LDAP identity</a>
                              </nav><a class="nav-link" href="#json-object-signing-and-encryption">JSON Object Signing and Encryption</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#jwk-service">JWK Service</a><a class="nav-link" href="#jws-service">JWS Service</a><a class="nav-link" href="#jwe-service">JWE Service</a><a class="nav-link" href="#jwt-service">JWT Service</a><a class="nav-link" href="#jose-media-type-converters">JOSE Media Type Converters</a>
                              </nav>
                            </nav><a class="nav-link" href="#inverno-maven-plugin-1">Inverno Maven Plugin</a>
                            <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#usage">Usage</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#run-a-module-application-project">Run a module application project</a><a class="nav-link" href="#start-and-stop-the-application-for-integration-testing">Start and stop the application for integration testing</a><a class="nav-link" href="#build-a-runtime-image">Build a runtime image</a><a class="nav-link" href="#build-an-application-image">Build an application image</a><a class="nav-link" href="#build-a-container-image-tarball">Build a container image tarball</a><a class="nav-link" href="#build-and-deploy-a-container-image-to-a-docker-daemon">Build and deploy a container image to a Docker daemon</a><a class="nav-link" href="#build-and-deploy-a-container-image-to-a-remote-repository">Build and deploy a container image to a remote repository</a>
                              </nav><a class="nav-link" href="#goals">Goals</a>
                              <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#overview-3">Overview</a><a class="nav-link" href="#invernobuild-app">inverno:build-app</a><a class="nav-link" href="#invernobuild-image">inverno:build-image</a><a class="nav-link" href="#invernobuild-image-docker">inverno:build-image-docker</a><a class="nav-link" href="#invernobuild-image-tar">inverno:build-image-tar</a><a class="nav-link" href="#invernobuild-runtime">inverno:build-runtime</a><a class="nav-link" href="#invernohelp">inverno:help</a><a class="nav-link" href="#invernorun">inverno:run</a><a class="nav-link" href="#invernostart">inverno:start</a><a class="nav-link" href="#invernostop">inverno:stop</a>
                              </nav>
                            </nav><a class="nav-link" href="#inverno-oss-parent">Inverno OSS Parent</a>
                            <nav class="nav nav-pills flex-column ms-2 my-1">
                              <a class="nav-link" href="#dependencies">Dependencies</a><a class="nav-link" href="#maven-plugins">Maven Plugins</a>
                            </nav>
                        </nav>
                    </nav>
                </section>
                <section class="markdown col p-3 overflow-auto">
                    <h2 id="introduction">Introduction</h2>
                    <p>The <strong>Inverno Framework</strong> has been created with the objective of facilitating the creation of Java enterprise applications with maximum modularity, performance, maintainability and customizability.</p>
                    <p>New technologies are emerging all the time questioning what has been working for years, We strongly believe that we must instead recognize and preserve proven solutions and only provide what is missing or change what is no longer in line with widely accepted evolutions. The Java platform has proven to be resilient to change and offers features that make it an ideal choice to create durable and efficient applications in complex technical and organizational environments which is precisely what is expected in an enterprise world. The Inverno Framework is a fully integrated suite of modules built for the Java platform that fully embrace this philosophy by keeping things well organized, strict and explicit with clean APIs and comprehensive documentation.</p>
                    <p>The Inverno framework is open source and licensed under version 2.0 of the <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License</a>.</p>
                    <h3 id="design-principles">Design principles</h3>
                    <p>A Inverno application is inherently modular, <strong>modularity</strong> is a key design principle which guarantees a proper separation of concerns providing flexibility, maintainability, stability and ease of development regardless of the lifespan of an application or the number of people involved to develop it. A Inverno module is built as a standard Java module extending the <a href="https://en.wikipedia.org/wiki/Java_Platform_Module_System">Java module system</a> with <a href="https://en.wikipedia.org/wiki/Inversion_of_control">Inversion of Control</a> and <a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a> performed at compile time.</p>
                    <p>The Inverno Framework extends the Java compiler to generate code at compile time when it makes sense to do so which is strictly why annotations were initially created for. When done appropriately, <strong>code generation</strong> can be extremely valuable: issues can be detected ahead of time by analyzing the code during compilation, runtime footprint can be reduced by transferring costly processing like IoC/DI to the compiler improving runtime performance at the same time.</p>
                    <p>The framework uses a state of the art threading model and it has been designed from the ground up to be fully non-blocking and reactive in order to deliver very <strong>high performance</strong> while simplifying development of highly distributed applications requiring back pressure management.</p>
                    <p>The inherent modularity of the framework based on the Java module system guarantees a nice and clean project structure which prevents misuse and abuse by clearly separating the concerns and exposing <strong>well designed APIs</strong>.</p>
                    <p>Special attention has been paid to <strong>configuration</strong> and <strong>customization</strong> which are often overlooked and yet vital to create applications that can adapt to any environment or context.</p>
                    <h3 id="getting-help">Getting help</h3>
                    <p>We provide here a reference guide that starts by an overview of the Inverno core, modules and tools projects which gives a good idea of what can be done with the framework followed by a more comprehensive documentation that should guide you in the creation of an Inverno project using the Inverno distribution, the use of the core IoC/DI framework, the various modules including the configuration and the Web server modules and the tools to run, package and distribute Inverno components and applications.</p>
                    <p>The <a href="../../../../docs/release/api/index.html">API documentation</a> provides plenty of details on how to use the various APIs. The <a href="../../../../docs/getting-started/html/index.html">getting started guide</a> is also a good starting point to get into it.</p>
                    <p>Feel free to report bugs and feature requests or simply ask questions using <a href="https://github.com/inverno-io/inverno-core/issues">GitHub</a>'s issue tracking system if you ran in any issue or wish to see some new functionalities implemented in the framework.</p>
                    <h2 id="overview">Overview</h2>
                    <h3 id="inverno-core">Inverno Core</h3>
                    <p><a href="https://github.com/inverno-io/inverno-core/actions/workflows/maven.yml"><img src="https://github.com/inverno-io/inverno-core/actions/workflows/maven.yml/badge.svg" alt="CI/CD" /></a></p>
                    <p>The <a href="https://www.inverno.io">Inverno core framework</a> project provides an Inversion of Control and Dependency Injection framework for the Java™ platform. It has the particularity of not using reflection for object instantiation and dependency injection, everything being verified and done statically during compilation.</p>
                    <p>This approach has many advantages over other IoC/DI solutions starting with the static checking of the bean dependency graph at compile time which guarantees that a program is correct and will run properly. Debugging is also made easier since you can actually access the source code where beans are instantiated and wired together. Finally, the startup time of a program is greatly reduced since everything is known in advance, such program can even be further optimized with ahead of time compilation solutions like <a href="https://www.graalvm.org/">GraalVM</a>...</p>
                    <p>The framework has been designed to build highly modular applications using standard Java modules. An Inverno module supports encapsulation, it only exposes the beans that need to be exposed and it clearly specifies the dependencies it requires to operate properly. This greatly improves program stability over time and simplifies the use of a module. Since an Inverno module has a very small runtime footprint it can also be easily integrated in any application.</p>
                    <h4 id="creating-an-inverno-module">Creating an Inverno module</h4>
                    <p>An <strong>Inverno module</strong> is a regular Java module, that requires <code>io.inverno.core</code> modules, and which is annotated with <code>@Module</code> annotation. The following <em>hello</em> module is a simple Inverno module:</p>
                    <pre><code class="language-java">@io.inverno.core.annotation.Module
module io.inverno.example.hello {
    requires io.inverno.core;
}
</code></pre>
                    <p>An <strong>Inverno bean</strong> can be a regular Java class annotated with <code>@Bean</code> annotation. A bean represents the basic building block of an application which is typically composed of multiple interconnected beans instances. The following <code>HelloService</code> bean can be used to create a basic application:</p>
                    <pre><code class="language-java">package io.inverno.example.hello;

import io.inverno.core.annotation.Bean;

@Bean
public class HelloService {

    public HelloService() {}

    public void sayHello(String name) {
        System.out.println("Hello " + name + "!!!");
    }
}
</code></pre>
                    <p>At compile time, the Inverno framework will generate a module class named after the module, <code>io.inverno.example.hello.Hello</code> in our example. This class contains all the logic required to instantiate and wire the application beans at runtime. It can be used in a Java program to access and use the <code>HelloService</code>. This program can be in the same Java module or in any other Java module which requires module <code>io.inverno.example.hello</code>:</p>
                    <pre><code class="language-java">package io.inverno.example.hello;

import io.inverno.core.v1.Application;

public class Main {
    
    public static void main(String[] args) {
        Hello hello = Application.with(new Hello.Builder()).run();

        hello.helloService().sayHello(args[0]);
    }
}
</code></pre>
                    <h5 id="building-and-running-with-maven">Building and running with Maven</h5>
                    <p>The development of an Inverno module is pretty easy using <a href="https://maven.apache.org/">Apache Maven</a>, you simply need to create a standard Java project that inherits from <code>io.inverno.dist:inverno-parent</code> project and declare a dependency to <code>io.inverno:inverno-core</code>:</p>
                    <pre><code class="language-xml">&lt;!-- pom.xml --&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;io.inverno.dist&lt;/groupId&gt;
        &lt;artifactId&gt;inverno-parent&lt;/artifactId&gt;
        &lt;version&gt;1.5.2&lt;/version&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;io.inverno.example&lt;/groupId&gt;
    &lt;artifactId&gt;hello&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-core&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <p>Java source files for <code>io.inverno.example.hello</code> module must be placed in <code>src/main/java</code> directory, the module can then be built using Maven:</p>
                    <pre><code class="language-plaintext">$ mvn install
</code></pre>
                    <p>You can then run the application:</p>
                    <pre><code class="language-plaintext">$ mvn inverno:run -Dinverno.run.arguments=John

[INFO] --- inverno-maven-plugin:1.3.1:run (default-cli) @ app-hello ---
[INFO] Running project: io.inverno.example.hello@1.0.0-SNAPSHOT...
Hello John!!!

</code></pre>
                    <h5 id="building-and-running-with-pure-java">Building and running with pure Java</h5>
                    <p>You can also choose to build your Inverno module using pure Java commands. Assuming Inverno framework modules are located under <code>lib/</code> directory and Java source files for <code>io.inverno.example.hello</code> module are placed in <code>src/io.inverno.example.hello</code> directory, you can build the module with the <code>javac</code> command:</p>
                    <pre><code class="language-plaintext">$ javac --processor-module-path lib/ --module-path lib/ --module-source-path src/ -d jmods/ --module io.inverno.example.hello 
</code></pre>
                    <p>The application can then be run as follows:</p>
                    <pre><code class="language-plaintext">$ java --module-path lib/:jmods/ --module io.inverno.example.hello/io.inverno.example.hello.Main John
Hello John!!!
</code></pre>
                    <h3 id="inverno-modules">Inverno Modules</h3>
                    <p><a href="https://github.com/inverno-io/inverno-mods/actions/workflows/maven.yml"><img src="https://github.com/inverno-io/inverno-mods/actions/workflows/maven.yml/badge.svg" alt="CI/CD" /></a></p>
                    <p>The <a href="https://www.inverno.io">Inverno modules framework</a> project provides a collection of components for building highly modular and powerful applications on top of the <a href="https://github.com/inverno-io/inverno-core">Inverno IoC/DI framework</a>.</p>
                    <p>While being fully integrated, any of these modules can also be used individually in any application thanks to the high modularity and low footprint offered by the Inverno framework.</p>
                    <p>The objective is to provide a complete consistent set of high end tools and components for the development of fast and maintainable applications.</p>
                    <h4 id="using-a-module">Using a module</h4>
                    <p>Modules can be used in a Inverno module by defining dependencies in the module descriptor. For instance you can create a Web application module using the <em>boot</em> and <em>web</em> modules:</p>
                    <pre><code class="language-java">@io.inverno.core.annotation.Module
module io.inverno.example.webApp {
    requires io.inverno.mod.boot;
    requires io.inverno.mod.web;
}
</code></pre>
                    <p>A simple microservice application can then be created in a few lines of code as follows:</p>
                    <pre><code class="language-java">import io.inverno.core.annotation.Bean;
import io.inverno.core.v1.Application;
import io.inverno.mod.base.resource.MediaTypes;
import io.inverno.mod.web.annotation.WebController;
import io.inverno.mod.web.annotation.WebRoute;

@Bean
@WebController
public class MainController {

    @WebRoute( path = "/message", produces = MediaTypes.TEXT_PLAIN)
    public String getMessage() {
        return "Hello, world!";
    }

    public static void main(String[] args) {
        Application.with(new WebApp.Builder()).run();
    }
}
</code></pre>
                    <p>Please refer to <a href="https://github.com/inverno-io/inverno-dist">Inverno distribution</a> for detailed setup and installation instructions.</p>
                    <p>Comprehensive reference documentations are available for <a href="https://github.com/inverno-io/inverno-core/tree/master/doc/reference-guide.md">Inverno core</a> and <a href="https://github.com/inverno-io/inverno-mods/tree/master/doc/reference-guide.md">Inverno modules</a>.</p>
                    <p>Several example projects showing various features are also available in the <a href="https://github.com/inverno-io/inverno-examples">Inverno example project</a>. They can also be used as templates to start new Inverno application or component projects.</p>
                    <p>Feel free to report bugs and feature requests in GitHub's issue tracking system if you ran in any issue or wish to see some new functionalities implemented in the framework.</p>
                    <h4 id="available-modules">Available modules</h4>
                    <p>The framework currently provides the following modules.</p>
                    <h5 id="inverno-base">inverno-base</h5>
                    <p>The foundational APIs of the Inverno framework modules:</p>
                    <ul>
                        <li>Conversion API used to convert objects from/to other objects</li>
                        <li>Concurrent API defining the reactive threading model API</li>
                        <li>Net API providing URI manipulation as well as low level network client and server utilities</li>
                        <li>Reflect API for manipulating parameterized type at runtime</li>
                        <li>Resource API to read/write any kind of resources (eg. file, zip, jar, classpath, module...)</li>
                    </ul>
                    <h5 id="inverno-boot">inverno-boot</h5>
                    <p>The boot Inverno module provides base services to an application:</p>
                    <ul>
                        <li>the reactor which defines the reactive threading model of an application</li>
                        <li>a net service used for the implementation of optimized network clients and servers</li>
                        <li>a media type service used to determine the media type of a resource</li>
                        <li>a resource service used to access resources based on URIs</li>
                        <li>a basic set of converters to decode/encode JSON, parameters (string to primitives or common types), media types (text/plain, application/json, application/x-ndjson...)</li>
                        <li>a worker thread pool used to execute tasks asynchronously</li>
                        <li>a JSON reader/writer</li>
                    </ul>
                    <h5 id="inverno-configuration">inverno-configuration</h5>
                    <p>Application configuration API providing great customization and configuration features to multiple parts of an application (eg. system configuration, multitenant configuration, user preferences...).</p>
                    <p>This module also introduces the <code>.cprops</code> configuration file format which facilitates the definition of complex parameterized configuration.</p>
                    <p>In addition, it also provides implementations for multiple configuration sources:</p>
                    <ul>
                        <li>a command line configuration source used to load configuration from command line arguments</li>
                        <li>a map configuration source used to load configuration stored in map in memory</li>
                        <li>a system environment configuration source used to load configuration from environment variables</li>
                        <li>a system properties configuration source used to load configuration from system properties</li>
                        <li>a <code>.properties</code> file configuration source used to load configuration stored in a <code>.properties</code> file</li>
                        <li>a <code>.cprops</code> file configuration source used to load configuration stored in a <code>.cprops</code> file</li>
                        <li>a Redis configuration source used to load/store configuration from/to a Redis data store with supports for configuration versioning</li>
                        <li>a composite configuration source used to combine multiple sources with support for smart defaulting</li>
                        <li>an application configuration source used to load the system configuration of an application from a set of common configuration sources in a specific order, for instance: command line, system properties, system environment, local <code>configuration.cprops</code> file and <code>configuration.cprops</code> file resource in the application module</li>
                    </ul>
                    <p>Configurations are defined as simple interfaces in a module which are processed by the Inverno compiler to generate configuration loaders and beans to make them available in an application with no further effort.</p>
                    <h5 id="inverno-http-base">inverno-http-base</h5>
                    <p>The Inverno HTTP base module provides the foundational API as well as common services for HTTP client and server development, in particular an extensible HTTP header service used to decode and encode HTTP headers.</p>
                    <h5 id="inverno-http-server">inverno-http-server</h5>
                    <p>The Inverno HTTP server module provides a fully reactive HTTP/1.x and HTTP/2 server implementation based on Netty.</p>
                    <p>It supports the following features:</p>
                    <ul>
                        <li>SSL</li>
                        <li>HTTP compression/decompression</li>
                        <li>Server-sent events</li>
                        <li>HTTP/2 over cleartext upgrade</li>
                        <li>URL encoded form data</li>
                        <li>Multipart form data</li>
                    </ul>
                    <h5 id="inverno-irt">inverno-irt</h5>
                    <p>The Inverno Reactive Template module provides a reactive template engine including:</p>
                    <ul>
                        <li>reactive, near zero-copy rendering</li>
                        <li>statically types template generated by the Inverno compiler at compile time</li>
                        <li>pipes for data transformation</li>
                        <li>functional syntax inspired from XSLT and Erlang on top of the Java language that perfectly embraces reactive principles</li>
                    </ul>
                    <h5 id="inverno-ldap">inverno-ldap</h5>
                    <p>The Inverno LDAP module specifies a reactive API for querying <a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol">LDAP</a> servers. It also includes a basic LDAP client implementation based on the JDK. It supports bind and search operations.</p>
                    <h5 id="inverno-redis">inverno-redis</h5>
                    <p>The Inverno Redis client module specifies a reactive API for executing Redis commands on a <a href="https://redis.io/">Redis</a> data store. It supports:</p>
                    <ul>
                        <li>batch queries</li>
                        <li>transaction</li>
                    </ul>
                    <h5 id="inverno-redis-lettuce">inverno-redis-lettuce</h5>
                    <p>The Inverno Redis client Lettuce implementation module provides Redis implementation on top of <a href="https://lettuce.io">Lettuce</a> async pool.</p>
                    <p>It also exposes a Redis Client bean backed by a Lettuce client and created using the module's configuration. It can be used as is to send commands to a Redis data store.</p>
                    <h5 id="inverno-security">inverno-security</h5>
                    <p>The Inverno Security module specifies an API for authenticating request to an application and controlling the access to protected services or resources. It provides:</p>
                    <ul>
                        <li>User/password authentication against a user repository (in-memory, Redis...).</li>
                        <li>Token based authentication.</li>
                        <li>Strong user identification against a user repository (in-memory, Redis...).</li>
                        <li>Secured password encoding using message digest, Argon2, Password-Based Key Derivation Function (PBKDF2), BCrypt, SCrypt...</li>
                        <li>Role-based access control.</li>
                        <li>Permission-based access control.</li>
                    </ul>
                    <h5 id="inverno-security-http">inverno-security-http</h5>
                    <p>The Inverno Security HTTP module is an extension to the Inverno Security module that provides a specific API and base implementations for securing applications accessed via HTTP. It provides supports for:</p>
                    <ul>
                        <li>HTTP basic authentication scheme.</li>
                        <li>HTTP digest authentication scheme.</li>
                        <li>Form based authentication.</li>
                        <li>Cross-origin resource sharing support CORS.</li>
                        <li>Protection against Cross-site request forgery attack CSRF.</li>
                    </ul>
                    <h5 id="inverno-security-ldap">inverno-security-ldap</h5>
                    <p>The Inverno Security LDAP module is an extension to the Inverno Security module that provides support for authentication and identification against LDAP and Active Directory servers.</p>
                    <h5 id="inverno-security-jose">inverno-security-jose</h5>
                    <p>The Inverno Security JOSE module is a complete implementation of JSON Object Signing and Encryption RFCs. It provides:</p>
                    <ul>
                        <li>a JWK service used to manipulate JSON Web Key as specified by <a href="https://datatracker.ietf.org/doc/html/rfc7517">RFC 7517</a> and <a href="https://datatracker.ietf.org/doc/html/rfc7518">RFC 7518</a>.</li>
                        <li>a JWS service used to create and validate JWS tokens as specified by <a href="https://datatracker.ietf.org/doc/html/rfc7515">RFC 7515</a>.</li>
                        <li>a JWE service used to create and decrypt JWE tokens as specified by <a href="https://datatracker.ietf.org/doc/html/rfc7516">RFC 7516</a>.</li>
                        <li>a JWT service used to create, validate or decrypt JSON Web Tokens as JWS or JWE as specified by <a href="https://datatracker.ietf.org/doc/html/rfc7519">RFC 7519</a>.</li>
                        <li>JWS and JWE compact and JSON representations support.</li>
                        <li>JSON Web Key Thumbprint support as specified by <a href="https://datatracker.ietf.org/doc/html/rfc7638">RFC 7638</a>.</li>
                        <li>support for JWS Unencoded Payload Option as specified by <a href="https://datatracker.ietf.org/doc/html/rfc7797">RFC 7797</a>.</li>
                        <li>CFRG Elliptic Curve Diffie-Hellman (ECDH) and Signatures support as specified by <a href="https://datatracker.ietf.org/doc/html/rfc8037">RFC 8037</a>.</li>
                        <li>CBOR Object Signing and Encryption (COSE) as specified by <a href="https://datatracker.ietf.org/doc/html/rfc8812">RFC 8812</a>.</li>
                    </ul>
                    <h5 id="inverno-sql">inverno-sql</h5>
                    <p>The Inverno SQL client module specifies a reactive API for executing SQL statements on a RDBMS. It supports:</p>
                    <ul>
                        <li>prepared statement</li>
                        <li>batch execution</li>
                        <li>transaction</li>
                    </ul>
                    <h5 id="inverno-sql-vertx">inverno-sql-vertx</h5>
                    <p>The Inverno SQL client Vert.x implementation module provides SQL Client implementations on top of <a href="https://github.com/eclipse-vertx/vertx-sql-client">Vert.x</a> pool and pooled client.</p>
                    <p>It also exposes a pool based Sql Client bean created using the module's configuration that can be used as is to query a RDBMS.</p>
                    <h5 id="inverno-web">inverno-web</h5>
                    <p>The Inverno Web module provides advanced features on top of the HTTP server module, including:</p>
                    <ul>
                        <li>request routing based on path, path pattern, HTTP method, request and response content negotiation including request and response content type and language of the response.</li>
                        <li>path parameters</li>
                        <li>interceptors</li>
                        <li>transparent payload conversion based on the content type of the request or the response from raw representation (arrays of bytes) to Java objects</li>
                        <li>transparent parameter (path, cookie, header, query...) conversion from string to Java objects</li>
                        <li>static resource handler to serve static resources from various location based on the resource API</li>
                        <li>a complete set of annotations for easy REST controller development</li>
                    </ul>
                    <p>REST controllers can be easily defined using annotations which are processed by the Inverno compiler to generate the Web server configuration. The compiler also checks that everything is in order as for example that there are no conflicting routes.</p>
                    <h3 id="inverno-tools">Inverno Tools</h3>
                    <p><a href="https://github.com/inverno-io/inverno-tools/actions/workflows/maven.yml"><img src="https://github.com/inverno-io/inverno-tools/actions/workflows/maven.yml/badge.svg" alt="CI/CD" /></a></p>
                    <p>The Inverno framework provides tools for running and building modular Java applications and Inverno applications in particular. It allows for instance to create native runtime and application images providing all the dependencies required to run a modular application. It is also possible to build Docker and <a href="https://github.com/opencontainers/image-spec">OCI</a> images.</p>
                    <h4 id="inverno-maven-plugin">Inverno Maven Plugin</h4>
                    <p>The <a href="https://github.com/inverno-io/inverno-tools/tree/master/inverno-maven-plugin">Inverno Maven Plugin</a> provides specific goals to:</p>
                    <ul>
                        <li>run a modular Java application.</li>
                        <li>start/stop a modular Java application during the build process to execute integration tests.</li>
                        <li>build native a runtime image containing a set of modules and their dependencies creating a light Java runtime.</li>
                        <li>build native an application image containing an application and all its dependencies into an easy to install platform dependent package (eg. <code>.deb</code>, <code>.rpm</code>, <code>.dmg</code>, <code>.exe</code>, <code>.msi</code>...).</li>
                        <li>build docker or OCI images of an application into a tarball, a Docker daemon or a container image registry.</li>
                    </ul>
                    <p>The plugin requires <a href="https://jdk.java.net/">JDK</a> 15+ and <a href="https://maven.apache.org/download.cgi">Apache Maven</a> 3.6.0 or later.</p>
                    <h2 id="inverno-distribution">Inverno Distribution</h2>
                    <p><a href="https://github.com/inverno-io/inverno-dist/actions/workflows/maven.yml"><img src="https://github.com/inverno-io/inverno-dist/actions/workflows/maven.yml/badge.svg" alt="CI/CD" /></a></p>
                    <p>The Inverno distribution provides a parent POM <code>io.inverno.dist:inverno-parent</code> and a BOM <code>io.inverno.dist:inverno-dependencies</code> for developing Inverno components and applications.</p>
                    <p>The parent POM inherits from the BOM which inherits from the <a href="https://github.com/inverno-io/inverno-oss-parent">Inverno OSS parent</a> POM. It provides basic build configuration for building Inverno components and applications, including dependency management and plugins configuration. It especially includes configuration for the <a href="https://github.com/inverno-io/inverno-tools/tree/master/inverno-maven-plugin">Inverno Maven plugin</a>.</p>
                    <p>The BOM specifies the <a href="https://github.com/inverno-io/inverno-core">Inverno core</a> and <a href="https://github.com/inverno-io/inverno-mods">Inverno modules</a> dependencies as well as OSS dependencies.</p>
                    <p>The Inverno distribution thus defines a consistent sets of dependencies and configuration for developing, building, packaging and distributing Inverno components and applications. Upgrading the Inverno framework version of a project boils down to upgrade the Inverno distribution version which is the version of the Inverno parent POM or the Inverno BOM.</p>
                    <h3 id="requirements">Requirements</h3>
                    <p>The Inverno framework requires <a href="https://jdk.java.net/">JDK</a> 15 or later and <a href="https://maven.apache.org/download.cgi">Apache Maven</a> 3.6.0 or later.</p>
                    <h3 id="creating-an-inverno-project">Creating an Inverno project</h3>
                    <p>The recommended way to start a new Inverno project is to create a Maven project which inherits from the <code>io.inverno.dist:inverno-parent</code> project, we might also want to add a dependency to <code>io.inverno:inverno-core</code> in order to create an Inverno module with IoC/DI:</p>
                    <pre><code class="language-xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;io.inverno.dist&lt;/groupId&gt;
        &lt;artifactId&gt;inverno-parent&lt;/artifactId&gt;
        &lt;version&gt;1.5.2&lt;/version&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;io.inverno.example&lt;/groupId&gt;
    &lt;artifactId&gt;sample-app&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-core&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <p>That is all we need to develop, run, build, package and distribute a basic Inverno component or application. The Inverno parent POM provides dependency management and Java compiler configuration to invoke the Inverno compiler during the build process as well as Inverno tools configuration to be able to run and package the Inverno component or application.</p>
                    <p>If it is not possible to inherit from the Inverno parent POM, we can also declare the Inverno BOM <code>io.inverno.dist:inverno-dependencies</code> in the <code>&lt;dependencyManagement/&gt;</code> section to benefit from dependency management but loosing plugins configuration which must then be recovered from the Inverno parent POM.</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;io.inverno.dist&lt;/groupId&gt;
                &lt;artifactId&gt;inverno-dependencies&lt;/artifactId&gt;
                &lt;version&gt;1.5.2&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
&lt;/project&gt;
</code></pre>
                    <p>Inverno modules dependencies can be added in the <code>&lt;dependencies/&gt;</code> section of the project POM. For instance the following dependencies can be added to develop a REST microservice application:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-boot&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <p>Please refer to the <a href="https://github.com/inverno-io/inverno-core/tree/master/doc/reference-guide.md">Inverno core documentation</a> and <a href="https://github.com/inverno-io/inverno-mods/tree/master/doc/reference-guide.md">Inverno modules documentation</a> to learn how to develop with IoC/DI and how to use Inverno modules.</p>
                    <h4 id="developing-a-simple-inverno-application">Developing a simple Inverno application</h4>
                    <p>We can now start developing a sample REST application. An Inverno component or application is a regular Java module annotated with <code>@io.inverno.core.annotation.Module</code>, so the first thing we need to do is to create Java module descriptor <code>module-info.java</code> under <code>src/main/java</code> which is where Maven finds the sources to compile.</p>
                    <pre><code class="language-java">@io.inverno.core.annotation.Module
module io.inverno.example.sample_app {
    requires io.inverno.mod.boot;
    requires io.inverno.mod.web;
}
</code></pre>
                    <p>Note that we declared the <code>io.inverno.mod.boot</code> and <code>io.inverno.mod.web</code> module dependencies since we want to create a REST application, please refer to the <a href="https://github.com/inverno-io/inverno-mods/tree/master/doc/reference-guide.md">Inverno modules documentation</a> to learn more.</p>
                    <p>We then can create the main class of our sample REST application in <code>src/main/java/io/inverno/example/sample_app/App.java</code>:</p>
                    <pre><code class="language-java">package io.inverno.example.sample_app;

import io.inverno.core.annotation.Bean;
import io.inverno.core.v1.Application;
import io.inverno.mod.base.resource.MediaTypes;
import io.inverno.mod.web.annotation.WebController;
import io.inverno.mod.web.annotation.WebRoute;

@Bean
@WebController
public class App {

    @WebRoute( path = "/message", produces = MediaTypes.TEXT_PLAIN)
    public String getMessage() {
        return "Hello, world!";
    }

    public static void main(String[] args) {
        Application.with(new Sample_app.Builder()).run();
    }
}
</code></pre>
                    <h4 id="configuring-logging">Configuring logging</h4>
                    <p>Inverno framework is using <a href="https://logging.apache.org/log4j/2.x/index.html">Log4j 2</a> for logging, Inverno application logging can be activated by adding the dependency to <code>org.apache.logging.log4j:log4j-core</code>:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <blockquote>
                        <p>If you don't include this dependency at runtime, Log4j falls back to the <code>SimpleLogger</code> implementation provided with the API and configured using <code>org.apache.logging.log4j.simplelog.*</code> system properties. The log level can then be configured by setting <code>-Dorg.apache.logging.log4j.simplelog.level=INFO</code> system property when running the application.</p>
                    </blockquote>
                    <p>Log4j 2 provides a default configuration with a default root logger level set to <code>ERROR</code>, resulting in no info messages being output when starting an application. This can be changed by setting <code>-Dorg.apache.logging.log4j.level=INFO</code> system property when running the application.</p>
                    <p>However the recommended way is to provide a specific <code>log4j2.xml</code> logging configuration file in the project resources under <code>src/main/resources</code>:</p>
                    <pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;Configuration xmlns="http://logging.apache.org/log4j/2.0/config"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://logging.apache.org/log4j/2.0/config https://raw.githubusercontent.com/apache/logging-log4j2/rel/2.14.0/log4j-core/src/main/resources/Log4j-config.xsd" 
    status="WARN" shutdownHook="disable"&gt;

    &lt;Appenders&gt;
        &lt;Console name="LogToConsole" target="SYSTEM_OUT"&gt;
             &lt;PatternLayout pattern="%d{DEFAULT} %highlight{%-5level} [%t] %c{1.} - %msg%n%ex"/&gt;
        &lt;/Console&gt;
    &lt;/Appenders&gt;
    &lt;Loggers&gt;
        &lt;Root level="info"&gt;
            &lt;AppenderRef ref="LogToConsole"/&gt;
        &lt;/Root&gt;
    &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
                    <blockquote>
                        <p>Note that the Log4j shutdown hook must be disabled so as not to interfere with the Inverno application shutdown hook, if it is not disabled, application shutdown logs might be dropped.</p>
                    </blockquote>
                    <blockquote>
                        <p>We could have chosen to provide a default logging configuration in the Inverno framework itself, but we preferred to stick to standard Log4j 2 configuration rules in order to keep things simple so please refer to the <a href="https://logging.apache.org/log4j/2.x/manual/configuration.html">Log4j 2 configuration documentation</a> to learn how to configure logging.</p>
                    </blockquote>
                    <h4 id="running-the-application">Running the application</h4>
                    <p>The application is now ready and can be run using the <code>inverno:run</code> goal:</p>
                    <pre><code class="language-plaintext">$ mvn inverno:run

...
[INFO] --- inverno-maven-plugin:1.3.1:run (default-cli) @ sample-app ---
[INFO] Running project: io.inverno.example.sample_app@1.0.0-SNAPSHOT...
 [═══════════════════════════════════════════════ 100&nbsp;% ══════════════════════════════════════════════] 
2021-04-08 23:50:35,261 INFO  [main] i.w.c.v.Application - Inverno is starting...


     ╔════════════════════════════════════════════════════════════════════════════════════════════╗
     ║                      , ~~ ,                                                                ║
     ║                  , '   /\   ' ,                                                            ║
     ║                 , __   \/   __ ,      _                                                    ║
     ║                ,  \_\_\/\/_/_/  ,    | |  ___  _    _  ___   __  ___   ___                 ║
     ║                ,    _\_\/_/_    ,    | | / _ \\ \  / // _ \ / _|/ _ \ / _ \                ║
     ║                ,   __\_/\_\__   ,    | || | | |\ \/ /|  __/| | | | | | |_| |               ║
     ║                 , /_/ /\/\ \_\ ,     |_||_| |_| \__/  \___||_| |_| |_|\___/                ║
     ║                  ,     /\     ,                                                            ║
     ║                    ,   \/   ,                                  -- 1.5.1 --                 ║
     ║                      ' -- '                                                                ║
     ╠════════════════════════════════════════════════════════════════════════════════════════════╣
     ║ Java runtime        : OpenJDK Runtime Environment                                          ║
     ║ Java version        : 16+36-2231                                                           ║
     ║ Java home           : /home/jkuhn/Devel/jdk/jdk-16                                         ║
     ║                                                                                            ║
     ║ Application module  : io.inverno.example.sample_app                                        ║
     ║ Application version : 1.0.0-SNAPSHOT                                                       ║
     ║ Application class   : io.inverno.example.sample_app.App                                    ║
     ║                                                                                            ║
     ║ Modules             :                                                                      ║
     ║  * ...                                                                                     ║
     ╚════════════════════════════════════════════════════════════════════════════════════════════╝


2021-04-08 23:50:35,266 INFO  [main] i.w.e.s.Sample_app - Starting Module io.inverno.example.sample_app...
2021-04-08 23:50:35,266 INFO  [main] i.w.m.b.Boot - Starting Module io.inverno.mod.boot...
2021-04-08 23:50:35,446 INFO  [main] i.w.m.b.Boot - Module io.inverno.mod.boot started in 179ms
2021-04-08 23:50:35,446 INFO  [main] i.w.m.w.Web - Starting Module io.inverno.mod.web...
2021-04-08 23:50:35,446 INFO  [main] i.w.m.h.s.Server - Starting Module io.inverno.mod.http.server...
2021-04-08 23:50:35,446 INFO  [main] i.w.m.h.b.Base - Starting Module io.inverno.mod.http.base...
2021-04-08 23:50:35,450 INFO  [main] i.w.m.h.b.Base - Module io.inverno.mod.http.base started in 3ms
2021-04-08 23:50:35,545 INFO  [main] i.w.m.h.s.i.HttpServer - HTTP Server (nio) listening on http://0.0.0.0:8080
2021-04-08 23:50:35,546 INFO  [main] i.w.m.h.s.Server - Module io.inverno.mod.http.server started in 99ms
2021-04-08 23:50:35,546 INFO  [main] i.w.m.w.Web - Module io.inverno.mod.web started in 99ms
2021-04-08 23:50:35,546 INFO  [main] i.w.e.s.Sample_app - Module io.inverno.example.sample_app started in 281ms

</code></pre>
                    <p>We can now test the application:</p>
                    <pre><code class="language-plaintext">$ curl http://127.0.0.1:8080/message
Hello, world!
</code></pre>
                    <p>The application can be gracefully shutdown by pressing <code>Ctrl-c</code>.</p>
                    <h4 id="building-the-application-image">Building the application image</h4>
                    <p>In order to create a native image containing the application and all its dependencies including JDK's dependencies, we can simply invoke the <code>inverno:build-app</code> goal:</p>
                    <pre><code class="language-plaintext">$ mvn inverno:build-app

...
[INFO] Building application image: /home/jkuhn/Devel/git/frmk/io.inverno.example.sample-app/target/maven-inverno/application_linux_amd64/sample-app-1.0.0-SNAPSHOT...
 [═══════════════════════════════════════════════  67&nbsp;% ═════════════&gt;                                ] Creating archive sample-app-1.0.0-SNAPSHOT-application_linux_amd64.zip...
</code></pre>
                    <blockquote>
                        <p>This uses <code>jpackage</code> tool which is an incubating feature in JDK&lt;16, if you intend to build an application image with an old JDK, you'll need to explicitly add the <code>jdk.incubator.jpackage</code> module in <code>MAVEN_OPTS</code>:</p>
                        <pre><code class="language-plaintext">$ export MAVEN_OPTS="--add-modules jdk.incubator.jpackage"
</code></pre>
                    </blockquote>
                    <p>This will create a ZIP archive containing a native application distribution <code>target/sample-app-1.0.0-SNAPSHOT-application_linux_amd64.zip</code> which will be deployed to the local Maven repository and eventually to a remote Maven repository.</p>
                    <p>Then in order to install the application on a compatible platform, we just need to download the archive corresponding to the platform, extract it to some location and run the application. Luckily for us this can be done quite easily with Maven dependency plugin:</p>
                    <pre><code class="language-plaintext">$ mvn dependency:unpack -Dartifact=io.inverno.example:sample-app:1.0.0-SNAPSHOT:zip:application_linux_amd64 -DoutputDirectory=./
...
$ ./sample-app-1.0.0-SNAPSHOT/bin/sample-app
...
</code></pre>
                    <p>It is also possible to create platform specific package such as <code>.deb</code> or a <code>.msi</code> by defining particular formats in the Inverno Maven plugin configuration:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;io.inverno.tool&lt;/groupId&gt;
                &lt;artifactId&gt;inverno-maven-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;build-app&lt;/id&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;build-app&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;formats&gt;
                                &lt;format&gt;zip&lt;/format&gt;
                                &lt;format&gt;deb&lt;/format&gt;
                            &lt;/formats&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
                    <pre><code class="language-plaintext">$ mvn package
...
</code></pre>
                    <blockquote>
                        <p>Note that there is no cross-platform support and a given platform specific format must be built on the platform it runs on.</p>
                    </blockquote>
                    <p>Such platform-specific package can then be downloaded and installed using the right package manager:</p>
                    <pre><code class="language-plaintext">$ mvn dependency:copy -Dartifact=io.inverno.example:sample-app:1.0.0-SNAPSHOT:deb:application_linux_amd64 -DoutputDirectory=./
...
$ sudo dpkg -i sample-app-1.0.0-SNAPSHOT-application_linux_amd64.deb
...
$ /opt/sample-app/bin/sample-app
...
</code></pre>
                    <p>The Inverno Maven plugin allows to create various application images including Docker or OCI container images, please refer to the <a href="https://github.com/inverno-io/inverno-tools/tree/master/inverno-maven-plugin">Inverno Maven plugin documentation</a> to learn more.</p>
                    <h2 id="inverno-core-1">Inverno Core</h2>
                    <h3 id="motivation">Motivation</h3>
                    <p><a href="https://en.wikipedia.org/wiki/Inversion_of_control">Inversion of Control</a> and <a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a> principles are not new and many Java applications have been developed following these principles over the past two decades using frameworks such as Spring, CDI, Guice... However these recognized solutions might have some issues in practice especially with the way Java has evolved and how applications should be developed nowadays.</p>
                    <p>Dependency injection errors like a missing dependency or a cycle in the dependency graph are often reported at runtime when the application is started. Most of the time these issues are easy to fix but when considering big applications split into multiple modules developed by different people, it might become more complex. In any case you can't tell for sure if an application will start before you actually start it.</p>
                    <p>Most IoC/DI frameworks are black boxes, often considered as magical because one gets beans instantiated and wired altogether without understanding what just happened and it is indeed quite hard to figure out how it actually works. This is not a problem as long as everything works as expected but it can become one when you actually need to troubleshoot a failing application.</p>
                    <p>Beans instantiation and wiring are done at runtime using Java reflection which offers all the advantages of Java dynamic linking at the expense of some performance overhead. Classpath scanning, instantiation and wiring process indeed takes some time and prevents just-in-time compilation optimization making application startup quite slow.</p>
                    <p>Although IoC frameworks make the development of modular applications easier, they often require a rigorous methodology to make it the right way. For instance, you must know precisely what components are provided and/or required by all the modules composing an application and make sure one doesn't provide a component that might interfere with another.</p>
                    <p>These points are very high level, please have a look at this <a href="https://inverno.medium.com/reviving-java-ioc-di-and-why-does-it-matters-b1a2b0b57cca">article</a> if you like to learn more about the general ideas behind the Inverno framework. The Inverno framework proposes a new approach of IoC/DI principles consistent with latest developments of the Java™ platform and perfectly adapted to the development of modern applications in Java.</p>
                    <h3 id="prerequisites">Prerequisites</h3>
                    <p>In this documentation, we’ll assume that you have a working knowledge of <a href="https://en.wikipedia.org/wiki/Inversion_of_control">Inversion of Control</a> and <a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a> principles as well as <a href="https://en.wikipedia.org/wiki/Object-oriented_programming">Object Oriented Programming</a>.</p>
                    <h3 id="overview-1">Overview</h3>
                    <p>The Inverno framework is different in many ways and tries to address previous issues. Its main difference is that it doesn't rely on Java reflection at all to instantiate the beans composing an application (IoC) and wire them together (DI), this is actually done by a class generated by the Inverno compiler at compile time.</p>
                    <p>Since beans and their dependencies are determined at compile time, errors can be raised precisely when they make sense during development or at build time.</p>
                    <p>There is also no need for complex runtime libraries since the complexity is handled by the compiler which generates a readable class providing only what is required at runtime. This presents two advantages, first applications have a small footprint and start fast since most of the processing is already done and no reflection is involved. Secondly you will be able to actually debug all parts of your application since nothing is hidden behind a complex library, you can actually see when the beans are instantiated with the <code>new</code> operator opening rooms to other compile and runtime optimization as well.</p>
                    <p>The framework also fully embraces the modular system introduced in Java 9 which basically imposes to develop with modularity in mind. An Inverno module only exposes the beans that must be exposed to other modules and it clearly indicates the beans it requires to operate. All this makes modular development safer, clearer and more natural.</p>
                    <h4 id="modules-and-beans">Modules and Beans</h4>
                    <p>Inversion of control and dependency injection principles have proven to be an elegant and efficient way to create applications in an Object Oriented Programming language. A Java application basically consists in a set of interconnected objects.</p>
                    <p>An Inverno application adds a modular dimension to these principles, the objects or the <strong>beans</strong> composing the application are created and connected in one or more isolated <strong>modules</strong> which are themselves composed in the <strong>application</strong>.</p>
                    <p>A <strong>module</strong> encapsulates several beans and possibly other modules. It specifies the dependencies it needs to operate and only exposes the beans that need to be exposed from the module perspective. As a result it is isolated from the rest of the application, it is unaware of how and where it is used and it actually doesn't care as long as its requirements are met. It really resembles a class which makes it very familiar to use.</p>
                    <p>A <strong>bean</strong> is a component of a module and more widely an application. It has required and optional dependencies provided by the module when a bean instance is created.</p>
                    <p>The <strong>Inverno compiler</strong> is an annotation processor which runs inside the Java compiler and generates module classes based on Inverno annotations found on the modules and classes being compiled.</p>
                    <h4 id="java-module-system">Java module system</h4>
                    <p>Before you can create your first Inverno module, you must first understand what a Java module is and how it might change your life as a Java developer. If you are already familiar with it, you can skip that section and go directly to the <a href="#project-setup">project setup</a> section.</p>
                    <p>The Java module system has been introduced in Java 9 mostly to modularize the overgrowing Java runtime library which is now split into multiple interdependent modules loaded when you need them at runtime or compile time. This basically means that the size of the Java runtime you need to compile and/or run your application now depends on your application's needs which is a pretty big improvement.</p>
                    <p>If you know OSGI or Maven already, you might say that modules have existed in Java for a long time but now they are fully integrated into the language, the compiler and the runtime. You can create a Java module, specify what packages are exposed and what dependencies are required and the good part is that both the compiler and JVM tell you when you do something wrong being as close as possible to the code, there’s no more xml or manifest files to care about.</p>
                    <p>So how do you create a Java module? There is plenty of documentation you can read to have a complete and deep understanding of the Java module system, here we will only explain what you need to know to develop regular Inverno modules.</p>
                    <p>A Java module is specified in a <code>module-info.java</code> file located in the default package. Let's assume you want to create module <code>io.inverno.example.sample</code>, you can create the following file structure:</p>
                    <pre><code class="language-plaintext">src
└── io.inverno.example.sample
    ├── io
    │   └── inverno
    │       └── example
    │           └── sample
    │               ├── internal
    │               │   └── ...
    │               └── ...
    └── module-info.java
</code></pre>
                    <blockquote>
                        <p>This is one way to organize the code, the only important thing is to put the <code>module-info.java</code> descriptor in the default package.</p>
                    </blockquote>
                    <p>Now let's have a closer look at the module descriptor:</p>
                    <pre><code class="language-java">module io.inverno.example.sample {      // 1
    exports io.inverno.example.sample;  // 2
}
</code></pre>
                    <ol>
                        <li>A module is declared using a familiar syntax starting with the <code>module</code> keyword followed by the name of the module which must be a valid Java name.</li>
                        <li>The <code>io.inverno.example.sample</code> module exports the <code>io.inverno.example.sample</code> package which means that other modules can only access public types contained in that package. Any type defined in another package within that module is only visible from within the module following usual Java visibility rules (default, public, protected, private). This basically defines a new level of encapsulation at module level. For instance, types in package <code>io.inverno.example.sample.internal</code> are not accessible to other modules regardless of their visibility.</li>
                    </ol>
                    <p>Now let's say you need to use some external types defined and exported in another module <code>io.inverno.example.other</code>:</p>
                    <pre><code class="language-plaintext">src
├── io.inverno.example.sample
│   ├── ...
│   └── module-info.java
└── io.inverno.example.other
    ├── ...
    └── module-info.java
</code></pre>
                    <p>If you try to reference any of these types in <code>io.inverno.example.sample</code> module as is the compiler will complain with explicit visibility errors unless you specify that <code>io.inverno.example.sample</code> module requires <code>io.inverno.example.other</code> module:</p>
                    <pre><code class="language-java">module io.inverno.example.sample {
    requires io.inverno.example.other;
    
    exports io.inverno.example.sample;
}
</code></pre>
                    <p>You should now be able to reference any public types defined in a package exported in <code>io.inverno.example.other</code> module.</p>
                    <p>The modular system has also changed the way Java applications are built and run. Before we used to specify a classpath listing the locations where the Java compiler and the JVM should look for application's classes whereas now we should specify a module path listing the locations of modules and forget about the classpath.</p>
                    <p>If we consider previous modules, they are compiled and run as follows:</p>
                    <pre><code class="language-plaintext">&gt; javac --module-source-path src -d jmods --module io.inverno.example.sample --module io.inverno.example.other

&gt; java --module-path jmods/ --module io.inverno.example.sample/io.inverno.example.sample.Sample
</code></pre>
                    <p>There are other subtleties like transitive dependencies, service providers or opened modules and cool features like jmod packaging and the <code>jlink</code> tool but for now that's pretty much all you need to know to develop Inverno modules which are basically instrumented Java modules.</p>
                    <p>You should now have a basic understanding of how an Inverno application is built and what Java technologies are involved. An Inverno application results from the composition of multiple isolated modules which create and wire the beans making up the application. Almost everything is done at compile time where module classes are generated.</p>
                    <h3 id="project-setup">Project Setup</h3>
                    <h4 id="maven">Maven</h4>
                    <p>The easiest way to setup an Inverno module project is to start by creating a regular Java Maven project which inherits from <code>io.inverno.dist:inverno-parent</code> project and depends on <code>io.inverno:inverno-core</code>:</p>
                    <pre><code class="language-xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;io.inverno.dist&lt;/groupId&gt;
        &lt;artifactId&gt;inverno-parent&lt;/artifactId&gt;
        &lt;version&gt;1.5.2&lt;/version&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;io.inverno.example&lt;/groupId&gt;
    &lt;artifactId&gt;sample&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;

    ...
    &lt;dependencies&gt;
        ...
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-core&lt;/artifactId&gt;
        &lt;/dependency&gt;
        ...
    &lt;/dependencies&gt;
    ...
    
&lt;/project&gt;
</code></pre>
                    <p>Then you have to add a module descriptor to make it a Java module project. An Inverno module requires <code>io.inverno.core</code> and <code>io.inverno.core.annotation</code> modules. If you want your module to be used in other modules it must also export the package where the module class is generated by the Inverno compiler which is the module name by default. Remember that an Inverno module is materialized in a regular Java class subject to the same rules as any other class in a Java module.</p>
                    <pre><code class="language-java">module io.inverno.example.sample {
    requires io.inverno.core;
    requires io.inverno.core.annotation;
    
    exports io.inverno.example.sample;
}
</code></pre>
                    <p>If you do not want your project to inherit from <code>io.inverno.dist:inverno-parent</code> project, you'll have to explicitly specify compiler source and target version (&gt;=9), dependencies version and configure the Maven compiler plugin to invoke the Inverno compiler.</p>
                    <pre><code class="language-xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;io.inverno.example&lt;/groupId&gt;
    &lt;artifactId&gt;sample&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
    
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
        &lt;version.inverno&gt;1.5.1&lt;/version.inverno&gt;
        &lt;version.inverno.dist&gt;1.5.2&lt;/version.inverno.dist&gt;
    &lt;/properties&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;io.inverno.dist&lt;/groupId&gt;
                &lt;artifactId&gt;inverno-dependencies&lt;/artifactId&gt;
                &lt;version&gt;${version.inverno.dist}&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-core&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    
    &lt;build&gt;
        &lt;plugins&gt;
            ...
            &lt;plugin&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;annotationProcessorPaths&gt;
                        &lt;path&gt;
                            &lt;groupId&gt;io.inverno&lt;/groupId&gt;
                            &lt;artifactId&gt;inverno-core-compiler&lt;/artifactId&gt;
                            &lt;version&gt;${version.inverno}&lt;/version&gt;
                        &lt;/path&gt;
                    &lt;/annotationProcessorPaths&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
            ...
        &lt;plugin&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
                    <p>An Inverno module is built just as a regular Maven project using maven commands (compile, package, install...). The module class is generated and compiled during the <code>compile</code> phase and included in the resulting JAR file during the <code>package</code> phase. If anything related to IoC/DI goes wrong during compilation, the compilation fails with explicit compilation errors reported by the Inverno compiler.</p>
                    <h4 id="gradle">Gradle</h4>
                    <p>Since version 6.4, it is also possible to use <a href="https://gradle.org/">Gradle</a> to build Inverno module projects. Here is a sample <code>build.gradle</code> file:</p>
                    <pre><code class="language-java">plugins {
    id 'application'
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'io.inverno:inverno-core:1.5.1'
    annotationProcessor 'io.inverno:inverno-core-compiler:1.5.1'
}

java {
    modularity.inferModulePath = true
    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11
}

application {
    mainModule = 'io.inverno.example.hello'
    mainClassName = 'io.inverno.example.hello.App'
}
</code></pre>
                    <h3 id="bean">Bean</h3>
                    <p>As you already know, a Java application can be reduced to the composition of objects working together. In an Inverno application, these objects are instantiated and injected into each other by one or more modules. Inside a module, a bean basically specifies what it needs to create a bean instance (DI) and how to obtain it (IoC).</p>
                    <p>A bean and a bean instance are two different things that should not be confused. A bean can result in multiple bean instances in the application whereas a bean instance always refers to exactly one bean. A bean is like a plan used to create instances.</p>
                    <p>A bean is fully identified by its name and the module in which it resides. The following notation is used to represent a bean qualified name: <code>[MODULE]:[BEAN]</code>. As a consequence, two beans with the same name cannot exist in the same module but it is safe to have multiple beans with the same name in different modules.</p>
                    <h4 id="module-bean">Module Bean</h4>
                    <p>Module bean is the primary type of beans you can create in an Inverno module. It is defined by a concrete class annotated with the <code>@Bean</code> annotation.</p>
                    <pre><code class="language-java">import io.inverno.core.annotation.Bean;
    
@Bean
public class SomeBean {
    ...
}
</code></pre>
                    <p>In the previous code we created a bean of type <code>SomeBean</code>. At compile time, the Inverno compiler will include it in the generated module class that you'll eventually use at runtime to obtain <code>SomeBean</code> instances.</p>
                    <p>By default, a bean is named after the simple name of the class starting with a lower case (eg. <code>someBean</code> in our previous example). This can be specified in the annotation using the name attribute:</p>
                    <pre><code class="language-java">@Bean(name="customSomeBean")
public class SomeBean {
    ...
}
</code></pre>
                    <h4 id="wrapper-bean">Wrapper Bean</h4>
                    <p>A wrapper bean is a particular form of bean used to define beans whose code cannot be instrumented with Inverno annotations or that require more complex logic to create the instance. This is especially the case for legacy code or third party libraries.</p>
                    <p>A wrapper bean is defined by a concrete class annotated with both <code>@Bean</code> and <code>@Wrapper</code> annotations which basically wraps the actual bean instance and include the instantiation, initialization and destruction logic. It must implement the <code>Supplier&lt;E&gt;</code> interface which specifies the actual type of the bean as formal parameter.</p>
                    <pre><code class="language-java">@Bean
@Wrapper
public class SomeWrapperBean implements Supplier&lt;SomeLegacyBean&gt; {
    
    private SomeLegacyBean instance;
    
    public SomeWrapperBean() {
        // Creates the wrapped instance 
        this.instance = ...
    }
    
    SomeLegacyBean get() {
        // Returns the wrapped instance
        return this.instance;
    }
    ...
}
</code></pre>
                    <p>In the previous code we created a bean of type <code>SomeLegacyBean</code>. One instance of the wrapper class is used to create exactly one bean instance and it lives as long as the bean instance is referenced.</p>
                    <p>Since a wrapper bean is annotated with <code>@Bean</code> annotation, it can be configured in the exact same way as a module bean except that it only applies to the wrapper instance which is responsible to configure the actual bean instance. The wrapper instance is never exposed, only the actual bean instance wrapped in it is exposed. As for module beans, <code>SomeLegacyBean</code> instances can be obtained using the generated Module class.</p>
                    <blockquote>
                        <p>Note that since a new wrapper instance is created every time a new bean instance is requested, a wrapper class is not required to return a new or distinct result in the <code>get()</code> method. Nonetheless a wrapper instance is used to create, initialize and destroy exactly one instance of the supplied type and as a result it is good practice to have the wrapper instance always return the same bean instance. This is especially true and done naturally when initialization or destruction methods are specified.</p>
                    </blockquote>
                    <blockquote>
                        <p>When designing a prototype wrapper bean, particular care must be taken to make sure the wrapper does not hold a strong reference to the wrapped instance in order to prevent memory leak when a prototype bean instance is requested by the application. It is strongly advised to rely on <code>WeakReference&lt;&gt;</code> in that particular use case.</p>
                    </blockquote>
                    <h4 id="nested-bean">Nested Bean</h4>
                    <p>A nested bean is, as its name suggests, a bean inside a bean. A nested bean instance is obtained by invoking a particular method on another bean instance. Instances thus obtained participate in dependency injection but unlike other types of bean they do not follow any particular lifecycle or strategy, the implementor of the nested bean method is free to decide whether a new instance should be returned on each invocation.</p>
                    <p>A nested bean is declared in the class of a bean, by annotating a non-void method with no arguments with <code>@NestedBean</code> annotation. The name of a nested bean is given by the name of the bean providing the instance and the name of the annotated method following this notation: <code>[MODULE]:[BEAN].[METHOD_NAME]</code>.</p>
                    <pre><code class="language-java">@Bean
public class SomeBean {

    ...

    @NestedBean
    public SomeNestedBean nestedBean() {
        ...
    }
}
</code></pre>
                    <p>It is also possible to <em>cascade</em> nested beans.</p>
                    <h4 id="overridable">Overridable</h4>
                    <p>A module bean or a wrapper bean can be declared as overridable which allows to override the bean inside the module by a socket bean of the same type.</p>
                    <p>An overridable bean is defined as a module bean or a wrapper bean whose class has been annotated with <code>@Overridable</code>. This basically tells the Inverno compiler to create an extra optional socket bean with the particular feature of being able to take over the bean when an instance is provided on module instantiation.</p>
                    <pre><code class="language-java">@Bean
@Overridable
public class SomeBean {
    
}
</code></pre>
                    <h4 id="lifecycle">Lifecycle</h4>
                    <p>All bean instances follow the subsequent lifecycle in a module:</p>
                    <ol>
                        <li>A bean instance is created</li>
                        <li>It is initialized</li>
                        <li>It is active</li>
                        <li>It is <em>"eventually"</em> destroyed</li>
                    </ol>
                    <p>Let's examine each of these steps in details.</p>
                    <p>A bean instance is always created in a module, when a bean instance is created greatly depends on the context in which it is used, it can be created when a module instance is started or when it is required in the application. In order to create a bean instance the module must provide all the dependencies required by the bean. After that it sets any optional dependencies available on the instance thus obtained. This is actually when and where dependency injection takes place, this aspect will be covered more in details in following sections, for now all you have to know is that when requested the module creates a fully wired bean instance.</p>
                    <p>After that the module invokes initialization methods on the bean instance to initialize it. An initialization method is declared on the bean class using the <code>@Init</code> annotation:</p>
                    <pre><code class="language-java">@Bean
public class SomeBean {
    
    @Init
    public void init() {
        ...
    }
}
</code></pre>
                    <p>You can specify multiple initialization methods but the order in which they are invoked is undetermined. Inheritance is not considered here, only the methods annotated on the bean class are considered. Bean initialization is useful when you want to execute some code after dependency injection to make the bean instance fully functional (eg. initialize a connection pool, start a server socket...).</p>
                    <p>After that, the bean instance is active and can be used either directly by accessing it from the module or indirectly through another bean instance where it has been injected.</p>
                    <p>A bean instance is <em>"eventually"</em> destroyed, typically when its enclosing module instance is stopped. Just as you specified initialization methods, you can specify destruction methods to be invoked when a bean instance is destroyed using the <code>@Destroy</code> annotation:</p>
                    <pre><code class="language-java">@Bean
public class SomeBean {
    
    @Destroy
    public void destroy() {
        ...
    }
}
</code></pre>
                    <p>As for initialization methods, you can specify multiple destruction methods but the order in which they are invoked is undetermined and inheritance is also not considered. Bean destruction is useful when you need to free resources that have been allocated by the bean instance during application operation (eg. shutdown a connection pool, close a server socket...).</p>
                    <p>In case of wrapper beans, the initialization and destruction of a bean instance is delegated to the initialization and destruction methods specified on the wrapper bean which respectively initialize and destroy the actual bean instance wrapped in the wrapper bean.</p>
                    <pre><code class="language-java">@Bean
@Wrapper
public class SomeWrapperBean implements Supplier&lt;SomeLegacyBean&gt; {
    
    private SomeLegacyBean instance;
    
    public SomeWrapperBean() {
        // Creates the wrapped instance 
        this.instance = ...
    }
    
    @Init
    public void init() {
        // Initialize the wrapped instance
        this.instance.start();
    }
    
    @Destroy
    public void destroy() {
        // Destroy the wrapped instance
        this.instance.stop();
    }
    ...
}
</code></pre>
                    <blockquote>
                        <p>We stated here that all bean instances are eventually destroyed but this is actually not always the case. Depending on the bean strategy and the context in which it is used, it might not be destroyed at all, hopefully workarounds exist to make sure a bean instance is always properly destroyed. We'll cover this more in detail when we'll describe <a href="#strategy">bean strategies</a>.</p>
                    </blockquote>
                    <h4 id="visibility">Visibility</h4>
                    <p>A bean can be assigned a public or private visibility. A public bean is exposed by the module to the rest of the application whereas a private bean is only visible from within the module.</p>
                    <p>Bean visibility is set in the <code>@Bean</code> annotation in the visibility attribute:</p>
                    <pre><code class="language-java">@Bean(visibility=Visibility.PUBLIC)
public class SomeBean {
    
}
</code></pre>
                    <h4 id="strategy">Strategy</h4>
                    <p>A bean is always defined with a particular strategy which controls how a module should create a bean instance when one is requested, either during dependency injection when a module requires a bean instance to inject in another bean instance or during application operation when some application code requests a bean instance to a module instance.</p>
                    <h5 id="singleton">Singleton</h5>
                    <p>The singleton strategy is the default strategy used when no explicit strategy is specified on a bean class. An Inverno module only creates one single instance for a singleton bean. That same instance is returned every time an instance of that bean is requested. It is then shared among all dependent beans through dependency injection and also the application if it has requested an instance.</p>
                    <p>A singleton bean is specified explicitly by setting the <code>strategy</code> attribute to <code>Strategy.SINGLETON</code> in the <code>@Bean</code> annotation:</p>
                    <pre><code class="language-java">@Bean(strategy = Strategy.SINGLETON)
public class SomeSingletonBean {

}
</code></pre>
                    <p>Modules easily support the bean lifecyle for singleton beans since a module instance holds singleton bean instances by design, they can then be properly destroyed when the module instance is stopped.</p>
                    <p>Particular care must be taken when a singleton bean instance is requested to a module instance by the application as the resulting reference will point to a <em>managed</em> instance which will be destroyed when the module instance is stopped leaving the instance referenced in the application in an unpredictable state.</p>
                    <p>A singleton bean is the basic building block of any application which explains why it is the default strategy. An application is basically made of multiple long living components rather than volatile disposable components. A server is a typical example of singleton bean, it is created when the application is started, initialized to accept requests and destroyed when the application is stopped.</p>
                    <blockquote>
                        <p>A singleton instance is held by exactly one module instance, if you instantiate a module twice, you'll get two singleton bean instances, one in the first module instance and the other in the second module instance. This basically differs from the standard singleton pattern, you'll see more in detail why this actually matters when we'll describe <a href="#composite-module">composite modules</a>.</p>
                    </blockquote>
                    <h5 id="prototype">Prototype</h5>
                    <p>A prototype bean results in the creation of as many instances as requested. All dependent beans in the module get a different bean instance and each time a bean instance is requested to a module instance by the application a new instance is also created.</p>
                    <p>A prototype bean is specified by setting the <code>strategy</code> attribute to <code>Strategy.PROTOTYPE</code> in the <code>@Bean</code> annotation:</p>
                    <pre><code class="language-java">@Bean(strategy = Strategy.PROTOTYPE)
public class SomeBean {

}
</code></pre>
                    <p>Unlike singleton beans, modules can't always fully support the bean lifecycle for prototype beans. All prototype beans instances are kept in the module instance in order to destroy them when it is stopped. Modules use weak references to prevent memory leaks so that dereferenced instances are automatically removed from the internal registry when the garbage collector reclaims them. This works well for prototype bean instances injected into singleton bean instances since they are actually referenced until the module instance is stopped just like any singleton bean instance. It becomes tricky when a prototype bean instance is requested by the application. In that case, the prototype bean instance is removed from the module instance when it is dereferenced from the application and reclaimed by the garbage collector leaving no chance for the module instance to destroy it properly. The actual behavior is more subtle because a dereferenced prototype bean instance might actually be destroyed when a module is stopped before the instance is reclaimed by the garbage collector.</p>
                    <p>As a result, it is not recommended to define destruction methods on a prototype bean but if you really need to, you can make your bean implement <code>AutoClosable</code>, specify the <code>close()</code> method as the unique destruction method and request prototype bean instances from the application using a try-with-resources block:</p>
                    <pre><code class="language-java">@Bean(strategy = Strategy.PROTOTYPE)
public class SomeBean implements AutoCloseable {

    @Destroy
    public void close() throws Exception {
        ...
    }
}
</code></pre>
                    <p>Then when requesting a prototype bean instance from the application:</p>
                    <pre><code class="language-java">try(SomeBean bean = module.someBean()) {
    ...
}
</code></pre>
                    <p>As soon as the program exits the try-with-resources block the bean instance is properly destroyed, then dereferenced and eventually reclaimed by the garbage collector and finally removed from the module instance. However you should make sure that the <code>close()</code> method can be called twice since it actually might.</p>
                    <p>Prototype beans should be used whenever there is a need to hold a state in a particular context. An HTTP client is a typical example of a stateful instance, different instances should be created and injected in singleton beans so they can deal with concurrency independently to make sure requests are sent only after a response to the previous request has been received.</p>
                    <blockquote>
                        <p>That might not be the smartest way to use HTTP clients in an application but it gives you the idea.</p>
                    </blockquote>
                    <p>Prototype beans can also be used to implement the factory pattern, just like a factory, you can request new bean instances on a module. Inverno framework makes this actually very powerful since there's no runtime overhead, modules can be created and used anywhere and you never have to worry about the boiler plate code that instantiates the bean since it is generated for you by the framework.</p>
                    <h3 id="module">Module</h3>
                    <p>An Inverno module can be seen as an isolated collection of beans. The role of a module is to create and wire bean instances in order to expose logic to the application.</p>
                    <p>In practice, a module is materialized by the class generated by the Inverno compiler during compilation and which results from the processing of Inverno annotations.</p>
                    <p>A module is isolated from the rest of the application through its module class which clearly defines the beans exposed by the module and what it needs to operate. As a result, a module doesn’t care when and how it is used in an application as long as its requirements are met.</p>
                    <blockquote>
                        <p>Isolation is actually what makes the Inverno framework so special as it greatly simplifies the development of complex modular applications.</p>
                    </blockquote>
                    <p>A module is defined as a regular Java module annotated with the <code>@Module</code> annotation:</p>
                    <pre><code class="language-java">@Module
Module io.inverno.sample.sampleModule {
    ...
}
</code></pre>
                    <h4 id="the-module-class">The module class</h4>
                    <p>Java modules annotated with <code>@Module</code> will be processed by the Inverno compiler at compile time. The Inverno compiler generates one <strong>module class</strong> per module providing all the code required at runtime to create and wire bean instances.</p>
                    <p>This class is the entry point of a module and serve several purposes:</p>
                    <ul>
                        <li>encapsulate beans instances creation and wiring logic</li>
                        <li>implement bean instance lifecyle</li>
                        <li>specify required or optional module dependencies</li>
                        <li>expose public beans</li>
                        <li>hide private beans</li>
                        <li>guarantee a proper isolation of the module within the application</li>
                    </ul>
                    <p>This regular Java class can be instantiated like any other class. It relies on a minimal runtime library barely visible which makes it self-describing and very easy to use.</p>
                    <p>Let’s see how it looks like for the <code>io.inverno.sample.sampleModule</code> module and <code>SomeBean</code> bean, the module class would be used as follows:</p>
                    <pre><code class="language-java">SampleModule module = new SampleModule.Builder().build(); // 1
module.start();                                           // 2

SomeBean someBean = module.someBean();                    // 3
// Do something useful with someBean
module.stop();                                            // 4
</code></pre>
                    <ol>
                        <li>The <code>SampleModule</code> class is instantiated</li>
                        <li>The module is started</li>
                        <li>The <code>SomeBean</code> instance is retrieved</li>
                        <li>Eventually the module is stopped</li>
                    </ol>
                    <p>There are two important things to notice here, first you control when, where and how many times you want to instantiate a module, which brings great flexibility in the way modules are used in your application. For instance integrating an Inverno module in an existing code is pretty straightforward as it is plain old Java, it is also possible to create and use a module instance during application operation (eg. when processing a request). Secondly beans are exposed with their actual types through named methods which eventually produces more secure code because static type checking can (finally) be performed by the compiler.</p>
                    <p>Module classes provide dedicated builders to facilitate the creation of complex modules instances with multiple required and optional dependencies.</p>
                    <p>By default, the module class is named after the last identifier of the module name and generated in a package named after the module. The full class name can be specified in the annotation using the <code>className</code> attribute:</p>
                    <pre><code class="language-java">@Module(className=”io.inverno.sample.CustomSampleModule”)
Module io.inverno.sample.sampleModule {
    ...
}
</code></pre>
                    <p>The module class is like any other class in the module, if you want to use it outside the module you have to explicitly export its package in the module descriptor:</p>
                    <pre><code class="language-java">@Module
Module io.inverno.sample.sampleModule {
    exports io.inverno.sample.sampleModule;
}
</code></pre>
                    <p>Most of the time this is something you’ll do especially if you want to create <a href="#modular-application">composite modules</a>, however if you only use the module class from within the module, typically in a main method or embedded in some other class, you won’t have to do it.</p>
                    <blockquote>
                        <p>Note that the Java compiler fails if you try to export a package which is empty before compilation, since the module class is generated this might actually happen, so you need to make sure the class will be generated in a package containing some code. This is not an ideal situation however a module usually defines and exports a package named after its name so this should solve the issue.</p>
                    </blockquote>
                    <h4 id="lifecycle-1">Lifecycle</h4>
                    <p>Just like a bean instance, a module follows a lifecycle:</p>
                    <ol>
                        <li>A module instance is created</li>
                        <li>It is started</li>
                        <li>It is active</li>
                        <li>It is stopped</li>
                    </ol>
                    <p>Let's examine each of these steps in details.</p>
                    <p>A module instance can be created directly in the application or indirectly inside a composite module. A module defines a dedicated <code>Builder</code> class that must be used to build the module instance. Relying on a builder is very helpful when considering complex modules with many required and optional dependencies.</p>
                    <p>The instance must then be started to make it operational. During this phase, all Inverno modules composed in the module are instantiated and started and all the beans defined in the module are created and initialized. Dependency injection is performed naturally as beans are created. Since everything has been validated at compile time, we know for sure that everything will work properly.</p>
                    <blockquote>
                        <p>A module is actually composed by the beans it defines and the beans defined in the modules it composes. This is discussed in details in the <a href="#modular-application">Modular application</a> section.</p>
                    </blockquote>
                    <p>Once the module instance is active, beans are exposed to the application.</p>
                    <p>Finally, a module instance is stopped to release resources held by the beans instances. During this phase, beans are destroyed in the reverse order of their creation and composed Inverno modules are stopped.</p>
                    <h4 id="module-as-component">Module as component</h4>
                    <p>Inverno modules are very flexible and can be used in many situations. You can for instance develop Inverno modules to create reusable software components. Such components would benefit from inversion of control and dependency injection capabilities offered by the framework without interfering with the applications that uses them. An Inverno module has also a very low runtime footprint since it creates objects and wires them in a fixed and deterministic way, it can then be created at any time in any situations.</p>
                    <h5 id="standalone-component">Standalone component</h5>
                    <p>You can imagine a standalone module used to interface with an external system like a coffee maker module for example. From the outside a coffee maker is actually quite simple:</p>
                    <ul>
                        <li>it requires electricity to operate</li>
                        <li>you have to fill it with coffee beans</li>
                        <li>you have to supply some water as well</li>
                        <li>then you can make some tasty coffee</li>
                    </ul>
                    <p>From the inside on the other hand it can be much more complex than this, it is probably composed of multiple internal components that you actually don't care about as long as the coffee is good.</p>
                    <p>Let's try to imagine what kind of interface would be exposed by the <code>io.inverno.sample.coffeeMakerModule</code> module without anticipating any implementation.</p>
                    <p>First of all it would probably export the module's package as it is intended to be used from outside the module:</p>
                    <p><strong>module-info.java</strong></p>
                    <pre><code class="language-java">@Module
Module io.inverno.sample.coffeeMakerModule {
    exports io.inverno.sample.coffeeMakerModule;
}
</code></pre>
                    <p>It might expose three singleton beans:</p>
                    <ul>
                        <li><code>io.inverno.sample.coffeeMakerModule:coffeeBeansContainer</code> to be able to fill the coffee maker with beans</li>
                        <li><code>io.inverno.sample.coffeeMakerModule:waterReservoir</code> for water supply</li>
                        <li><code>io.inverno.sample.coffeeMakerModule:coffeeMaker</code> to actually make some coffee</li>
                    </ul>
                    <p><strong>CoffeeBeansContainer</strong></p>
                    <pre><code class="language-java">public interface CoffeeBeansContainer {
    void fill(CoffeeBean[] beans);
}
</code></pre>
                    <p><strong>WaterReservoir</strong></p>
                    <pre><code class="language-java">public interface WaterReservoir {
    void fill(int waterQuantity);
}
</code></pre>
                    <p><strong>CoffeeMaker</strong></p>
                    <pre><code class="language-java">public interface CoffeeMaker {
    Coffee make();
}
</code></pre>
                    <p>Inside a coffee shop application, you might instantiate several coffee maker modules used in the following way:</p>
                    <pre><code class="language-java">PowerSupply powerSupply = ...                                                        // Get some power supply

CoffeeMakerModule coffeeMakerModule = new CoffeeMakerModule.Builder(powerSupply).build();
coffeeMakerModule.start();

ArabicaCoffeeBeans[]&nbsp;coffeeBeans = ...                                               // Get some tasty coffee beans
coffeeMakerModule.coffeeBeansContainer().fill(coffeeBeans);                          // fill the coffee beans container
coffeeMakerModule.waterReservoir().fill(1.5);                                        // fill the water reservoir with 1.5 Liters

CoffeeMaker coffeeMaker = coffeeMakerModule.coffeeMaker();                           // Get the coffee maker instance

Coffee coffee_1 = coffeeMaker.make();                                                // Deliver some tasty coffees
...
Coffee coffee_n = coffeeMaker.make();

coffeeMakerModule.stop();
</code></pre>
                    <p>The goal of this example was to show the benefits of using Inverno modules as standalone components in an application. As you can see:</p>
                    <ul>
                        <li>implementation details are completely hidden: you don't know and you don't have to know how the beans container, the water reservoir and the coffee maker are working together.</li>
                        <li>dependencies are clearly exposed: you must provide some power supply to instantiate the module.</li>
                        <li>only significant functionalities are exposed.</li>
                        <li>if you look closely, you'll see that no particular technical framework is visible: from a code perspective, the application doesn't see and don't need to know it is using an Inverno module, everything is also statically typed and self-describing.</li>
                    </ul>
                    <h5 id="factory-component">Factory component</h5>
                    <p>You can also create a module as a generic factory or builder to ease the creation of complex objects. If we consider previous example from a different perspective, we can imagine a factory module that could be used to build coffee makers from raw materials.</p>
                    <p>It would also probably export the module's package so it can be used from outside the module:</p>
                    <p><strong>module-info.java</strong></p>
                    <pre><code class="language-java">@Module
Module io.inverno.sample.coffeeMakerFactoryModule {
    exports io.inverno.sample.coffeeMakerFactoryModule;
}
</code></pre>
                    <p>Then it would expose the <code>io.inverno.sample.coffeeMakerFactoryModule:coffeeMaker</code> prototype bean:</p>
                    <pre><code class="language-java">public interface CoffeeMaker {

    void fillWithCoffeeBeans(CoffeeBeans[] beans);
    
    void filleWithWater();
    
    Coffee makeCoffee();
}
</code></pre>
                    <p>Inside a cooking appliances factory application, you might instantiate one or more coffee maker factory module to produce coffee makers:</p>
                    <pre><code class="language-java">CoffeeMakerFactoryModule coffeeMakerFactoryModule = new CoffeeMakerFactoryModule.Builder(rawMaterials...).build();
coffeeMakerFactoryModule.start();

CoffeeMaker coffeeMaker_1 = coffeeMakerFactoryModule.coffeeMaker(); // We can massively produce coffee makers
...
CoffeeMaker coffeeMaker_n = coffeeMakerFactoryModule.coffeeMaker();

coffeeMakerFactoryModule.stop();
</code></pre>
                    <p>The context and the approach are clearly different here, the purpose of a factory component module is to enable developers to use IoC/DI to easily create complex objects.</p>
                    <h5 id="processing-component">Processing component</h5>
                    <p>Dependency Injection is mostly about interconnecting objects to form an application, but this is more a consequence of how IoC/DI frameworks are designed than an absolute fact. An Inverno module is cheap, it can also be created and used during the operation of an application to process requests. This makes it possible to have data objects or contextual objects injected and used in bean instances.</p>
                    <p>Let's say we have created a highly customizable coffee maker, capable of producing a coffee based on many parameters: steam pressure, temperature, grinding size... These parameters have to be used in various components of the coffee maker. These data have to be provided each time a customer orders a coffee</p>
                    <p>Propagating the right data to the right coffee maker component can be a tedious task. An Inverno module can be created to inject data where they are needed based on the dependencies of each beans composing the coffee maker module and eventually process the request.</p>
                    <pre><code class="language-java">public Coffee orderCoffee(Param_1 p1, Param_2 p2, ... Param_n pn) {
    // Receive a large amount of parameters to make a coffee
    
    try {
        CoffeeMakerModule coffeeMakerFactoryModule = new CoffeeMakerFactoryModule.Builder(p1, p2, ... pn).build(); // Parameters are injected only where they are needed
        coffeeMakerModule.start();
    
        return offeeMakerModule.coffeeMaker().makeCoffee();
    }
    finally {
        coffeeMakerFactoryModule.stop();
    }
}
</code></pre>
                    <p>You can then benefit from dependency injection inside the business logic, performance shouldn't be impacted by bean instantiation or dependency injection logic because the creation of a module instance is no different than creating some objects with the <code>new</code> operator and invoking some setter methods. This is especially interesting when you have to process very complex requests with a lot of input data.</p>
                    <h4 id="module-as-application">Module as application</h4>
                    <p>An Inverno module can also be used to bootstrap a whole application. In such situation one single Inverno module is started as an application in the main method of a class. This class can be defined in the same module but this is not mandatory as long as it has access to the application module. The role of an application module is to create and start all the components of the application.</p>
                    <pre><code class="language-java">public static void main(String[] args) {
    CoffeeMakerModule coffeeMakerModule = Application.with(new CoffeeMakerModule.Builder(...)).run();
    ...
}
</code></pre>
                    <p>An application module is basically a regular module whose lifecycle is managed by the <code>Application</code> class. A module instance is created and started when the <code>run()</code> method is invoked and eventually stopped when the JVM shuts down.</p>
                    <blockquote>
                        <p>Note that this involves a shutdown hook, as a consequence there is actually no guarantee that the module will be stopped especially if the JVM is not gracefully shut down.</p>
                    </blockquote>
                    <p>Furthermore, an Inverno application outputs a customizable <code>Banner</code> on startup providing useful environment information in the application log.</p>
                    <pre><code class="language-plaintext">mars 04, 2020 1:14:27 PM io.inverno.core.v1.Application run
INFO: Inverno is starting...


     ╔════════════════════════════════════════════════════════════════════════════════════════════╗
     ║                      , ~~ ,                                                                ║
     ║                  , '   /\   ' ,                                                            ║
     ║                 , __   \/   __ ,      _                                                    ║
     ║                ,  \_\_\/\/_/_/  ,    | |  ___  _    _  ___   __  ___   ___                 ║
     ║                ,    _\_\/_/_    ,    | | / _ \\ \  / // _ \ / _|/ _ \ / _ \                ║
     ║                ,   __\_/\_\__   ,    | || | | |\ \/ /|  __/| | | | | | |_| |               ║
     ║                 , /_/ /\/\ \_\ ,     |_||_| |_| \__/  \___||_| |_| |_|\___/                ║
     ║                  ,     /\     ,                                                            ║
     ║                    ,   \/   ,                                  -- 1.5.1 --                 ║
     ║                      ' -- '                                                                ║
     ╠════════════════════════════════════════════════════════════════════════════════════════════╣
     ║ Java runtime        : OpenJDK Runtime Environment                                          ║
     ║ Java version        : 12.0.2+10                                                            ║
     ║ Java home           : /home/jkuhn/Devel/jdk/jdk-12.0.2                                     ║
     ║                                                                                            ║
     ║ Application module  : io.inverno.sample.coffeeMakerModule                                  ║
     ║ Application class   : io.inverno.sample.coffeeMakerModule.App                              ║
     ║                                                                                            ║
     ║ Modules             :                                                                      ║
     ║  * ...                                                                                     ║
     ╚════════════════════════════════════════════════════════════════════════════════════════════╝


mars 04, 2020 1:14:27 PM io.inverno.core.v1.Module start
...
</code></pre>
                    <p>The <code>StandardBanner</code> is displayed by default but you can specify custom implementations as well:</p>
                    <pre><code class="language-java">public static void main(String[] args) {
    CustomBanner customBanner = ...
    CoffeeMakerModule coffeeMakerModule = Application.with(new CoffeeMakerModule.Builder(...)).banner(customBanner).run();
    ...
}
</code></pre>
                    <h3 id="dependency-injection">Dependency Injection</h3>
                    <p><a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a> principle is at the heart of the Inverno framework. Inside an Inverno module, beans instances are wired into each other based on their respective types and dependencies.</p>
                    <p>In order to understand how this works, you could imagine that each bean exposes multiple sockets and that multiple wires leave the bean, as many as necessary. After creating and initializing bean instances, the module has to plug these wires into compatible sockets. The type of the wire, which is the type of the bean, must match the type of the socket, which is the type of the dependency defined in the bean.</p>
                    <p>The result is modeled in a graph of beans built at compile time by the Inverno compiler which checks that it is a directed acyclic graph (ie. there's no cycles in the graph) and that there is a plug in each required socket. If everything is correct, a module class implementing the graph is created.</p>
                    <blockquote>
                        <p>Dependency injection is validated and fully determined at compile time, the module class just instantiates and injects beans in a predetermined order without having to worry about missing dependencies or dependency cycles amongst others.</p>
                    </blockquote>
                    <h4 id="bean-socket">Bean Socket</h4>
                    <p>A <strong>bean socket</strong> designates a bean dependency. A bean can have two kinds of dependencies and then define two kinds of sockets: required and optional. Required dependencies must be resolved to create an operational bean instance whereas optional dependencies add extra capabilities to the bean instance. As a consequence, a module has to wire every required sockets, the Inverno compiler actually raises compilation errors on beans with unresolved required sockets.</p>
                    <p>The Inverno framework tries to be as less intrusive as possible, a bean specifies its sockets using standard Java as constructor arguments for required sockets and setter methods for optional sockets. Creating a bean is then very natural.</p>
                    <p>A bean socket is fully identified by its name, the name of the bean which defines it and the module in which the bean resides. The following notation is used to represent a bean socket qualified name: <code>[MODULE]:[BEAN]:[SOCKET_NAME]</code>. On a given bean in a given module, it is not possible to specify two sockets with the same name.</p>
                    <p>Let's go back to our coffee maker example and define the dependencies of the <code>CoffeeMaker</code> bean.</p>
                    <p><strong>CoffeeMakerImpl</strong></p>
                    <pre><code class="language-java">@Bean
public class CoffeMakerImpl implements CoffeMaker {
    
    private PowerSupply powerSupply;
    
    private WaterReservoir waterReservoir;
    
    private CoffeeBeansContainer coffeeBeansContainer;
    
    public CoffeeMakerImpl(PowerSupply powerSupply, WaterReservoir waterReservoir, CoffeeBeansContainer coffeeBeansContainer) {
        this.powerSupply = powerSupply;
        this.waterReservoir = waterReservoir;
        this.coffeeBeansContainer = coffeeBeansContainer;
    }
    
    public Coffee make() {
        ...
    }
}
</code></pre>
                    <p>The <code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl</code> bean then specifies three required sockets:</p>
                    <ul>
                        <li><code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl:powerSupply</code></li>
                        <li><code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl:waterReservoir</code></li>
                        <li><code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl:coffeeBeansContainer</code></li>
                    </ul>
                    <p>There should be only one public constructor defined in a bean class, this is actually proper bean design. Defining multiple constructors means that there are probably some dependencies not really required by the bean to work properly. Only required dependencies should be specified in a single bean constructor and optional dependencies in multiple setter methods. However if for some reasons multiple public constructors are defined on a bean class, you can explicitly specify which constructor to consider using the <code>@BeanSocket</code> annotation.</p>
                    <pre><code class="language-java">@Bean
public class CoffeMakerImpl implements CoffeMaker {
    
    @BeanSocket
    public CoffeeMakerImpl(PowerSupply powerSupply, WaterReservoir waterReservoir, CoffeeBeansContainer coffeeBeansContainer) {
        ...
    }
    
    public CoffeeMakerImpl(PowerSupply powerSupply, WaterReservoir waterReservoir, CoffeeBeansContainer coffeeBeansContainer, SomeOptionalDependency dependency) {
        ...
    }
}
</code></pre>
                    <p>The coffee maker should now have everything it needs to make coffee but let's say we want the coffee maker to be able to make cappuccinos, it will then need a <code>MilkFrother</code>. The coffee maker can use a <code>MilkFrother</code> when available but it doesn't require a <code>MilkFrother</code> to make coffee, only to make cappuccinos, as a result it should be declared in an optional socket.</p>
                    <pre><code class="language-java">@Bean
public class CoffeMakerImpl implements CoffeMaker {
    
    ...    
    private MilkFrother milkFrother
    
    ...    
    public void setMilkFrother(MilkFrother milkFrother) {
        this.milkFrother = milkFrother;
    }
    
    public Coffee make() {
        ...
        if(this.milkFrother != null) {
            // Do something useful with the milk frother
            ...
        }
    }
}
</code></pre>
                    <p>The <code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl</code> bean now specifies one optional socket: <code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl:milkFrother</code>.</p>
                    <p>By convention, every setter method on a bean is considered an optional socket, this enforces proper bean design. However in some situations you might need to explicitly specify which setter methods are sockets. In order to do that, you need to annotate every socket setter method of the bean with the <code>@BeanSocket</code> annotation.</p>
                    <pre><code class="language-java">@Bean
public class CoffeMakerImpl implements CoffeMaker {
    
    ...    
    @BeanSocket
    public void setMilkFrother(MilkFrother milkFrother) {
        ...
    }

    ...
    public void setSomethingElse() {
        ...
    }    
}
</code></pre>
                    <blockquote>
                        <p>Note that Inverno annotation are not inherited from ancestor class, the Inverno compiler only considers the bean class annotated with <code>@Bean</code> so you must explicitly override setter methods to specify optional sockets defined in a class ancestor. This might not be obvious but it is actually the safer way that gives a perfect control on the sockets you want to expose in your beans.</p>
                    </blockquote>
                    <h5 id="single-and-multiple">Single and multiple</h5>
                    <p>We can differentiate two kinds of bean socket: single socket and multiple socket. A single socket can be of any type except arrays, <code>java.util.List</code>, <code>java.util.Set</code> and <code>java.util.Collection</code> whereas the type of a multiple socket is necessarily an array, a <code>java.util.List</code>, a <code>java.util.Set</code> or a <code>java.util.Collection</code>. Multiple beans can be wired to a multiple socket whereas only one bean is wired to a single socket.</p>
                    <h5 id="lazy">Lazy</h5>
                    <p>A socket can be annotated with the <code>@Lazy</code> to indicate that a bean instance supplier should be provided instead of an actual bean instance. A lazy socket must then be of type <code>Supplier&lt;E&gt;</code> which specifies the actual type of the socket as formal parameter. In order to lazily inject a list of beans, the socket must be of type <code>List&lt;Supplier&lt;E&gt;&gt;</code>.</p>
                    <p>A lazy socket allows a dependent bean to lazily retrieve a bean instance. This presents several advantages when prototype beans are wired into a lazy socket, it is then possible to create fully wired bean instances on demand during the operation of a module and use them when processing a request for instance.</p>
                    <h4 id="socket-bean">Socket Bean</h4>
                    <p>Bean sockets designates the dependencies of a single bean. All beans in a module must be operational for a module to work properly as a consequence all beans required sockets must be resolved but what if one or more <em>plugs</em> are missing inside the module to match all these sockets? The dependency can then be declared at module level using a particular kind of bean: the <strong>socket bean</strong>.</p>
                    <p>From inside a module, a socket bean is considered as any regular beans as it takes part in the dependency injection process. From outside the module, it designates a module dependency that is provided when a module is instantiated.</p>
                    <p>Unlike other type of beans, a socket bean is not a concrete class, it must be an interface annotated with <code>@Bean</code> extending the <code>Supplier&lt;E&gt;</code> interface. The supplier's formal parameter designates the type of the dependency to provide.</p>
                    <p>Let's say the coffee maker module does not provide any <code>PowerSupply</code> bean internally, this makes sense since a power supply might be required to make coffee but it is clearly unrelated. We must then find a way to provide a <code>PowerSupply</code> inside the module to make it work. We can then create a <code>PowerSupplySocket</code> socket bean inside the coffee maker module.</p>
                    <pre><code class="language-java">@Bean
public interface PowerSupplySocket implements Supplier&lt;PowerSupply&gt; {}
</code></pre>
                    <p>This creates socket bean <code>io.inverno.sample.coffeeMakerModule:powerSupplySocket</code> in the module <code>io.inverno.sample.coffeeMakerModule</code>. As you can imagine, this bean can be injected in other module's beans just like any regular beans.</p>
                    <p>The module class generated by the Inverno compiler now defines an argument of type <code>PowerSupply</code> in the module's builder constructor, we must then provide a <code>PowerSupply</code> instance in order to instantiate the module.</p>
                    <pre><code class="language-java">PowerSupply powerSupply = ...
CoffeeMakerModule coffeeMakerModule = new CoffeeMakerModule.Builder(powerSupply).build();
...
</code></pre>
                    <p>A socket bean appears in the builder constructor when it is wired to a required bean socket inside the module. On the other hand, a socket bean wired to an optional bean socket appears in an extra method of the module's builder class.</p>
                    <p>We might want to be able to stick a brand sticker on the coffee maker, this is obviously completely optional and external to the coffee maker module. We can then define a <code>BrandStickerSocket</code> in the module.</p>
                    <pre><code class="language-java">BrandSticker brandSticker = ...
CoffeeMakerModule coffeeMakerModule = new CoffeeMakerModule.Builder(powerSupply).brandSticker(brandSticker).build();
...
</code></pre>
                    <blockquote>
                        <p>It is interesting to notice here that a Inverno module explicitly specifies its dependencies which is extremely valuable to create complex modular applications involving multiple people working together, one can easily understand how to use another one's module without mentioning the fact that the compiler can actually check that everything fits together since beans, modules and modules builder arguments are all statically typed.</p>
                    </blockquote>
                    <h4 id="wiring">Wiring</h4>
                    <p>The Inverno compiler wires beans together based on the sockets defined in the module. A viable module is a module that has:</p>
                    <ul>
                        <li>all its required sockets resolved, either internally with another bean in the module or externally through a socket bean</li>
                        <li>no cycles in the resulting graph of beans</li>
                    </ul>
                    <h5 id="autowiring">Autowiring</h5>
                    <p>By default, the Inverno compiler tries to automatically wire the beans in a module based on their respective types and the types of the sockets they expose.</p>
                    <p>In the coffee maker module we have the following beans:</p>
                    <ul>
                        <li><code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl</code></li>
                        <li><code>io.inverno.sample.coffeeMakerModule:waterReservoirImpl</code></li>
                        <li><code>io.inverno.sample.coffeeMakerModule:coffeeBeansContainerImpl</code></li>
                        <li><code>io.inverno.sample.coffeeMakerModule:powerSupply</code> (socket bean)</li>
                    </ul>
                    <p>The <code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl</code> bean defines the following sockets:</p>
                    <ul>
                        <li><code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl:powerSupply</code></li>
                        <li><code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl:waterReservoir</code></li>
                        <li><code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl:coffeeBeansContainer</code></li>
                        <li><code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl:milkFrother</code> (optional)</li>
                    </ul>
                    <p>This configuration results in the following graph of beans:</p> <img class="img-fluid mt-4 mb-5" src="img/coffee_maker_bean_graph.svg" alt="Beans dependency graph" />
                    <p>The module is viable since all required beans sockets are resolved and the graph of beans is a directed acyclic graph. The Inverno compiler can then generate a module class containing the logic to instantiate the beans in the right order and the dependency injection logic. When an instance of the <code>io.inverno.sample.coffeeMakerModule</code> module is started, the <code>waterReservoirImpl</code> bean and the <code>coffeeBeansContainerImpl</code> are instantiated first then the <code>coffeeMakerImpl</code> bean is instantiated next using previously created instances and the <code>powerSupply</code> instance injected when the module was created.</p>
                    <p>In case one or more bean sockets cannot be resolved, the Inverno compiler outputs specific compilation errors for each one of them. When this happens, you must either define module beans or socket beans inside the module matching the unresolved sockets in order for the module to compile.</p>
                    <blockquote>
                        <p>You'll learn in the <a href="#modular-application">Modular application</a> section that there is another way to provide beans in a module by <em>composing</em> another Inverno module inside your module.</p>
                    </blockquote>
                    <h5 id="explicit-wiring">Explicit wiring</h5>
                    <p>It is not possible for the Inverno compiler to automatically wire module beans when more than one bean matching a socket exists in the module. In that case, the Inverno compiler outputs specific compilation errors on bean sockets presenting such conflicts. In order for the module to compile, these conflicts must be explicitly resolved.</p>
                    <p>Let's assume we actually have two beans of type <code>WaterReservoir</code> in the coffee maker module: <code>smallWaterReservoir</code> and <code>bigWaterReservoir</code>, the <code>coffeeMakerImpl</code> requires only one <code>WaterReservoir</code> since the <code>waterReservoir</code> socket is a single socket, we clearly have a conflict that the Inverno compiler cannot resolve on its own because it cannot decide for you which water reservoir bean is best suited. So you have to explicitly tell the Inverno compiler what to do using a <code>@Wire</code> annotation on the module definition:</p>
                    <pre><code class="language-java">@Module
@Wire(beans="smallWaterReservoir", into="coffeeMakerImpl:waterReservoir")
Module io.inverno.sample.coffeeMakerModule {
    ...
}
</code></pre>
                    <p>In the <code>@Wire</code> annotation the <code>beans</code> attribute is used to specify which beans must be wired into the socket specified in the <code>into</code> attribute.</p>
                    <p>The <code>beans</code> attribute is an array of bean qualified names of the form <code>([MODULE]:)?[BEAN]</code>. If the module name is omitted, the compiler will look for beans in the current module. When defining a wire for a single socket, only one bean qualified name is expected.</p>
                    <p>The <code>into</code> attribute is a bean socket qualified name of the form <code>([MODULE]|([MODULE]:)?[BEAN]):[SOCKET_NAME]</code>. When specifying a wire on a bean socket name which is necessarily defined in a bean in the current module, the module name can be omitted.</p>
                    <blockquote>
                        <p>The module name is in fact only necessary when specifying a wire on a socket bean of a module composed in a <a href="#composite-module">composite module</a>.</p>
                    </blockquote>
                    <p>Obviously, multiple <code>@Wire</code> annotations can be specified on a module definition. If a specified bean does not exist, if the specified socket does not exist, if the specified beans does not match the specified socket or if multiple beans were specified for a single socket, the Inverno compiler will raise compilation errors.</p>
                    <p>Resolving conflicts is one way of using explicit wiring, but in the case of a multiple socket, you can also use a wire to explicitly select which beans you want to inject using the <code>@Wire</code> annotation. For instance, let's say we have a module with four beans of type <code>SomeType</code>: <code>beanA</code>, <code>beanB</code>, <code>beanC</code>, <code>beanD</code> and another bean which defines a multiple socket of the same type (eg. <code>List&lt;SomeType&gt;</code>), if you do nothing, by default the Inverno compiler will automatically wire all four into the multiple socket, if you want to inject only <code>beanA</code> and <code>beanB</code> you can specify the following on the module definition:</p>
                    <pre><code class="language-java">@Module
@Wire(beans={"beanA", "beanB"}, into="someBean:multipleSomeType")
Module someModule {
    ...
}
</code></pre>
                    <blockquote>
                        <p>It's interesting to see that it is not on the socket that the conflict is resolved but on the module that actually created that conflict. This is quite different than other DI frameworks that use qualifiers specified on the conflicting injection point. With these approaches, In order to properly separate the concerns a bean should not know the name of the actual bean that will be injected, as a result it is up to the bean to define the qualifiers and up to the other beans to be named or aliased after these qualifiers but this means the bean still know that a conflict exist otherwise it wouldn't need to specify any qualifier. The Inverno framework eliminates this issue to enforce proper separation of concerns.</p>
                    </blockquote>
                    <h5 id="selector">Selector</h5>
                    <p>Beans are always wired to sockets based on their types, selectors provide another level of filtering. They are used to specify what compile time properties a bean type must have to be wired to a particular socket.</p>
                    <p>Selectors are annotations annotated with <code>@Selector</code> that can be specified on both bean sockets and socket beans. The framework currently supports the <code>@AnnotationSelector</code> that lets you filter beans based on a particular annotation.</p>
                    <p>Let's say, you finally decided to provide a milk frother to the coffee maker which is unfortunately only compatible with milk frothers of a particular brand. To do so, you can define a <code>@SuperSteam</code> annotation for the brand and tell the Inverno compiler to make sure the milk forther wired to the coffee maker is annotated with it.</p>
                    <pre><code class="language-java">public @interface SuperSteam {}
</code></pre>
                    <pre><code class="language-java">@Bean
public class CoffeMakerImpl implements CoffeMaker {
    
    ...
    public void setMilkFrother(@AnnotationSelector(SuperSteam.class) MilkFrother milkFrother) {
        ...
    }

}
</code></pre>
                    <p>If no bean of type <code>MilkForther</code> annotated with <code>@SuperSteam</code> exists, a compilation error is raised.</p>
                    <blockquote>
                        <p>It's important to understand here that the Inverno compiler considers the declared type of a bean which is not necessarily the actual type of the runtime instance. This is especially true when defining a <a href="#provided-type">provided type</a> in a bean class, the selector annotation must then be specified on the provided type and not the actual bean class.</p>
                    </blockquote>
                    <h3 id="modular-application">Modular application</h3>
                    <p>Modularity is at the heart of the Inverno framework, it has been built on the idea that flexibility, maintainability and stability, especially on large and complex applications can only be achieved through a proper modularization and strict <a href="https://en.wikipedia.org/wiki/Separation_of_concerns">separation of concerns</a>.</p>
                    <p>So far, we explored how to define and compose beans inside a module to implement a wider component or a standalone application but the Inverno framework also allows the composition of modules to create even more complex components and applications.</p>
                    <h4 id="composite-module">Composite module</h4>
                    <p>A <strong>composite module</strong> is literally a module composed of multiple Inverno modules. Concretely, all public beans exposed in a component module are considered for dependency injection in the composite module. In the same way, socket beans defined in a component module are resolved with the beans available in the composite module.</p>
                    <p>By default, any Inverno module required in the module descriptor of a Inverno module are composed by the Inverno compiler inside the module class. Component modules public beans are encapsulated in the composite module class and then only accessible from within that module. At runtime, component modules are instantiated and started along with the composite module which wires their public beans into the module's beans sockets or into other component modules socket beans.</p>
                    <p>Let's assume module <code>io.inverno.sample.milkFrotherModule</code> provides a <code>MilkFrother</code> bean compatible with the coffee maker. You can simply declare it as required in the module descriptor of the <code>io.inverno.sample.coffeeMakerModule</code> module to get the milk frother module created and started along with the coffee maker module and eventually wire the milk frother into the coffee maker.</p>
                    <pre><code class="language-java">@Module
Module io.inverno.sample.coffeeMakerModule {
    ...
    requires io.inverno.sample.milkFrotherModule;
    ...
}
</code></pre>
                    <p>The Inverno compiler will find out that the milk frother module provides a bean matching coffee maker optional milk frother socket and do the wiring in the module class.</p>
                    <p>In some situations, you might want to explicitly include or exclude required modules from the module composition, you can do this using <code>includes</code> and <code>excludes</code> attributes in the <code>@Module</code> annotation. This is useful when you just want to use types from another module without instantiating it.</p>
                    <pre><code class="language-java">@Module(includes={"moduleA", "moduleB"})
Module someModule {
    ...
    requires moduleA;
    requires moduleB;
    requires moduleC; // moduleC will be ignored by the Inverno compiler
    ...
}
</code></pre>
                    <p>In order for the module to compile, all required socket beans defined in component modules must be resolved. They can be resolved with any beans available in the composite module including beans, socket beans or any public beans provided in other component modules.</p>
                    <p>Explicit wiring can be used as described before using fully qualified names for component modules public beans or socket beans.</p>
                    <pre><code class="language-java">@Module
@Wire(beans="moduleA:bean1", into="someBean:socket")     // Explicitly wire bean 'bean1' of component module 'moduleA' into bean socket 'socket' in bean 'someBean' of module 'someModule'
@Wire(beans="moduleB:bean2", into="moduleC:socketBean")  // Explicitly wire bean 'bean2' of component module 'moduleB' into socket bean 'socketBean' of module 'moduleC'
Module someModule {
    ...
    requires moduleA;
    requires moduleB;
    requires moduleC;
    ...
}
</code></pre>
                    <p>Module composition offers greater flexibility when using or designing modules. A typical Inverno application module would be a simple composition of multiple Inverno modules implementing different aspects. Multiple modules inside an application can depend on the same module but with different instances which limits the possibility of collisions and increases reusability. Indeed when developing a module you don't have to worry about the context in which it will be used or executed, you can focus on the feature it provides, external dependencies can be provided internally through module composition or externally through socket beans.</p>
                    <h4 id="provided-type">Provided type</h4>
                    <p>By default, the type of a bean is given by the class defining the bean, for a module bean it is the annotated class and for a wrapper bean it is the formal parameter specified in the <code>Supplier&lt;E&gt;</code> interface.</p>
                    <p>This basically means that the type of a public bean must be accessible from outside the module, its package must then be exported in the module descriptor. However, you might, and probably will, need to hide bean implementations and only expose public API types.</p>
                    <p>You can control which type is actually provided by a bean using the <code>@Provide</code> annotation. A bean can only provide one type.</p>
                    <p>Let's see how it works for the <code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl</code> bean:</p>
                    <pre><code class="language-java">@Bean
public class CoffeMakerImpl implements @Provide CoffeMaker {
    ...
}
</code></pre>
                    <p>The <code>CoffeeMakerImpl</code> class can implement several types but it will be exposed as a <code>CoffeeMaker</code> in the module class.</p>
                    <blockquote>
                        <p>The <code>@Provide</code> annotation is only useful on module bean, for w beans the implementation type is already hidden in the <code>Supplier#get()</code> method and the provided type is the formal parameter specified in the <code>Supplier&lt;E&gt;</code> interface.</p>
                    </blockquote>
                    <p>The provided type is only considered outside the module when used in a composite module or in an application. Inside the module, the actual bean type is used for dependency injection unless the bean is also overridable in which case the provided type is also used internally.</p>
                    <p>Hiding implementation and only expose public API is very convenient when you developed a component module and it is a best practice in general if you want to enforce modularity inside an application. Most of the time modules should always depend on public API so from a dependency injection perspective it doesn't really matters whether a module expose implementation classes but you can't guarantee that nobody will ever create a dependency on an implementation class if that class is accessible which would be quite bad for maintainability. Being able to control the types actually exposed in a module enforces a proper isolation.</p>
                    <blockquote>
                        <p>Particular care must be taken when using <a href="#selector">selectors</a> in a composite module, the type of component modules beans considered by the Inverno compiler will be the provided types, so if you want to specify properties matching selectors, you have to specify them on the provided types and not the actual beans types.</p>
                    </blockquote>
                    <h2 id="inverno-modules-1">Inverno Modules</h2>
                    <h3 id="motivation-1">Motivation</h3>
                    <p>Built on top of the <a href="https://github.com/inverno-io/inverno-core">Inverno core IoC/DI framework</a>, Inverno modules suite aimed to provide a complete set of features to develop high end production-grade applications.</p>
                    <p>The advent of cloud computing and highly distributed architecture based on microservices has changed the way applications should be conceived, maintained, executed and operated. While it was perfectly fine to have application started in couple of seconds or even minutes some years ago with long release cycles, today's application must be highly efficient, agile in terms of development and deployment and start in a heart beat.</p>
                    <p>The Inverno framework was created to reduce framework overhead at runtime to the minimum, allowing to create applications that start in milliseconds. Inverno modules extend this approach to provide functionalities with low footprint, relying on the compiler when it makes sense to generate human-readable code for easy maintenance and improved performance.</p>
                    <p>An agile application is naturally modular which is the essence of the Inverno framework, but it must also be highly configurable and customizable in many ways using configuration data distributed in various data stores and that greatly depend on the context such as an execution environment: test, production..., a location: US, Europe, Asia..., a particular customer, a particular user... Advanced configuration capabilities are then essential to build modern applications.</p>
                    <p>Traditional application servers and frameworks used to be based on inefficient threading models that didn't make fair use of hardware resources which make them bad cloud citizens. Inverno applications are one hundred percent reactive making maximum use of the allocated resources.</p>
                    <p>The primary goals can be summarized as follows:</p>
                    <ul>
                        <li>provide a complete set of common features to build any kind of applications</li>
                        <li>maintain a high level of performance...</li>
                        <li>...but always choose modularity and maintainability over performance to favor agility</li>
                        <li>be explicit and consistent, there's nothing worse than ambiguity and disparateness, the <em>you have to know</em>s must be minimal and logical.</li>
                        <li>provide advanced configuration and customization features</li>
                    </ul>
                    <h3 id="prerequisites-1">Prerequisites</h3>
                    <p>Before we can dig into the various modules provided in the framework, it is important to understand how to setup a modular Inverno project, so please have a look at the <a href="https://github.com/inverno-io/inverno-dist">Inverno distribution documentation</a> which describes in details how to create, build, run, package and distribute a modular Inverno component or application.</p>
                    <p>Inverno modules are built on top of the Inverno core IoC/DI framework, please refer to the <a href="https://github.com/inverno-io/inverno-core/tree/master/doc/reference-guide.md">Inverno core documentation</a> to understand how IoC/DI is working in the framework.</p>
                    <p>The framework is fully reactive thanks to <a href="https://projectreactor.io/">Project Reactor Core library</a>, it is strongly recommended to also look at <a href="https://projectreactor.io/docs/core/release/reference/">the reference documentation</a>.</p>
                    <h3 id="overview-2">Overview</h3>
                    <p>The basic Inverno application is an Inverno module composing the <em>boot</em> module which provides common services. Other Inverno modules can then be added by defining the corresponding dependencies in the module descriptor.</p>
                    <pre><code class="language-java">@io.inverno.core.annotation.Module
module io.inverno.example.app {
    requires io.inverno.mod.boot;
    // Other modules...
}
</code></pre>
                    <p>Declaring a dependency to the <em>boot</em> module automatically includes core IoC/DI modules as well as <em>base</em> module, <em>configuration</em> module and reactive framework dependencies.</p>
                    <p>A basic application can then be created as follows:</p>
                    <pre><code class="language-java">import io.inverno.core.v1.Application;

public class Main {

    public static void main(String[] args) {
        Application.with(new App.Builder()).run();
    }
}
</code></pre>
                    <p>Inverno modules are fully integrated which means they have been designed to work together in an Inverno component or application but this doesn't mean it's not possible to embed them independently in any kind of application following the agile principle. For instance, the <em>configuration</em> module, can be easily used in any application with limited dependency overhead. More generally, an Inverno module can be created and started very easily in pure Java thanks to the Inverno core IoC/DI framework.</p>
                    <p>For instance, an application can embed a HTTP server as follows:</p>
                    <pre><code class="language-java">Boot boot = new Boot.Builder().build();
boot.start();

Server httpServer = new Server.Builder(boot.netService(), boot.resourceService())
    .setHttpServerConfiguration(HttpServerConfigurationLoader.load(conf -&gt; conf.server_port(8080)))
    .setRootHandler(
        exchange -&gt; exchange
            .response()
            .body()
            .raw()
            .value(Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("Hello, world!", Charsets.DEFAULT)))
    )
    .build();

httpServer.start();
...
httpServer.stop();
boot.stop();
</code></pre>
                    <blockquote>
                        <p>Note that as for any Inverno module, dependencies are clearly specified and must be provided when creating a module, in the previous example the HTTP server requires a <code>NetService</code> and a <code>ResourceService</code> which are normally provided by the boot module but custom implementations can be provided. It is also possible to create an Inverno module composing the <em>boot</em> and <em>http-server</em> modules to let the framework deal with dependency injection.</p>
                    </blockquote>
                    <h3 id="base">Base</h3>
                    <p>The Inverno <em>base</em> module defines the foundational APIs used across all modules, it can be seen as an extension to the <em>java.base</em> module.</p>
                    <p>In order to use the Inverno <em>base</em> module, we need to declare a dependency in the module descriptor:</p>
                    <pre><code class="language-java">module io.inverno.example.app {
    requires io.inverno.mod.base;
    ...
}
</code></pre>
                    <p>The <em>base</em> module declares transitive dependencies to reactive APIs which don't need to be re-declared.</p>
                    <p>We also need to declare that dependency in the build descriptor:</p>
                    <p>Using Maven:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-base&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <p>Using Gradle:</p>
                    <pre><code class="language-java">...
compile 'io.inverno.mod:inverno-base:1.5.2'
...
</code></pre>
                    <p>The <em>base</em> module is usually provided as a transitive dependency by other modules, mainly the <em>boot</em> module, so defining a direct dependency is usually not necessary at least for an application module.</p>
                    <h4 id="converter-api">Converter API</h4>
                    <p>The converter API provides interfaces and classes for building converters, decoders or encoders which are basically used to decode/encode objects of a given type from/to objects of another type.</p>
                    <h5 id="scope">Scope</h5>
                    <p>The <code>Scope</code> interface specifies a way to expose different bean instances depending on particular scope.</p>
                    <p>For instance, let's say we want to use different instances of a <code>Warehouse</code> bean based on a particular region, we can define a prototype bean for the <code>Warehouse</code> and create the following bean which extends <code>KeyScope</code>:</p>
                    <pre><code class="language-java">@Bean
public class WarehouseKeyScope extends KeyScope&lt;Warehouse&gt; {

    private final Supplier&lt;Warehouse&gt; storePrototype;
    
    public WarehouseKeyScope(@Lazy Supplier&lt;Warehouse&gt; storePrototype) {
        this.storePrototype = storePrototype;
    }
    
    @Override
    protected Warehouse create() {
        return this.storePrototype.get();
    }
}
</code></pre>
                    <p>We can then inject that bean where we need a <code>Warehouse</code> instance for a particular region:</p>
                    <pre><code class="language-java">@Bean
public class WarehouseService {

    private final KeyScope&lt;Warehouse&gt; warehouse;

    public WarehouseService(KeyScope&lt;Warehouse&gt; warehouse) {
        this.warehouse = warehouse;
    }
    
    public void store(Product product, String region) {
        Warehouse warehouse = this.warehouse.get(region);
        ...
    }
}
</code></pre>
                    <p>The base module expose three base <code>Scope</code> implementations:</p>
                    <ul>
                        <li>the <code>KeyScope</code> which binds an instance to an arbitrary key</li>
                        <li>the <code>ThreadScope</code> which binds an instance to the current thread</li>
                        <li>the <code>ReactorScope</code> which binds an instance to the current reactor's thread. This is very similar to the <code>ThreadScope</code> but this throws an <code>IllegalStateException</code> when used outside the scope of the reactor (ie. the current thread is not a reactor thread).</li>
                    </ul>
                    <blockquote>
                        <p>Particular care must be taken when using this technique in order to avoid resource leaks. For instance, when a scoped instance is no longer in use, it should be cleaned explicitly as references can be strongly reachable. The <code>KeyScope</code> exposes the <code>remove()</code> for this purpose. Also when using prototype bean instance, the destroy method, if any, may not be invoked if the instance is reclaimed before it can be destroyed, as a result you should avoid using such bean instances within scope beans.</p>
                    </blockquote>
                    <h5 id="basic-converter">Basic converter</h5>
                    <p>The <code>Converter</code> interface defines a basic converter. It simply extends <code>Decoder</code> and <code>Encoder</code> interfaces which defines respectively the basic decoder and the basic encoder.</p>
                    <p>A basic decoder is used to decode an object of a source type to an object of a target type. For instance, we can create a simple string to integer decoder as follows:</p>
                    <pre><code class="language-java">public class StringToIntegerDecoder {
    
    @Override
    public &lt;T extends Integer&gt; T decode(String value, Class&lt;T&gt; type) throws ConverterException {
        return (T)Integer.valueOf(value);
    }
    
    @Override
    public &lt;T extends Integer&gt; T decode(String value, Type type) throws ConverterException {
        return (T)Integer.valueOf(value);
    }
}
Decoder&lt;String, Integer&gt; 
</code></pre>
                    <p>A basic encoder is used to encode an object of a source type to an object of a target type. For instance, we can create a simple integer to string encoder as follows:</p>
                    <pre><code class="language-java">public class IntegerToStringEncoder implements Encoder&lt;Integer, String&gt; {
    
    @Override
    public &lt;T extends Integer&gt; String encode(T value) throws ConverterException {
        return value.toString();
    }
    
    @Override
    public &lt;T extends Integer&gt; String encode(T value, Class&lt;T&gt; type) throws ConverterException {
        return value.toString();
    }
    
    @Override
    public &lt;T extends Integer&gt; String encode(T value, Type type) throws ConverterException {
        return value.toString();
    }
}
</code></pre>
                    <p>A string to integer converter can then be created by combining both implementations.</p>
                    <p>The previous example while not very representative illustrates the basic decoder and encoder API, you should now wonder how to use this properly in an application and what is the fundamental difference between a decoder and an encoder, the answer actually lies in the names. A decoder is meant to <em>decode</em> data formatted in a particular way into a representation that can be used in an application whereas an encoder is meant to <em>encode</em> an object in an application into data formatted in a particular way. From there, we understand that a converter can be used to read or write raw data (JSON data in an array of bytes for instance) to or from actual usable representations in the form of Java objects but it can also be used as an object mapper to convert from one representation to another (domain object to data transfer object for instance).</p>
                    <p>A more realistic example would then be a JSON string to object converter:</p>
                    <pre><code class="language-java">public class JsonToObjectConverter implements Converter&lt;String, Object&gt; {
    
    private ObjectMapper mapper = new ObjectMapper();
    
    @Override
    public &lt;T&gt; T decode(String value, Class&lt;T&gt; type) throws ConverterException {
        try {
            return this.mapper.readValue(value, type);
        } 
        catch (JsonProcessingException e) {
            throw new ConverterException(e);
        }
    }
    
    @Override
    public &lt;T&gt; T decode(String value, Type type) throws ConverterException {
        ...
    }
    
    @Override
    public &lt;T&gt; String encode(T value) throws ConverterException {
        try {
            return this.mapper.writeValueAsString(value);
        } 
        catch (JsonProcessingException e) {
            throw new ConverterException(e);
        }
    }
    
    @Override
    public &lt;T&gt; String encode(T value, Class&lt;T&gt; type) throws ConverterException {
        ...
    }
    
    @Override
    public &lt;T&gt; String encode(T value, Type type) throws ConverterException {
        ...
    }
}
</code></pre>
                    <p>The API provides other interfaces to create converters, decoders and encoders with more capabilities.</p>
                    <h5 id="splittable-decoder-and-joinable-encoder">Splittable decoder and Joinable encoder</h5>
                    <p>A <code>SplittableDecoder</code> is a particular decoder which allows to decode an object of a source type into multiple objects of a target type. It specifies methods to decode one source instance into an array, a list or a set of target instances.</p>
                    <p>In the same way, a <code>JoinableEncoder</code> is a particular encoder which allows to encode multiple objects of a source type into one single object of a target type. It specifies methods to encode an array, a list or a set of source instances into a single target instance.</p>
                    <p>The <code>StringConverter</code> is a typical implementation that can decode or encode multiple parameters values.</p>
                    <pre><code class="language-java">StringConverter converter = new StringConverter();

// List.of(1, 2, 3)
List&lt;Integer&gt; l = converter.decodeToList("1,2,3", Integer.class); 
// "1,2,3"
String s = converter.encodeList(List.of(1, 2, 3));
</code></pre>
                    <h5 id="primitive-decoder-and-encoder">Primitive decoder and encoder</h5>
                    <p>A <code>PrimitiveDecoder</code> is fundamentally an object decoder which provides bindings to decode an object of a source type into an object of primitive (boolean, integer...) or common type (string, date, URI...).</p>
                    <p>In the same way, a <code>PrimitiveEncoder</code> is fundamentally an object encoder which provides bindings to encode an object of a primitive or common type to an object of a target type.</p>
                    <p>The <code>StringConverter</code> which is meant to convert parameter values is again a typical use case of primitive decoder and encoder.</p>
                    <pre><code class="language-java">StringConverter converter = new StringConverter();

// 123l
long l = converter.decodeLong("123");
// ISO-8601 date: "yyyy-MM-dd"
String s = converter.encode(LocalDate.now());
</code></pre>
                    <p>The <code>SplittablePrimitiveDecoder</code> and <code>JoinablePrimitiveEncoder</code> are primitive decoder and encoder that respectively extends <code>SplittableDecoder</code> and <code>JoinableEncoder</code>.</p>
                    <h5 id="object-converter">Object converter</h5>
                    <p>An <code>ObjectConverter</code> is a convenient interface for building <code>Object</code> converters. It extends <code>Converter</code>, <code>SplittablePrimitiveDecoder</code> and <code>JoinablePrimitiveEncoder</code>.</p>
                    <h5 id="reactive-converter">Reactive converter</h5>
                    <p>A <code>ReactiveConverter</code> is a particular converter which extends <code>ReactiveDecoder</code> and <code>ReactiveEncoder</code> for building reactive converters which are particularly useful to convert data from non-blocking I/O channels.</p>
                    <p>The <code>ReactiveDecoder</code> interface defines methods to decode one or many objects of a target type from a stream of objects of a source type. In the same way, the <code>ReactiveEncoder</code> interface defines methods to encode one or many objects of a source type into a stream of objects of target type.</p>
                    <p>The <code>ByteBufConverter</code> is a typical use case, it is meant to convert data from non-blocking channels like the request or response payloads in a network server or client, or the content of a resource read asynchronously.</p>
                    <pre><code class="language-java">ByteBufConverter converter = new ByteBufConverter(new StringConverter());

Publisher&lt;ByteBuf&gt; dataStream = ... // comes from a request or resource

// On subscription, chunk of data accumulates until a complete response can be emitted
Mono&lt;ZonedDateTime&gt; dateTimeMono = converter.decodeOne(dataStream, ZonedDateTime.class); 

// On subscription, a stream of integer is mapped to a publisher of ByteBuf
Publisher&lt;ByteBuf&gt; integerStream = converter.encodeMany(Flux.just(1,2,3,4));
</code></pre>
                    <h5 id="media-type-converter">Media type converter</h5>
                    <p>A <code>MediaTypeConverter</code> is a particular kind of object converter which supports a specific format specified as a <a href="https://en.wikipedia.org/wiki/Media_type">media type</a> and converts object from/to raw data in the supported format. A typical example would be a JSON media type converter used to decode/encode raw JSON data.</p>
                    <blockquote>
                        <p>The <em>web</em> module relies on such converters to respectively decode end encode HTTP request and HTTP response payloads based on the content type specified in the message headers.</p>
                    </blockquote>
                    <h5 id="composite-converter">Composite converter</h5>
                    <p>A <code>CompositeConverter</code> is an extensible object converter based on a <code>CompositeDecoder</code> and a <code>CompositeEncoder</code> which themselves rely on multiple <code>CompoundDecoder</code> and <code>CompoundEncoder</code> to extend or override respectively the decoding and encoding capabilities of the converter. In practical terms, it is possible to make a converter able to decode or encode any type of object by providing ad hoc compound decoders and encoders.</p>
                    <p>The <code>StringCompositeConverter</code> is a composite converter implementation which uses a default <code>StringConverter</code> to convert primitive and common types of objects, it can be extended to convert other types of object.</p>
                    <p>For instance, let's consider the following <code>Message</code> class:</p>
                    <pre><code class="language-java">public static class Message {

    private String message;

    // constructor, getter, setter
    ...
}
</code></pre>
                    <p>We can create specific compound decoder and encoder to respectively decode and encode a <code>Message</code> from/to a string as follows:</p>
                    <pre><code class="language-java">public static class MessageDecoder implements CompoundDecoder&lt;String, Message&gt; {

    @SuppressWarnings("unchecked")
    @Override
    public &lt;T extends Message&gt; T decode(String value, Class&lt;T&gt; type) throws ConverterException {
        return (T) new Message(value);
    }
    
    @SuppressWarnings("unchecked")
    @Override
    public &lt;T extends Message&gt; T decode(String value, Type type) throws ConverterException {
        return (T) new Message(value);
    }
    
    @Override
    public &lt;T extends Message&gt; boolean canDecode(Class&lt;T&gt; type) {
        return Message.class.equals(type);
    }
    
    @Override
    public boolean canDecode(Type type) {
        return Message.class.equals(type);
    }
}
</code></pre>
                    <pre><code class="language-java">public static class MessageEncoder implements CompoundEncoder&lt;Message, String&gt; {
    
    @Override
    public &lt;T extends Message&gt; String encode(T value) throws ConverterException {
        return value.getMessage();
    }
    
    @Override
    public &lt;T extends Message&gt; String encode(T value, Class&lt;T&gt; type) throws ConverterException {
        return value.getMessage();
    }
    
    @Override
    public &lt;T extends Message&gt; String encode(T value, Type type) throws ConverterException {
        return value.getMessage();
    }
    
    @Override
    public &lt;T extends Message&gt; boolean canEncode(Class&lt;T&gt; type) {
        return Message.class.equals(type);
    }
    
    @Override
    public boolean canEncode(Type type) {
        return Message.class.equals(type);
    }
}
</code></pre>
                    <p>And inject them into a string composite converter which can then decode/encode <code>Message</code> object:</p>
                    <pre><code class="language-java">CompoundDecoder&lt;String, Message&gt; messageDecoder = new MessageDecoder();
CompoundEncoder&lt;Message, String&gt; messageEncoder = new MessageEncoder();

StringCompositeConverter converter = new StringCompositeConverter();
converter.setDecoders(List.of(messageDecoder));
converter.setEncoders(List.of(messageEncoder));

Message decodedMessage = converter.decode("this is an encoded message", Message.class);
String encodedMessage = converter.encode(new Message("this is a decoded message"));
</code></pre>
                    <h4 id="net-api">Net API</h4>
                    <p>The Net API provides interfaces and classes to manipulate basic network elements such as URIs or to create basic network clients and servers.</p>
                    <h5 id="uris">URIs</h5>
                    <p>A URI follows the standard defined by <a href="https://tools.ietf.org/html/rfc3986">RFC 3986</a>, it is mostly used to identify resources such as file or more specifically a route in a Web server. The JDK provides a standard implementation which is not close to what is required by the <em>web</em> module to name just one.</p>
                    <p>The <code>URIs</code> utility class is the main entry point for working on URIs in any ways imaginable. It defines methods to create a blank URI or a URI based on a given path or URI. These methods return a <code>URIBuilder</code> instance which is then used to build a URI, a path, a query string or a URI pattern.</p>
                    <p>A simple URI can then be created as follows:</p>
                    <pre><code class="language-java">// http://localhost:8080/path/to/resource?parameter=value
URI uri = URIs.uri()
    .scheme("http")
    .host("localhost")
    .port(8080)
    .path("/path/to/resource")
    .queryParameter("parameter", "value")
    .build();
</code></pre>
                    <p>or from an existing URI as follows:</p>
                    <pre><code class="language-java">// https://test-server/path/to/resource
URI uri = URIs.uri(URI.create("http://localhost:8080/path/to?parameter=value"))
    .scheme("https")
    .host("test-server")
    .port(null)
    .segment("resource")
    .clearQuery()
    .build();
</code></pre>
                    <p>A URI can be normalized by enabling the <code>URIs.Option.NORMALIZED</code> option:</p>
                    <pre><code class="language-java">// path/to/other
URI uri = URIs.uri("path/to/resource", URIs.Option.NORMALIZED)
    .segment("..")
    .segment("other")
    .build();
</code></pre>
                    <p>A parameterized URI can be created by enabling the <code>URIs.Option#PARAMETERIZED</code> option and specifying parameters of the form <code>{[&lt;name&gt;][:&lt;pattern&gt;]}</code> in the components of the URI. This allows to create URI templates that can be used to generate URIs from a set of parameters.</p>
                    <pre><code class="language-java">URIBuilder uriTemplate = URIs.uri(URIs.Option.PARAMETERIZED)
    .scheme("{scheme}")
    .host("{host}")
    .path("/path/to/resource")
    .segment("{id}")
    .queryParameter("format", "{format}");

// http://locahost/path/to/resource/1?format=text
URI uri1 = uriTemplate.build("http", "localhost", "1", "text");

// https://production/path/to/resource/32?format=json
URI uri2 = uriTemplate.build("https", "production", "32", "json");
</code></pre>
                    <p>The <code>URIBuilder</code> also defines methods to create string representations of the whole URI, the path component or the query component.</p>
                    <pre><code class="language-java">URIBuilder uriBuilder = URIs.uri()
    .scheme("http")
    .host("localhost")
    .port(8080)
    .path("/path/to/resource")
    .queryParameter("parameter", ""value);

// http://localhost:8080/path/to/resource?parameter=value
String uri = uriBuilder.buildString();

// path/to/resource
String path = uriBuilder.buildPath();

// parameter=value
String query = uriBuilder.buildQuery();
</code></pre>
                    <p>It can also create <code>URIPattern</code> to match a given input against the pattern specified by the URI while extracting parameter values when the URI is parameterized.</p>
                    <pre><code class="language-java">URIPattern uriPattern = URIs.uri(URIs.Option.PARAMETERIZED)
    .scheme("{scheme}")
    .host("{host}")
    .path("/path/to/resource")
    .segment("{id}")
    .queryParameter("format", "{format}")
    .buildPattern();

URIMatcher matcher = uriPattern.matcher("http://localhost:8080/path/to/resource/1?format=text");
if(matcher.matches()) {
    // scheme=http, host=localhost, id=1, format=text
    Map&lt;String, String&gt; parameters = matcher.getParameters();
    ...
}
</code></pre>
                    <p>Path patterns are also supported by enabling the <code>URIs.Option#PATH_PATTERN</code> option and allows to create URI patterns with question marks or wildcards.</p>
                    <pre><code class="language-java">// Matches all .java files under /src path
URIPattern uriPattern = URIs.uri("/src/**/*.java", URIs.RequestTargetForm.ABSOLUTE, URIs.Option.PATH_PATTERN)
    .buildPathPattern();

// Matches test.jsp, tast.jsp, t1st.jsp...
uriPattern = URIs.uri("/t?st.java", URIs.RequestTargetForm.ABSOLUTE, URIs.Option.PATH_PATTERN)
    .buildPathPattern();
</code></pre>
                    <blockquote>
                        <p>Note that the Path pattern option is not compatible with <code>ORIGIN</code> form request target, as a result the URI must be created using the <code>ABSOLUTE</code> request target form.</p>
                    </blockquote>
                    <p>It is possible to determine whether a path pattern is included into another. A path pattern is said to be included into another path pattern if and only if the set of URIs matched by this pattern is included in the set of URIs matched by the other pattern.</p>
                    <p>̀```java URIPattern pathPattern1 = URIs.uri("/src/**", URIs.RequestTargetForm.ABSOLUTE, URIs.Option.PATH_PATTERN) .buildPathPattern();</p>
                    <p>URIPattern pathPattern2 = URIs.uri("/src/java/**/*.java", URIs.RequestTargetForm.ABSOLUTE, URIs.Option.PATH_PATTERN) .buildPathPattern();</p>
                    <p>URIPattern.Inclusion inclusion = uriPattern1.includes(uriPattern2); // returns URIPattern.Inclusion.INCLUDED ̀```</p>
                    <p>The proposed implementation is not exact which is why the <code>includes()</code> method returns <code>INCLUDED</code> when inclusion could be determined with certainty, <code>DISJOINT</code> when exclusion could be determined with certainty and <code>INDETERMINATE</code> when inclusion could not be determined with certainty.</p>
                    <blockquote>
                        <p>Note that inclusion can only be determined when considering path patterns, ie. created using <code>buildPathPattern()</code> method and containing only a path component. The <code>includes()</code> method will always return <code>INDETERMINATE</code> for any other type of URI patterns.</p>
                    </blockquote>
                    <h5 id="network-service">Network service</h5>
                    <p>The <code>NetService</code> interface specifies a service for building optimized network clients and servers based on Netty. The <em>base</em> module doesn't provide any implementation, a base implementation is provided in the <em>boot</em> module.</p>
                    <p>This service especially defines methods to obtain <code>EventLoopGroup</code> instances backed by a root event loop group in order to reuse event loops across different network servers or clients running in the same application.</p>
                    <p>It also defines methods to create basic network client and server bootstraps.</p>
                    <h4 id="reflection-api">Reflection API</h4>
                    <p>The reflection API provides classes and interfaces for building <code>java.lang.reflect.Type</code> instances in order to represent parameterized types at runtime which is otherwise not possible due to type erasure. Such <code>Type</code> instances are used when decoding data into objects of parameterized types.</p>
                    <p>The <code>Types</code> class is the main entry point for building any kind of Java types.</p>
                    <pre><code class="language-java">// java.util.List&lt;? extends java.lang.Comparable&lt;java.lang.String&gt;&gt;
Type type = Types.type(List.class)
    .wildcardType()
        .upperBoundType(Comparable.class)
            .type(String.class).and()
    .and()
    .build();
</code></pre>
                    <p>The reflection API is particularly useful to specify a parameterized type to an <a href="#object-converter">object converter</a>. For instance, let's imagine we have a <code>ByteBuf</code> we want to decode to a <code>List&lt;String&gt;</code>, we can do:</p>
                    <pre><code class="language-java">ByteBuf input = ...;
ObjectConverter&lt;ByteBuf&gt; converter = ...;

Type listOfStringType = Types.type(List.class)
    .type(String.class).and()
    .build();
List&lt;String&gt; decode = converter.&lt;List&lt;String&gt;&gt;decode(input, listOfStringType);
</code></pre>
                    <h4 id="resource-api">Resource API</h4>
                    <p>The resource API provides classes and interfaces for accessing resources of different kinds and locations (file, zip, jar, classpath, module...) in a consistent way using a unique <code>Resource</code> interface.</p>
                    <p>A resource can be created directly using the implementation corresponding to the kind of resource. For instance, in order to access a resource on the class path, you need to choose the <code>ClasspathResource</code> implementation:</p>
                    <pre><code class="language-java">ClasspathResource resource = new ClasspathResource(URI.create("classpath:/path/to/resource"));
</code></pre>
                    <p>A resource is identified by a URI whose scheme specifies the kind of resources. The <em>base</em> module provides several implementations with a corresponding scheme.</p>
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered ">
                            <tbody>
                              <tr>
                              <th>Type</th>
                              <th>URI</th>
                              <th>Implementation</th>
                              </tr>
                              <tr>
                              <td><code>file</code></td>
                              <td><code>file:/path/to/resource</code></td>
                              <td><code>FileResource</code></td>
                              </tr>
                              <tr>
                              <td><code>zip</code></td>
                              <td><code>zip:/path/to/zip!/path/to/resource</code></td>
                              <td><code>ZipResource</code></td>
                              </tr>
                              <tr>
                              <td><code>jar</code></td>
                              <td><code>jar:/path/to/jar!/path/to/resource</code></td>
                              <td><code>JarResource</code></td>
                              </tr>
                              <tr>
                              <td><code>url</code></td>
                              <td><code>http|https|ftp://host/path/to/resource</code></td>
                              <td><code>URLResource</code></td>
                              </tr>
                              <tr>
                              <td><code>classpath</code></td>
                              <td><code>classpath:/path/to/resource</code></td>
                              <td><code>ClasspathResource</code></td>
                              </tr>
                              <tr>
                              <td><code>module</code></td>
                              <td><code>module://[MODULE_NAME]/path/to/resource</code></td>
                              <td><code>ModuleResource</code></td>
                              </tr>
                            </tbody>
                        </table>
                    </div>
                    <p>The <code>ResourceService</code> interface specifies a service which provides a unified access to resources based only on the resource URI. The <em>base</em> module doesn't provide any implementation, a base implementation is provided in the <em>boot</em> module.</p>
                    <p>A typical use case is to get a resource from a URI without knowing the actual kind of the resource.</p>
                    <pre><code class="language-java">ResourceService resourceService = ...

Resource resource = resourceService.getResource(URI.create("classpath:/path/to/resource"));
</code></pre>
                    <p>The resource service can also be used to list resources at a given location. Nonetheless this actually depends on the implementation and the kind of resource, although it is clearly possible to list resources from a file location, it might not be supported to list resources from a class path or URL location.</p>
                    <p>The <em>boot</em> module <a href="#resource-service">implementation</a> supports for instance the listing of resources that match a specific path pattern:</p>
                    <pre><code class="language-java">ResourceService resourceService = ...

Stream&lt;Resource&gt; resources = resourceService.getResources(URI.create("file:/path/to/resources/**/*"));
</code></pre>
                    <p>The <code>MediaTypeService</code> interface specifies a service used to determine the media type of a resource based on its extension, name, path or URI. As for the resource service, a base implementation is provided in the <em>boot</em> module.</p>
                    <pre><code class="language-java">MediaTypeService mediaTypeService = ...

// image/png
String mediaType = mediaTypeService.getForExtension("png");
</code></pre>
                    <h3 id="boot">Boot</h3>
                    <p>The Inverno <em>boot</em> module provides basic services to applications including several base implementation for interfaces defined in the <em>base</em> module.</p>
                    <p>The Inverno <em>boot</em> module is the basic building block for any application and as such it must be the first module to declare in an application module descriptor.</p>
                    <pre><code class="language-java">@io.inverno.core.annotation.Module
module io.inverno.example.app {
    requires io.inverno.mod.boot;
    // Other modules...
}
</code></pre>
                    <p>The <em>boot</em> module declares transitive dependencies to the core IoC/DI modules as well as <em>base</em> and <em>configuration</em> modules. They don't need to be re-declared.</p>
                    <p>This dependency must also be declared in the build descriptor:</p>
                    <p>Using Maven:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-boot&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <p>Using Gradle:</p>
                    <pre><code class="language-java">...
compile 'io.inverno.mod:inverno-boot:1.5.2'
...
</code></pre>
                    <h4 id="configuration">Configuration</h4>
                    <p>The <code>BootConfiguration</code> is used to configure the beans exposed in the <em>boot</em> module, the <code>Reactor</code> and the <code>NetService</code> in particular.</p>
                    <p>Please refer to the <a href="https://inverno.io/docs/release/api/index.html">API documentation</a> to have an exhaustive description of the different configuration properties.</p>
                    <h4 id="reactor">Reactor</h4>
                    <p>The module provides two <code>Reactor</code> implementations: one generic implementation which creates a regular Netty event loop group and a <a href="https://vertx.io/">Vert.x</a> core implementation which uses the event loops of a <code>Vertx</code> instance. The Vert.x implementation is particularly suited when an Inverno application must integrate Vert.x services such as the PostgreSQL client.</p>
                    <p>The module exposes one or the other as bean depending on the <em>boot</em> module configuration, parameter <code>reactor_prefer_vertx</code> must be set to true, and whether or not the Vert.x core module is present on the module path.</p>
                    <h4 id="net-service">Net service</h4>
                    <p>The module provides a base <code>NetService</code> implementation exposed as a bean for building network applications based on <a href="https://netty.io/">Netty</a>.</p>
                    <h4 id="media-type-service">Media type service</h4>
                    <p>The module provides a base <code>MediaTypeService</code> implementation based on the JDK (see <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/file/Files.html#probeContentType-java.nio.file.Path-">Files.probeContentType(Path)</a>) and exposed as an overridable bean allowing custom implementations to be provided.</p>
                    <h4 id="resource-service">Resource service</h4>
                    <p>The module provides a base <code>ResourceService</code> implementation exposed as a bean for accessing resources.</p>
                    <p>This base implementation supports the following schemes: <code>file</code>, <code>zip</code>, <code>jar</code>, <code>classpath</code>, <code>module</code>, <code>http</code>, <code>https</code> and <code>ftp</code> and it allows to list resources for <code>file</code>, <code>zip</code> and <code>jar</code> schemes.</p>
                    <p>When supported, resources are listed from a base URI specifying a path pattern using the following rules:</p>
                    <ul>
                        <li><code>?</code> matches one character</li>
                        <li><code>*</code> matches zero or more characters</li>
                        <li><code>**</code> matches zero or more directories in a path</li>
                    </ul>
                    <p>For instance:</p>
                    <pre><code class="language-java">ResourceService resourceService = ...

// Return: '/base/test1/a', '/base/test1/a/b', '/base/test2/c'...
Stream&lt;Resource&gt; resources = resourceService.getResources(URI.create("file:/base/test?/**/*"));
</code></pre>
                    <p>It is also possible to resolve all resources with a specific name defined in all application modules by specifying '<code>*</code>' instead of the module name in a module URI:</p>
                    <pre><code class="language-java">ResourceService resourceService = ...

// all resources named '/path/to/resource' in all application modules
Stream&lt;Resource&gt; resources = resourceService.getResources(URI.create("module://*/path/to/resource"));
</code></pre>
                    <p>This service can be extended by injecting custom <code>ResourceProvider</code> providing resources for a custom URI scheme. For instance, if we create a custom <code>Resource</code> and corresponding <code>ResourceProvider</code> implementations mapped to URI scheme <code>custom</code>, we can extend the resource service so it can create such custom resources.</p>
                    <pre><code class="language-java">Boot boot = new Base.Boot()
    .setResourceProviders(List.of(new CustomResourceProvider())
    .build();

boot.start();

Resource customResource = boot.resourceService().get(URI.create("custom:..."));
...

boot.stop();
</code></pre>
                    <h4 id="converters">Converters</h4>
                    <p>The module exposes various <code>Converter</code> implementations used across an application to convert parameter values or message payloads.</p>
                    <p>This includes the following also exposed as beans:</p>
                    <ul>
                        <li>a parameter converter for converting strings from/to objects, this converter can be extended by injecting specific compound decoders and encoders in the module as described in the <a href="#composite-converter">composite converter documentation</a>.</li>
                        <li>a JSON <code>ByteBuf</code> converter for converting raw JSON data in <code>ByteBuf</code> from/to objects in the application.</li>
                        <li>an <code>application/json</code> media type converter for converting message payloads from/to JSON.</li>
                        <li>an <code>application/x-ndjson</code> media type converter for converting message payloads from/to <a href="http://ndjson.org/">Newline Delimited JSON</a></li>
                        <li>a <code>text/plain</code> media type converter for converting message payloads from/to plain text.</li>
                    </ul>
                    <h4 id="worker-pool">Worker pool</h4>
                    <p>An Inverno application must be fully reactive, most of the processing is performed in non-blocking I/O threads but sometimes blocking operations might be needed, in such cases, the worker thread pool should be used to execute these blocking operations without impacting the I/O event loop.</p>
                    <p>The default worker pool bean is a simple <a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Executors.html#newCachedThreadPool--">cached Thread pool</a> which can be overridden by providing a different instance to the <em>boot</em> module.</p>
                    <h4 id="object-mapper">Object mapper</h4>
                    <p>A standard JSON reader/writer based on Jackson <code>ObjectMapper</code> is also provided. This instance is used across the application to perform JSON conversion operations, a global configuration can then be applied to that particular instance or it can be overridden when creating the <em>boot</em> module.</p>
                    <p>The global object mapper is configured to use <a href="https://jcp.org/en/jsr/detail?id=310">JSR310</a> for dates which are serialized as timestamps following <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> representation.</p>
                    <h3 id="configuration-1">Configuration</h3>
                    <p>The Inverno <em>configuration</em> module defines a unified configuration API for building agile and highly configurable applications.</p>
                    <p>Configuration is one of the most important aspect of an application and sadly one of the most neglected. There are very few decent configuration frameworks and most of the time they relate to one part of the issue. It is important to approach configuration by considering it as a whole and not as something that can be solved by a property file here and a database there. Besides, it must be the first issue to tackle during the design phase as it will impact all aspects of the application. For instance, we can imagine an application where configuration is defined in simple property file, a complete configuration would probably be needed for each environment where the application is deployed, maintenance would be probably problematic even more when we know that configuration properties can be added, modified or removed over time.</p>
                    <p>In its most basic form, a configuration is not more than a set of properties associating a value to a key. It would be naive to think that this would be enough to build an agile and customizable application, but in the end, the property should always be considered as the basic building block for configurations.</p>
                    <p>Now, the first thing to notice is that any part of an application can potentially be configurable, from a server IP address to a color of a button in a user interface, there are multiple forms of configuration with different expectations that must coexist in an application. For instance, some parts of the configuration are purely static and do not change during the operation of an application, this is the case of a bootstrap configuration which mostly relates to the operating environment (eg. a server port). Some other parts, on the other hand, are more dynamic and can change during the operation of an application, this is the case of tenant specific configuration or even user preferences.</p>
                    <p>Following this, we can see that a configuration greatly depends on the context in which it is loaded. The definition of a configuration, which is basically a list of property names, is dictated by the application, so when the application is running, this definition should be fixed but the context is not. For instance, the bootstrap configuration is different from one operating environment to another, user preferences are not the same from one user to another...</p>
                    <p>We can summarize this as follows:</p>
                    <ul>
                        <li>a configuration is a set of configuration properties.</li>
                        <li>the configuration of an application is actually composed of multiple configurations with their own specificities.</li>
                        <li>the definition of a configuration is bound to the application as a result the only way to change it is to change the application.</li>
                        <li>a configuration depends on a particular context which must be considered when setting or getting configuration properties.</li>
                    </ul>
                    <p>The configuration API has been created to address previous points, giving a maximum flexibility to precisely design how an application should be configured.</p>
                    <p>In order to use the Inverno <em>configuration</em> module, we need to declare a dependency in the module descriptor:</p>
                    <pre><code class="language-java">module io.inverno.example.app {
    ...
    requires io.inverno.mod.configuration;
    ...
}
</code></pre>
                    <p>And also declare that dependency in the build descriptor:</p>
                    <p>Using Maven:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-configuration&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <p>Using Gradle:</p>
                    <pre><code class="language-java">...
compile 'io.inverno.mod:inverno-configuration:1.5.2'
...
</code></pre>
                    <h4 id="configuration-source">Configuration source</h4>
                    <p>A configuration source can be any data store that holds configuration data, the API abstracts configuration data sources to provide a unified access to configuration data through the <code>ConfigurationSource</code> interface. Specific implementations should be considered depending on the type of configuration: a bootstrap configuration is most likely to be static and stored in configuration files or environment variables whereas a tenant specific configuration is most likely to be stored in a distributed data store. But this is not a universal rule, depending on the needs we can very well consider any kind of configuration source for any kind of configuration. The configuration source abstracts these concerns from the rest of the application.</p>
                    <p>The <code>ConfigurationSource</code> is the main entry point for accessing configuration properties, it shall be used every time there's a need to retrieve configuration properties. It defines only one method for creating a <code>ConfigurationQuery</code> eventually executed in order to retrieve one or more configuration properties.</p>
                    <p>For instance, property <code>server.uri</code> can be retrieved as follows:</p>
                    <pre><code class="language-java">ConfigurationSource&lt;?, ?, ?&gt; source = ...

source.get("server.url")                        // 1
    .execute()                                  // 2
    .single()                                   // 3
    .map(queryResult -&gt; queryResult
        .getResult()                            // 4
        .flatMap(ConfigurationProperty::asURI)  // 5
        .orElse(URI.create("http://localhost")) // 6
    )
    .subscribe(serverURI -&gt; ...);               // 7
</code></pre>
                    <p>In the preceding example:</p>
                    <ol>
                        <li>create a configuration query to retrieve the <code>server.url</code> property</li>
                        <li>execute the query, the API is reactive so nothing will happen until a subscription is actually made on the resulting publisher of <code>ConfigurationQueryResult</code></li>
                        <li>transform the <code>Flux</code> to a <code>Mono</code> since we expect a single result</li>
                        <li>get the resulting configuration property, a query result is always returned even if the property does not exist in the source therefore <code>getResult()</code> returns an <code>Optional</code> that lets you decide what to do if the property is missing</li>
                        <li>convert the property value to URI if present, a property can be defined in a source with a null value which explains why the property value is also an <code>Optional</code> and why we need to use <code>flatMap()</code></li>
                        <li>return the actual value if it exists or the specified default value</li>
                        <li>subscribe to the <code>Mono</code> which actually runs the query in the source and return the property value or the default value if the property value is null or not defined in the source</li>
                    </ol>
                    <p>This seems to be a lot of steps to simply retrieve one property value, but if you look closely you'll understand that each of them is actually necessary:</p>
                    <ul>
                        <li>we want to be able to retrieve multiple properties and/or create more complex queries in a batch so <code>.execute()</code> is required to mark the end of a batch of queries</li>
                        <li>we want to be reactive so <code>.single().map()</code> and <code>subscribe()</code> are required</li>
                        <li>we want to have access to the configuration query key at the origin of a property for troubleshooting as a result the query result must expose <code>getQueryKey()</code> and <code>getResult()</code> methods</li>
                        <li>we want to be able to convert a property value and provide different behaviors when a property does not exist in a source or when it does exist but with a null value, as a result <code>.flatMap(property -&gt; property.asURI()).orElse(URI.create("http://localhost"))</code> is required</li>
                    </ul>
                    <p>As we said earlier, a configuration depends on the context: a given property might have different values when considering different contexts. The configuration API defines a configuration property with a name, a value and a set of parameters specifying the context for which the property is defined. Such configuration property is referred to as a <strong>parameterized configuration property</strong>.</p>
                    <blockquote>
                        <p>Some configuration source implementations do not support parameterized configuration property, they simply ignore parameters specified in queries and return the value associated to the property name. This is especially the case of environment variables which don't allow to specify property parameters.</p>
                    </blockquote>
                    <p>In order to retrieve a property in a particular context we can then parameterized the configuration query as follows:</p>
                    <pre><code class="language-java">source.get("server.url")
    .withParameters("environment", "production", "zone", "us")
    .execute()
    ...
</code></pre>
                    <p>In the preceding example, we query the source for property <code>server.url</code> defined for the production environment in zone US. To state the obvious, both the list of parameters and their values can be determined at runtime using actual contextual values. This is what makes parameterized properties so powerful as it is suitable for a wide range of use cases. This is all the more true when using <a href="#defaultable-configuration-source">defaultable configuration sources</a> which use defaulting strategies to determine the best matching value corresponding to a given query.</p>
                    <p>As said before the API let's you fluently query multiple properties in a batch and map the results in a configuration object.</p>
                    <pre><code class="language-java">source
    .get("server.port", "db.url", "db.user", "db.password").withParameters("environment", "production", "zone", "us")
    .and()
    .get("db.schema").withParameters("environment", "production", "zone", "us", "tenant", "someCompany")
    .execute()
    .collectMap(queryResult -&gt; queryResult.getQueryKey().getName(), queryResult -&gt; queryResult.getResult())
    .map(properties -&gt; {
        ApplicationConfiguration config = new ApplicationConfiguration();
        
        properties.get("server.port").flatMap(property -&gt; property.asInteger()).ifPresent(config::setServerPort);
        properties.get("db.url").flatMap(property -&gt; property.asURL()).ifPresent(config::setDbURL);
        properties.get("db.user").flatMap(property -&gt; property.asString()).ifPresent(config::setDbUser);
        String dbPassword = properties.get("db.password").flatMap(property -&gt; property.asString()).ifPresent(config::setDbPassword);
        String dbSchema = properties.get("db.schema").flatMap(property -&gt; property.asString()).ifPresent(config::setDbSchema);
        
        return config;
    })
    .subscribe(config -&gt; {
        ...
    });
</code></pre>
                    <p>The beauty of being reactive is that it comes with a lot of cool features such as the ability to re-execute a query or caching the result. A <code>Flux</code> or a <code>Mono</code> executes on subscriptions, which means we can create a complex query to retrieve a whole configuration, keep the resulting Reactive Streams <code>Publisher</code> and subscribe to it when needed. A Reactive Stream publisher can also cache configuration results.</p>
                    <pre><code class="language-java">Mono&lt;ApplicationConfiguration&gt; configurationLoader = ... // see previous example

// Query the source on each subscriptions
configurationLoader.subscribe(config -&gt; {
    ...
});

// Cache the configuration for five minutes
Mono&lt;ApplicationConfiguration&gt; cachedConfigurationLoader = configurationLoader.cache(Duration.ofMinutes(5));

// Query the source on first subscription, further subscriptions within a window of 5 minutes will get the cached configuration
cachedConfigurationLoader.subscribe(config -&gt; {
    ...
});
</code></pre>
                    <blockquote>
                        <p>Although publisher caching is a cool feature, it might not be ideal for complex caching use cases and more solid solution should be considered.</p>
                    </blockquote>
                    <p>A configuration source relies on a <code>SplittablePrimitiveDecoder</code> to decode property values. Configuration source implementations usually provide a default decoder but it is possible to inject custom decoders to decode particular configuration values. The expected decoder implementation depends on the configuration source implementation but most of the time a string to object decoder is expected.</p>
                    <pre><code class="language-java">SplittablePrimitiveDecoder&lt;String&gt; customDecoder = ...

PropertyFileConfigurationSource source = new PropertyFileConfigurationSource(new ClasspathResource(URI.create("classpath:/path/to/configuration.properties")), customDecoder)
</code></pre>
                    <p>The regular and most efficient way to query a configuration source is to target specific configuration properties identified by a name and a set of parameters, however there are some cases that actually require to list all values defined for a particular property name and matching a particular set of parameters.</p>
                    <p>for instance, this is typically the case when configuring log levels, since we can hardly know the name of each and every loggers used in an application, it is easier, safer and more efficient in that case to list all the configuration properties defined for a <code>logging.level</code> property and apply the configuration to the loggers based on the parameters of the returned properties.</p>
                    <p>For instance, the following properties can be defined in the configuration:</p>
                    <pre><code>logging.level[]=info
logging.level[logger="logger1"]=debug
logging.level[logger="logger2"]=trace
logging.level[logger="logger3"]=error
</code></pre>
                    <p>These configuration properties can then be listed in the application as follows:</p>
                    <pre><code class="language-java">// Returns all logging.level properties defined in the configuration source
List&lt;ConfigurationProperty&gt; result = source.list("logging.level")
	.executeAll()
	.collectList()
	.block();

// Apply logging configuration
for(ConfigurationProperty p : result) {
    Optional&lt;String&gt; loggerName = p.getKey().getParameter("logger");
    Level level = p.as(Level.class).get();
	// Configure logger...
}
</code></pre>
                    <p>The <code>executeAll()</code> method returns all the properties defined in the configuration source for a particular property name and matching the set of parameters defined in the query whether they are defined with extra parameters or not. For instance, if we extend our example by adding an <code>environment</code> parameter:</p>
                    <pre><code>logging.level[]=info
logging.level[environment="dev",logger="logger1"]=debug
logging.level[environment="prod",logger="logger2"]=trace
logging.level[logger="logger3"]=error
</code></pre>
                    <p>The following list query will return all values that are defined with a <code>logger</code> parameter whether they are defined with an <code>environment</code> parameter or not. Please note how the <code>logger</code> parameter is specified in the query as a wildcard:</p>
                    <pre><code class="language-java">// Returns logging.level[environment="dev", logger="logger1"], logging.level[environment="prod", logger="logger2"] and logging.level[logger="logger3"]=error which are all defined with parameter logger
List&lt;ConfigurationProperty&gt; result = source.list("logging.level")
	.withParameters(Parameter.wildcard("logger"))
	.executeAll()
	.collectList()
	.block();
</code></pre>
                    <p>On the other hand, the <code>execute()</code> method is exact and returns all the properties defined in the configuration source for a particular property name and which parameters exactly match the set of parameters defined in the query, excluding those that are defined with extra parameters:</p>
                    <pre><code class="language-java">// Returns logging.level[logger="logger3"]=error which exactly defines parameter logger
List&lt;ConfigurationProperty&gt; result = source.list("logging.level")
	.withParameters(Parameter.wildcard("logger"))
	.execute()
	.collectList()
	.block();
</code></pre>
                    <h5 id="configurable-configuration-source">Configurable configuration source</h5>
                    <p>A configurable configuration source is a particular configuration source which supports configuration properties updates. The <a href="#redis-configuration-source">Redis configuration source</a> is an example of configurable configuration source.</p>
                    <p>The <code>ConfigurableConfigurationSource</code> interface is the main entry point for updating configuration properties, it shall be used every time there's a need to retrieve or set configuration properties.</p>
                    <p>It extends the <code>ConfigurationSource</code> with one method for creating a <code>ConfigurationUpdate</code> instance eventually executed in order to set one or more configuration properties in the configuration source.</p>
                    <p>For instance, a parameterized property <code>server.port</code> can be set in a configuration source as follows:</p>
                    <pre><code class="language-java">ConfigurableConfigurationSource&lt;?, ?, ?, ?, ?&gt; source = null;

source.set("server.port", 8080)
    .withParameters("environment", "production", "zone", "us")
    .execute()
    .single()
    .subscribe(
        updateResult -&gt; {
            try {
                updateResult.check();
                // Update succeeded
                ...
            }
            catch(ConfigurationSourceException e) {
                // Update failed
                ...
            }
        }
    );
</code></pre>
                    <p>A configurable configuration source relies on a <code>JoinablePrimitiveEncoder</code> to encode property values. Implementations usually provide a default encoder but it is possible to inject custom encoders to encode particular configuration values. The expected encoder implementation depends on the configuration source implementation but most of the time an object to string encoder is expected.</p>
                    <pre><code class="language-java">RedisClient redisClient = ...
JoinablePrimitiveEncoder&lt;String&gt; customEncoder = ...
SplittablePrimitiveDecoder&lt;String&gt; customDecoder = ...

RedisConfigurationSource source = new RedisConfigurationSource(redisClient, customEncoder, customDecoder)
</code></pre>
                    <h5 id="defaultable-configuration-source">Defaultable configuration source</h5>
                    <p>By default, a configuration source returns the result that exactly match the configuration query. When considering parameterized configuration properties, this behaviour can quickly become quite retrictive and a defaulting mechanism that would allow to select the best matching value among those defined in the source could reveal their full potential.</p>
                    <p>A defaultable configuration source is a particular source that can rely on a defaulting strategy to determine the best matching value for a given configuration query. A defaultable configuration source implements <code>DefaultableConfigurationSource</code> which allows to choose the defaulting strategy to use by wrapping the original source:</p>
                    <pre><code class="language-java">DefaultableConfigurationSource&lt;?, ?, ?, ?&gt; source = ...

DefaultableConfigurationSource&lt;?, ?, ?, ?&gt; defaultingSource = source.withDefaultingStrategy(DefaultingStrategy.lookup());

DefaultableConfigurationSource&lt;?, ?, ?, ?&gt; originalSource = defaultingSource.unwrap();
</code></pre>
                    <p>A <code>DefaultingStrategy</code> provides two methods <code>#getDefaultingKeys(ConfigurationKey queryKey)</code> and <code>#getListDefaultingKeys(ConfigurationKey queryKey)</code> which respectively derives the actual keys to retrieve from the source ordered by priorities from the highest to the lowest to determine the best-matching value for the query (the first existing value shall be returned) and the actual keys that must be retained when listing properties. The configuration module provides three implementations: <code>DefaultingStrategy#noOp()</code> strategy, <code>DefaultingStrategy#lookup()</code> and <code>DefaultingStrategy#wildcard()</code>.</p>
                    <h6 id="noop-defaulting-strategy">noOp defaulting strategy</h6>
                    <p>The noOp strategy is used to return exact results. This is the default behaviour for all configuration sources.</p>
                    <h6 id="lookup-defaulting-strategy">lookup defaulting strategy</h6>
                    <p>The lookup strategy prioritizes query parameters from left to right and is used to return the best matching property as the one matching the most continuous parameters from left to right.</p>
                    <p>If we consider query key <code>property[p1=v1,...pn=vn]</code>, it supersedes key <code>property[p1=v1,...pn-1=vn-1]</code> which supersedes key <code>property[p1=v1,...pn-2=vn-2]}</code>... which supersedes key <code>property[]</code>. It basically tells the source to lookup by successively removing the rightmost parameter if no exact result exists for a particular query.</p>
                    <p>For instance, if we consider a source with the following properties:</p>
                    <ul>
                        <li><code>log.level[]=INFO</code></li>
                        <li><code>log.level[environment = "prod"]=WARN</code></li>
                        <li><code>log.level[environment = "prod", name = "test1"]=ERROR</code></li>
                    </ul>
                    <p>We can run the following queries with defaulting:</p>
                    <pre><code class="language-java">DefaultableConfigurationSource&lt;?, ?, ?, ?&gt; source = null;
    source = source.withDefaultingStrategy(DefaultingStrategy.lookup());
    source
        .get("log.level").withParameters("environment", "dev", "name", "test1")        // 1
        .and().get("log.level").withParameters("environment", "prod", "name", "test2") // 2
        .and().get("log.level").withParameters("environment", "prod", "name", "test1") // 3
        .and().get("log.level").withParameters("name", "test1")                        // 4
        .and().get("log.level").withParameters("name", "test2", "environment", "prod") // 5
        .execute()
        ...
</code></pre>
                    <ol>
                        <li>Returns <code>INFO</code> which corresponds to <code>log.level[]</code> property since properties <code>log.level[environment = "dev", name = "test1"]</code> and <code>log.level[environment = "dev"]</code> are not defined</li>
                        <li>Returns <code>WARN</code> which corresponds to <code>log.level[environment = "prod"]</code> since property <code>log.level[environment = "dev", name = "test2"]</code> is not defined</li>
                        <li>Returns <code>ERROR</code> which corresponds to the exact match</li>
                        <li>Returns <code>INFO</code> which corresponds to <code>log.level[]</code> property since property <code>log.level[name = "test1"]</code> is not defined</li>
                        <li>Returns <code>INFO</code> which corresponds to <code>log.level[]</code> properties since property <code>log.level[name = "test2", "environment", "prod"]</code> and <code>log.level[name = "test2"]</code> are not defined</li>
                    </ol>
                    <p>Since parameters are prioritized from left to right, the order into which they are defined in the query is important. As you can see in see in above example querying <code>log.level[environment = "prod", name = "test2"]</code> is not the same as querying <code>log.level[name = "test2", environment = "prod"]</code>.</p>
                    <p>A query with <code>n</code> parameters results in at most <code>n+1</code> properties being retrieved from the source depending on the implementation.</p>
                    <h6 id="wildcard-defaulting-strategy">wildcard defaulting strategy</h6>
                    <p>The wildcard strategy returns the best matching property as the one matching the most of the query parameters while prioritizing them from left ro right.</p>
                    <p>If we consider query key <code>property[p1=v1,...pn=vn]</code>, the most precise result is the one defining parameters <code>[p1=v1,...pn=vn]</code>, it supersedes results that define <code>n-1</code> query parameters, which supersedes results that define <code>n-2</code> query parameters... which supersedes results that define no query parameters. Conflicts may arise when a source defines a property with different set of query parameters with the same cardinality (e.g. when it defines properties <code>property[p1=v1,p2=v2]</code> and <code>property[p1=v1,p3=v3]</code>). In such situation, priority is always given to parameters from left to right (therefore <code>property[p1=v1,p2=v2]</code> supersedes <code>property[p1=v1,p3=v3]</code>).</p>
                    <p>Considering previous example but with the wildcard strategy instead of the lookup strategy, some queries have different results:</p>
                    <pre><code class="language-java">DefaultableConfigurationSource&lt;?, ?, ?, ?&gt; source = null;
    source = source.withDefaultingStrategy(DefaultingStrategy.wildcard());
    source
        .get("log.level").withParameters("environment", "dev", "name", "test1")        // 1
        .and().get("log.level").withParameters("environment", "prod", "name", "test2") // 2
        .and().get("log.level").withParameters("environment", "prod", "name", "test1") // 3
        .and().get("log.level").withParameters("name", "test1")                        // 4
        .and().get("log.level").withParameters("name", "test2", "environment", "prod") // 5
        .execute()
        ...
</code></pre>
                    <ol>
                        <li>Returns <code>INFO</code> which corresponds to <code>log.level[]</code> property since properties <code>log.level[environment = "dev", name = "test1"]</code>, <code>log.level[environment = "dev"]</code> and <code>log.level[name = "test1"]</code> are not defined</li>
                        <li>Returns <code>WARN</code> which corresponds to <code>log.level[environment = "prod"]</code> since property <code>log.level[environment = "dev", name = "test2"]</code> is not defined and property <code>log.level[environment = "prod"]</code> is defined (it would also have superseded property <code>log.level[environment = "test2"]</code> if it had been defined)</li>
                        <li>Returns <code>ERROR</code> which corresponds to the exact match</li>
                        <li>Returns <code>INFO</code> which corresponds to <code>log.level[]</code> property since property <code>log.level[name = "test1"]</code> is not defined</li>
                        <li>Returns <code>WARN</code> which corresponds to <code>log.level[environment = "prod"]</code> since properties <code>log.level[name = "test2", environment = "prod"]</code> and <code>log.level[name = "test2"]</code> are not defined, but property <code>log.level[environment = "prod"]</code> is defined</li>
                    </ol>
                    <p>As for the lookup strategy, the order into which they are defined in the query is important and querying <code>log.level[environment = "prod", name = "test2"]</code> is not the same as querying <code>log.level[name = "test2", environment = "prod"]</code>.</p>
                    <p>A query with <code>n</code> parameters results in at most <code>2<sup>n</sup></code> properties being retrieved from the source depending on the implementation.</p>
                    <h5 id="map-configuration-source">Map configuration source</h5>
                    <p>The map configuration is the most basic configuration source implementation. It exposes configuration properties stored in a map in memory. It doesn't support parameterized properties, regardless of the parameters specified in a query, only the property name is considered when resolving a value.</p>
                    <pre><code class="language-java">MapConfigurationSource source = new MapConfigurationSource(Map.of("server.url", new URL("http://localhost")));
...
</code></pre>
                    <p>This source is <a href="#defaultable-configuration-source">defaultable</a> and it can be used for testing purpose in order to provide a mock configuration source.</p>
                    <h5 id="system-environment-configuration-source">System environment configuration source</h5>
                    <p>The system environment configuration source exposes system environment variables as configuration properties. As for the map configuration source, this implementation doesn't support parameterized properties.</p>
                    <pre><code class="language-plaintext">$ export SERVER_URL=http://localhost
</code></pre>
                    <pre><code class="language-java">SystemEnvironmentConfigurationSource source = new SystemEnvironmentConfigurationSource();
...
</code></pre>
                    <p>This implementation can be used to bootstrap an application using system environment variables.</p>
                    <h5 id="system-properties-configuration-source">System properties configuration source</h5>
                    <p>The system properties configuration source exposes system properties as configuration properties. As for the two previous implementations, it doesn't support parameterized properties.</p>
                    <pre><code class="language-plaintext">$ java -Dserver.url=http://localhost ...
</code></pre>
                    <pre><code class="language-java">SystemPropertiesConfigurationSource source = new SystemPropertiesConfigurationSource();
...
</code></pre>
                    <p>This implementation can be used to bootstrap an application using system properties.</p>
                    <h5 id="command-line-configuration-source">Command line configuration source</h5>
                    <p>The command line configuration source exposes configuration properties specified as command line arguments of the application. This implementation supports parameterized properties.</p>
                    <p>Configuration properties must be specified as application arguments using the following syntax: <code>--property[parameter_1=value_1...parameter_n=value_n]=value</code> where property and parameter names are valid Java identifiers and property and parameter values are Java primitives such as integer, boolean, string... A complete description of the syntax can be found in the <a href="https://inverno.io/docs/release/api/index.html">API documentation</a>.</p>
                    <p>For instance the following are valid configuration properties specified as command line arguments:</p>
                    <pre><code class="language-plaintext">$ java ... Main \
--web.server_port=8080 \
--web.server_port[profile="ssl"]=8443 \
--db.url[env="dev"]="jdbc:oracle:thin:@dev.db.server:1521:sid" \
--db.url[env="prod",zone="eu"]="jdbc:oracle:thin:@prod_eu.db.server:1521:sid" \
--db.url[env="prod",zone="us"]="jdbc:oracle:thin:@prod_us.db.server:1521:sid"
</code></pre>
                    <pre><code class="language-java">public static void main(String[] args) {
    CommandLineConfigurationSource source = new CommandLineConfigurationSource(args);
    ...
}
...
</code></pre>
                    <p>This implementation is <a href="#defaultable-configuration-source">defaultable</a>.</p>
                    <h5 id="properties-file-configuration-source"><code>.properties</code> file configuration source</h5>
                    <p>The <code>.properties</code> file configuration source exposes configuration properties specified in a <code>.properties</code> file. This implementation supports parameterized properties.</p>
                    <p>Configuration properties can be specified in a property file using a syntax similar to the command line configuration source for the property key. Some characters must be escaped with respect to the <code>.properties</code> file format. Property values don't need to follow Java's notation for strings since they are considered as strings by design.</p>
                    <pre><code class="language-properties">web.server_port=8080 
web.server_port[profile\="ssl"]=8443
db.url[env\="dev"]=jdbc:oracle:thin:@dev.db.server:1521:sid
db.url[env\="prod",zone\="eu"]=jdbc:oracle:thin:@prod_eu.db.server:1521:sid
db.url[env\="prod",zone\="us"]=jdbc:oracle:thin:@prod_us.db.server:1521:sid
</code></pre>
                    <pre><code class="language-java">PropertyFileConfigurationSource source = new PropertyFileConfigurationSource(new ClasspathResource(URI.create("classpath:/path/to/file")));
...
</code></pre>
                    <p>This implementation is <a href="#defaultable-configuration-source">defaultable</a>.</p>
                    <h5 id="cprops-file-configuration-source"><code>.cprops</code> file configuration source</h5>
                    <p>The <code>.cprops</code> file configuration source exposes configuratio properties specified in a <code>.cprops</code> file. This implementation supports parameterized properties.</p>
                    <p>The <code>.cprops</code> file format has been introduced to facilitate the definition and reading of parameterized properties. In particular it allows to regroup the definition of properties with common parameters into sections and many more.</p>
                    <p>For instance:</p>
                    <pre><code class="language-properties">### This is a comment
server.port=8080
db.url=jdbc:oracle:thin:@localhost:1521:sid
db.user=user
db.password=password
log.level=ERROR
application.greeting.message="""
 === Welcome! === 

     This is      
    a formated    
     message.     

 ================
"""

[ environment="test" ] {
    db.url=jdbc:oracle:thin:@test:1521:sid
    db.user=user_test
    db.password=password_test
}

[ environment="production" ] {
    db.url=jdbc:oracle:thin:@production:1521:sid
    db.user=user_production
    db.password=password_production
    
    [ zone="US" ] {
        db.url=jdbc:oracle:thin:@production.us:1521:sid
    }
    
    [ zone="EU" ] {
        db.url=jdbc:oracle:thin:@production.eu:1521:sid
    }
    
    [ zone="EU", node="node1" ] {
        log.level=DEBUG
    }
}
</code></pre>
                    <p>A complete <a href="https://javacc.github.io/javacc/">JavaCC</a> <a href="https://github.com/inverno-io/inverno-mods/tree/master/inverno-configuration/src/main/javacc/configuration_properties.jj">grammar</a> is available in the source of the configuration module.</p>
                    <pre><code class="language-java">CPropsFileConfigurationSource source = new CPropsFileConfigurationSource(new ClasspathResource(URI.create("classpath:/path/to/file")));
...
</code></pre>
                    <p>This implementation is <a href="#defaultable-configuration-source">defaultable</a>.</p>
                    <h5 id="redis-configuration-source">Redis configuration source</h5>
                    <p>The <a href="https://redis.io/">Redis</a> configuration source exposes configuration properties stored in a Redis data store. This implementation supports parameterized properties and it is also configurable which means it can be used to set configuration properties in the data store at runtime.</p>
                    <p>The following example shows how to set configuration properties for the <code>dev</code> and <code>prod</code> environment:</p>
                    <pre><code class="language-java">RedisClient&lt;String, String&gt; redisClient = ...
RedisConfigurationSource source = new RedisConfigurationSource(redisClient);

source
    .set("db.url", "jdbc:oracle:thin:@dev.db.server:1521:sid").withParameters("environment", "dev").and()
    .set("db.url", "jdbc:oracle:thin:@prod_eu.db.server:1521:sid").withParameters("environment", "prod", "zone", "eu").and()
    .set("db.url", "jdbc:oracle:thin:@prod_us.db.server:1521:sid").withParameters("environment", "prod", "zone", "us")
    .execute()
    .blockLast();
</code></pre>
                    <p>This implementation is <a href="#defaultable-configuration-source">defaultable</a>.</p>
                    <h5 id="versioned-redis-configuration-source">Versioned Redis configuration source</h5>
                    <p>The versioned <a href="https://redis.io/">Redis</a> configuration source exposes configuration properties stored in a Redis data store. This implementation supports parameterized properties and it is also configurable which means it can be used to set configuration properties in the data store at runtime.</p>
                    <p>The main difference with the <a href="#redis-configuration-source">Redis configuration source</a> lies in the fact that it also provides a simple but effective versioning system which allows to set multiple properties and activate or revert them atomically. A global revision keeps track of the whole data store but it is also possible to version a particular branch in the tree of properties.</p>
                    <p>The following example shows how to set configuration properties for the <code>dev</code> and <code>prod</code> environment and activates them globally or independently:</p>
                    <pre><code class="language-java">RedisTransactionalClient&lt;String, String&gt; redisClient = ...
VersionedRedisConfigurationSource source = new VersionedRedisConfigurationSource(redisClient);

source
    .set("db.url", "jdbc:oracle:thin:@dev.db.server:1521:sid").withParameters("environment", "dev").and()
    .set("db.url", "jdbc:oracle:thin:@prod_eu.db.server:1521:sid").withParameters("environment", "prod", "zone", "eu").and()
    .set("db.url", "jdbc:oracle:thin:@prod_us.db.server:1521:sid").withParameters("environment", "prod", "zone", "us")
    .execute()
    .blockLast();
    
// Activate working revision globally
source.activate().block();

// Activate working revision for dev environment and prod environment independently
source.activate("environment", "dev").block();
source.activate("environment", "prod").block();
</code></pre>
                    <p>It is also possible to fallback to a particular revision by specifying it in the <code>activate()</code> method:</p>
                    <pre><code class="language-java">// Activate revision 2 globally
source.activate(2).block();
</code></pre>
                    <p>This implementation is particularly suitable to load tenant specific configuration in a multi-tenant application, or user preferences... basically any kind of configuration that can and will be dynamically changed at runtime and might require atomic activation or fallback.</p>
                    <blockquote>
                        <p>Parameterized properties and versioning per branch are two simple yet powerful features but it is important to be picky here otherwise there is a real risk of messing things up. You should thoughtfully decide when a configuration branch can be versioned, for instance the versioned sets of properties must be disjointed (if this is not obvious, think again), this is actually checked in the Redis configuration source and an exception will be thrown if you try to do things like this, basically trying to version the same property twice.</p>
                    </blockquote>
                    <p>This implementation is <a href="#defaultable-configuration-source">defaultable</a>.</p>
                    <h5 id="composite-configuration-source">Composite Configuration source</h5>
                    <p>The composite configuration source is a configuration source implementation that allows to compose multiple configuration sources into one configuration source.</p>
                    <p>The property returned for a configuration query key then depends on the order in which configuration sources were defined in the composite configuration source, from the highest priority to the lowest.</p>
                    <p>The <code>CompositeConfigurationSource</code> resolves a configuration property by querying its sources in sequence from the highest priority to the lowest. It relies on a <code>CompositeConfigurationStrategy</code> to determine at each round which queries to execute and retain the best matching property from the results. The best matching property is the property whose key is the closest to the original configuration query key according to a <code>DefaultingStrategy</code>. The algorithm stops when an exact match is found or when there's no more configuration source to query.</p>
                    <p>A common defaulting strategy provided by the <code>CompositeConfigurationStrategy</code> is applied to all sources before executing a batch of queries, this allows to remain consistent and use a common defaulting strategy as well as optimizing the queries to execute on each source by keeping track of intermediate results.</p>
                    <p>For a composite configuration source using a <code>CompositeConfigurationStrategy#lookup()</code> strategy, which is the default, the best matching property for a given original query is determined by prioritizing query parameters from left to right as defined by the <a href="#lookup-defaulting-strategy">lookup defaulting strategy</a>. As a result, an original query with <code>n</code> parameters results in <code>n+1</code> queries being executed on a source if no property was retained in previous rounds and <code>n-p</code> queries if a property with <code>p</code> parameters (<code>p&lt;n</code>) was retained in previous rounds. Please remember that when using the lookup defaulting strategy the order into which parameters are specified in the original query is significant: <code>property[p1=v1,p2=v2]</code> is not the same as <code>property[p2=v2,p1=v1]</code>.</p>
                    <p>Let's consider two parameterized configuration sources: <code>source1</code> and <code>source2</code>.</p>
                    <p><code>source1</code> holds the following properties:</p>
                    <ul>
                        <li><code>server.url[]=null</code></li>
                        <li><code>server.url[zone="US", environment="production"]="https://prod.us"</code></li>
                        <li><code>server.url[zone="EU"]="https://default.eu"</code></li>
                    </ul>
                    <p><code>source2</code> holds the following properties:</p>
                    <ul>
                        <li><code>server.url[]="https://default"</code></li>
                        <li><code>server.url[environment="test"]="https://test"</code></li>
                        <li><code>server.url[environment="production"]="https://prod"</code></li>
                    </ul>
                    <p>We can compose them in a composite configuration source as follows:</p>
                    <pre><code class="language-java">ConfigurationSource&lt;?, ?, ?&gt; source1 = ...
ConfigurationSource&lt;?, ?, ?&gt; source2 = ...

CompositeConfigurationSource source = new CompositeConfigurationSource(List.of(source1, source2));

source
    .get("server.url").withParameters("zone", "US", "environment", "production")       // 1
    .and().get("server.url").withParameters("environment", "test")                     // 2
    .and().get("server.url")                                                           // 3
    .and().get("server.url").withParameters("zone", "EU", "environment", "production") // 4
    .and().get("server.url").withParameters("environment", "production", "zone", "EU") // 5
    .subscribe(result -&gt; ...);
</code></pre>
                    <p>In the example above:</p>
                    <ol>
                        <li><code>server.url[environment="production",zone="US"]</code> is exactly defined in <code>source1</code> =&gt; <code>https://prod.us</code> defined in <code>source1</code> is returned</li>
                        <li><code>server.url[environment="test"]</code> is not defined in <code>source1</code> but exactly defined in <code>source2</code> =&gt; <code>https://test</code> defined in <code>source2</code> is returned</li>
                        <li>Although <code>server.url[]</code> is defined in both <code>source1</code> and <code>source2</code>, <code>source1</code> has the highest priority and therefore =&gt; <code>null</code> is returned</li>
                        <li>There is no exact match for <code>server.url[zone="EU", environment="production"]</code> in both <code>source1</code> and <code>source2</code>, the priority is given to the parameters from left to right, the property matching <code>server.url[zone="EU"]</code> shall be returned =&gt; <code>https://default.eu</code> defined in <code>source1</code> is returned</li>
                        <li>Here we've simply changed the order of the parameters in the previous query, again the priority is given to parameters from left to right, since there is no match for <code>server.url[environment="production", zone="EU"]</code>, <code>server.url[environment="production"]</code> is considered =&gt; <code>https://prod</code> defined in <code>source2</code> is returned</li>
                    </ol>
                    <p>When considering multiple configuration sources, properties can be defined with the exact same key in two different sources, the source with the highest priority wins. In the last example we've been able to set the value of <code>server.url[]</code> to <code>null</code> in <code>source1</code>, however <code>null</code> is itself a value with a different meaning than a missing property, the <code>unset</code> value can be used in such situation to <em>unset</em> a property defined in a source with a lower priority.</p>
                    <p>For instance, considering previous example, we could have defined <code>server.url[]=unset</code> instead of <code>server.url[]=null</code> in <code>source1</code>, the query would then have returned an empty query result indicating an undefined property.</p>
                    <p>Prioritization and defaulting also apply when listing configuration properties on a composite configuration source. In case of conflict between two configuration sources, the default strategy retains the one defined by the source with the highest priority.</p>
                    <p>For instance, if we consider the following sources: <code>source1</code> and <code>source2</code>.</p>
                    <p><code>source1</code> holds the following properties:</p>
                    <ul>
                        <li><code>logging.level[environment="dev"]=info</code></li>
                        <li><code>logging.level[environment="dev",name="test1"]=info</code></li>
                        <li><code>logging.level[environment="prod",name="test1"]=info</code></li>
                        <li><code>logging.level[environment="prod",name="test4"]=error</code></li>
                        <li><code>logging.level[environment="prod",name="test5"]=info</code></li>
                        <li><code>logging.level[environment="prod",name="test1",node="node-1"]=trace</code></li>
                    </ul>
                    <p><code>source2</code> holds the following properties:</p>
                    <ul>
                        <li><code>logging.level[environment="dev",node="node-1"]=info</code></li>
                        <li><code>logging.level[environment="dev",name="test1"]=debug</code></li>
                        <li><code>logging.level[environment="dev",name="test2"]=debug</code></li>
                        <li><code>logging.level[environment="dev",name="test2",node="node-1"]=debug</code></li>
                        <li><code>logging.level[environment="prod",name="test1"]=warn</code></li>
                        <li><code>logging.level[environment="prod",name="test2"]=error</code></li>
                        <li><code>logging.level[environment="prod",name="test3"]=info</code></li>
                    </ul>
                    <p>If we can compose them in a composite configuration source, we can list configuration properties as follows:</p>
                    <pre><code class="language-java">ConfigurationSource&lt;?, ?, ?&gt; source1 = ...
ConfigurationSource&lt;?, ?, ?&gt; source2 = ...

CompositeConfigurationSource source = new CompositeConfigurationSource(List.of(source1, source2));

source                                       // 1
    .list("logging.level")
    .withParameters(
        Parameter.of("environment", "prod"), 
        Parameter.wildcard("name")
    )
    .execute()
    .subscribe(result -&gt; ...);

source                                       // 2
    .list("logging.level")
    .withParameters(
        Parameter.of("environment", "dev"), 
        Parameter.wildcard("name")
    )
    .executeAll()
    .subscribe(result -&gt; ...);
</code></pre>
                    <p>In the example above:</p>
                    <ol>
                        <li><code>execute()</code> is exact and returns properties defined with parameters <code>environment</code> and <code>name</code>, with parameter <code>environment</code> only and with no parameter following defaulting rules implemented in the default strategy. As a result the following properties are returned: 
                            <ul>
                              <li><code>logging.level[environment="prod",name="test1"]=info</code> defined in <code>source1</code> and overriding the property defined in <code>source2</code></li>
                              <li><code>logging.level[environment="prod",name="test2"]=error</code> defined in <code>source2</code></li>
                              <li><code>logging.level[environment="prod",name="test3"]=info</code> defined in <code>source2</code></li>
                              <li><code>logging.level[environment="prod",name="test4"]=error</code> defined in <code>source1</code></li>
                              <li><code>logging.level[environment="prod",name="test5"]=info</code> defined in <code>source1</code></li>
                            </ul></li>
                        <li><code>executeAll()</code> returns all properties defined with parameters <code>environment</code>, <code>name</code> and any other parameter, with parameter <code>environment</code> only and with no parameter following defaulting rules implemented in the default strategy. As a result the following properties are returned: 
                            <ul>
                              <li><code>logging.level[environment="dev"]=info</code> defined in <code>source1</code> which is the property that would be returned when querying the source with an unspecified name (eg. <code>logging.level[environment="dev",name="unspecifiedLogger"]</code>)</li>
                              <li><code>logging.level[environment="dev",name="test1"]=info</code> defined in <code>source1</code> and overriding the property defined in <code>source2</code></li>
                              <li><code>logging.level[environment="dev",name="test2"]=debug</code> defined in <code>source2</code></li>
                              <li><code>logging.level[environment="dev",name="test2",node="node-1"]=debug</code> defined in <code>source2</code></li>
                            </ul></li>
                    </ol>
                    <blockquote>
                        <p>it is important to note that list operations, especially on a very large set of data can become quite expensive and impact performances, as a result they must be used wisely.</p>
                    </blockquote>
                    <h5 id="bootstrap-configuration-source">Bootstrap configuration source</h5>
                    <p>The bootstrap configuration source is a <a href="#composite-configuration-source">composite configuration source</a> preset with configuration sources typically used when bootstrapping an application.</p>
                    <p>This implementation resolves configuration properties from the following sources in that order, from the highest priority to the lowest:</p>
                    <ul>
                        <li>command line</li>
                        <li>system properties</li>
                        <li>system environment variables</li>
                        <li>the <code>configuration.cprops</code> file in <code>./conf/</code> or <code>${inverno.conf.path}/</code> directories if one exists (if the first one exists the second one is ignored)</li>
                        <li>the <code>configuration.cprops</code> file in <code>/home/jkuhn/Devel/git/winter/inverno-apps/inverno-utilities/target/maven-inverno/application_linux_amd64/inverno-utilities-1.2.0-SNAPSHOT/lib/runtime/conf/</code> directory if it exists</li>
                        <li>the <code>configuration.cprops</code> file in the application module if it exists</li>
                    </ul>
                    <p>This source is typically created in a <code>main</code> method to load the bootstrap configuration on startup.</p>
                    <pre><code class="language-java">public class Application {

    public static void main(String[] args) {
        BootstrapConfigurationSource source = new BootstrapConfigurationSource(Application.class.getModule(), args);
        
        // Load configuration
        ApplicationConfiguration configuration = ConfigurationLoader
            .withConfiguration(ApplicationConfiguration.class)
            .withSource(source)
            .load()
            .block();

        // Start the application with the configuration
        ...
    }
}
</code></pre>
                    <h4 id="configuration-loader">Configuration loader</h4>
                    <p>The API offers a great flexibility but as we've seen it might require some efforts to load a configuration in a usable explicit Java bean. Hopefully, this has been anticipated and the configuration module provides a configuration loader to smoothly load configuration objects in the application.</p>
                    <p>The <code>ConfigurationLoader</code> interface is the main entry point for loading configuration objects from a configuration source. It can be used in two different ways, either dynamically using Java reflection or statically using the Inverno compiler.</p>
                    <h5 id="dynamic-loader">Dynamic loader</h5>
                    <p>A dynamic loader can be created by invoking static method <code>ConfigurationLoader#withConfiguration()</code> which accepts a single <code>Class</code> argument specifying the type of the configuration that must be loaded.</p>
                    <p>A valid configuration type must be an interface defining configuration properties as non-void no-argument methods whose names correspond to the configuration properties to retrieve and to map to the resulting configuration object, default values can be specified in default methods.</p>
                    <p>For instance the following interface represents a valid configuration type which can be loaded by a configuration loader:</p>
                    <pre><code class="language-java">public interface AppConfiguration {

    // query property 'server_host'
    String server_host();

    // query property 'server_port'
    default int server_port() {
        return 8080;
    }
}
</code></pre>
                    <p>It can be loaded at runtime as follows:</p>
                    <pre><code class="language-java">ConfigurationSource&lt;?, ?, ?&gt; source = ...

ConfigurationLoader
    .withConfiguration(AppConfiguration.class)
    .withSource(source)
    .withParameters("environment", "production")
    .load()
    .map(configuration -&gt; startServer(configuration.server_host(), configuration.server_port()))
    .subscribe();
</code></pre>
                    <p>In the above example, the configuration source is queried for properties <code>server_host[environment="production"]</code> and <code>server_port[environment="production"]</code>.</p>
                    <p>The dynamic loader also supports nested configurations when the return type of a method is an interface representing a valid configuration type.</p>
                    <pre><code class="language-java">public interface ServerConfiguration {

    // query property 'server_host'
    String server_host();
    
    // query property 'server_port'
    default int server_port() {
        return 8080;
    }
}
</code></pre>
                    <pre><code class="language-java">public interface AppConfiguration {
    
    // Prefix child property names with 'server_configuration'
    ServerConfiguration server_configuration();
}
</code></pre>
                    <p>In the above example, the configuration source is queried for properties <code>server_configuration.server_host[environment="production"]</code> and <code>server_configuration.server_port[environment="production"]</code>.</p>
                    <p>It is also possible to load a configuration by invoking static method <code>ConfigurationLoader#withConfigurator()</code> which allows to load any type of configuration (not only interface) by relying on a configurator and a mapping function.</p>
                    <p>A configurator defines configuration properties as void single argument methods whose names correspond to the configuration properties to retrieve and inject into a configurator instance using a dynamic configurer <code>Consumer&lt;Configurator&gt;</code>. The mapping function is finally applied to that configurer to actually create the resulting configuration object.</p>
                    <p>For instance, previous example could have been implemented as follows:</p>
                    <pre><code class="language-java">public class AppConfiguration {
    
    private String server_host;
    private String server_port = 8080;
    
    // query property 'server_host'
    public void server_host(String server_host) {
        this.server_host = server_host;
    }
    
    // query property 'server_port'
    public void server_port(int server_port) {
        this.server_port = server_port;
    }
    
    public String server_host() {
        return server_host;
    }
    
    public int server_port() {
        return server_port;
    }
}
</code></pre>
                    <pre><code class="language-java">ConfigurationSource&lt;?, ?, ?&gt; source = ...

ConfigurationLoader
    .withConfigurator(AppConfiguration.class, configurer -&gt; {
        AppConfiguration configuration = new AppConfiguration();
        configurer.apply(configuration);
        return configuration;
    })
    .withSource(source)
    .withParameters("environment", "production")
    .load()
    .map(configuration -&gt; startServer(configuration.server_host(), configuration.server_port()))
    .subscribe();
</code></pre>
                    <h5 id="static-loader">Static loader</h5>
                    <p>Dynamic loading is fine but it relies on Java reflection which induces extra processing at runtime and might cause unexpected runtime errors due to the lack of static checking. This is all the more true as most of the time configuration definitions are known at compile time. For these reasons, it is better to create adhoc configuration loader implementations. Fortunately, the configuration Inverno compiler plugin can generate these for us.</p>
                    <p>In order to create a configuration bean in an Inverno module, we simply need to create an interface for our configuration as specified above and annotates it with <code>@Configuration</code>, this will tell the configuration Inverno compiler plugin to generate a corresponding configuration loader implementation as well as a module bean making our configuration directly available inside our module.</p>
                    <pre><code class="language-java">@Configuration
public interface AppConfiguration {

    // query property 'server_host'
    String server_host();

    // query property 'server_port'
    int server_port();
}
</code></pre>
                    <p>The preceding code will result in the generation of class <code>AppConfigurationLoader</code> which can then be used to load configuration at runtime without resorting to reflection.</p>
                    <pre><code class="language-java">ConfigurationSource&lt;?, ?, ?&gt; source = ...

new AppConfigurationLoader()
    .withSource(source)
    .withParameters("environment", "production")
    .load()
    .map(configuration -&gt; startServer(configuration.server_host(), configuration.server_port()))
    .subscribe();
</code></pre>
                    <p>A configuration can also be obtained <em>manually</em> as follows:</p>
                    <pre><code class="language-java">AppConfiguration defaultConfiguration = AppConfigurationLoader.load(configurator -&gt; configurator.server_host("0.0.0.0"));

AppConfiguration customConfiguration = AppConfigurationLoader.load(configurator -&gt; configurator.server_host("0.0.0.0"));
</code></pre>
                    <p>By default, the generated loader also defines an overridable module bean which loads the configuration in the module. This bean defines three optional sockets:</p>
                    <ul>
                        <li><strong>configurationSource</strong> indicates the configuration source to query when initializing the configuration bean</li>
                        <li><strong>parameters</strong> indicates the parameters to consider when querying the source</li>
                        <li><strong>configurer</strong> provides a way to overrides default values</li>
                    </ul>
                    <p>If no configuration source is present, a default configuration is created, otherwise the configuration source is queried with the parameters, the resulting configuration is then <em>patched</em> with the configurer if present. The bean is overridable by default which means we can inject our own implementation if we feel like it.</p>
                    <p>It is possible to disable the activation of the configuration bean or make it non overridable in the <code>@Configuration</code> interface:</p>
                    <pre><code class="language-java">@Configuration(generateBean = false, overridable = false)
public interface AppConfiguration {
    ...
}
</code></pre>
                    <p>Finally, nested beans can be specified in a configuration which is convenient when a module is composing multiple modules and we wish to aggregate all configurations into one single representation in the composite module.</p>
                    <p>For instance, we can have the following configuration defined in a component module:</p>
                    <pre><code class="language-java">@Configuration
public interface ComponentModuleConfiguration {
    ...
}
</code></pre>
                    <p>and the following configuration defined in the composite module:</p>
                    <pre><code class="language-java">@Configuration
public interface CompositeModuleConfiguration {

    @NestedBean
    ComponentModuleConfiguration component_module_configuration();
}
</code></pre>
                    <p>In the preceding example, we basically indicate to the Inverno framework that the <code>ComponentModuleConfiguration</code> defined in the <code>CompositeModuleConfiguration</code> must be injected into the component module instance.</p>
                    <h3 id="http-base">HTTP Base</h3>
                    <p>The Inverno <em>http-base</em> module defines the foundational API for creating HTTP clients and servers. It also provides common HTTP services such as the header service.</p>
                    <p>In order to use the Inverno <em>http-base</em> module, we need to declare a dependency in the module descriptor:</p>
                    <pre><code class="language-java">module io.inverno.example.app {
    requires io.inverno.mod.http.base;
    ...
}
</code></pre>
                    <p>And also declare that dependency in the build descriptor:</p>
                    <p>Using Maven:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-http-base&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <p>Using Gradle:</p>
                    <pre><code class="language-java">...
compile 'io.inverno.mod:inverno-http-base:1.5.2'
...
</code></pre>
                    <p>The <em>http-base</em> module is usually provided as a transitive dependency by other HTTP modules, the <em>http-server</em> module or the <em>web</em> module in particular, so this might not be necessary.</p>
                    <h4 id="http-base-api">HTTP base API</h4>
                    <p>The base HTTP API defines common classes and interfaces for implementing applications or modules using HTTP/1.x or HTTP/2 protocols. This includes:</p>
                    <ul>
                        <li>HTTP methods and status enumerations</li>
                        <li>Exception bindings for HTTP errors: <code>BadRequestException</code>, <code>InternalServerErrorException</code>...</li>
                        <li>basic building blocks such as <code>Parameter</code> which defines the base interface for any HTTP component that can be represented as a key/value pair (eg. query parameter, header, cookie...)</li>
                        <li>Cookie types: <code>Cookie</code> and <code>SetCookie</code></li>
                        <li>Common HTTP header names (<code>Headers.NAME_*</code>) and values (<code>Headers.VALUE_*</code>) constants</li>
                        <li>Common HTTP header types: <code>Headers.ContentType</code>, <code>Headers.Accept</code>...</li>
                        <li>HTTP header codec API for implementing HTTP header codec used to decode a raw HTTP header in a specific <code>Header</code> object</li>
                        <li>A HTTP header service used to encode/decode HTTP headers from/to specific <code>Header</code> objects</li>
                    </ul>
                    <h4 id="http-header-service">HTTP header service</h4>
                    <p>The HTTP header service is the main entry point for decoding and encoding HTTP headers.</p>
                    <p>The <code>HeaderService</code> interface defines method to decode/encode <code>Header</code> object from/to <code>String</code> or <code>ByteBuf</code>.</p>
                    <p>For instance, a <code>content-type</code> header can be parsed as follows:</p>
                    <pre><code class="language-java">HeaderService headerService = ...

Headers.ContentType contentType = headerService.&lt;Headers.ContentType&gt;decode("content-type", "application/xml;charset=utf-8");

// application/xml
String mediaType = contentType.getMediaType();
// utf-8
Charset charset = contentType.getCharset();

</code></pre>
                    <p>The <em>http-base</em> module provides a default implementation exposed as a bean which relies on a set of <code>HeaderCodec</code> objects to support specific headers. Custom header codecs can then be injected in the module to extend its capabilities.</p>
                    <p>For instance, we can create an <code>ApplicationContextHeaderCodec</code> codec in order for the header service to decode custom <code>application-context</code> headers to <code>ApplicationContextHeader</code> instances. The codec must be injected in the <em>http-base</em> module either explicitly when creating the module or through dependency injection.</p>
                    <pre><code class="language-java">Base httpBase = new Base.Builder()
    .setHeaderCodecs(List.of(new ApplicationContextHeaderCodec())
    .build();

httpBase.start();

ApplicationContextHeaderCodec decodedHeader = httpBase.headerService().&lt;ApplicationContextHeaderCodec&gt;.decode("...")
...

httpBase.stop();
</code></pre>
                    <p>Most of the time the <em>http-base</em> module is composed in a composite module and as a result dependency injection should work just fine, so we simply need to declare the codec as a bean in the module composing the <em>http-base</em> module to extend the header service.</p>
                    <p>By default, the <em>http-base</em> module provides codecs for the following headers:</p>
                    <ul>
                        <li><code>accept</code> as defined by <a href="https://tools.ietf.org/html/rfc7231#section-5.3.2">RFC 7231 Section 5.3.2</a></li>
                        <li><code>accept-language</code> as defined by <a href="https://tools.ietf.org/html/rfc7231#section-5.3.5">RFC 7231 Section 5.3.5</a></li>
                        <li><code>authorization</code> as defined by <a href="https://datatracker.ietf.org/doc/html/rfc7235#section-4.2">RFC 7235 Section 4.2</a></li>
                        <li><code>content-disposition</code> as defined by <a href="https://tools.ietf.org/html/rfc6266">RFC 6266</a></li>
                        <li><code>content-type</code> as defined by <a href="https://tools.ietf.org/html/rfc7231#section-5.1.1.5">RFC 7231 Section 3.1.1.5</a></li>
                        <li><code>cookie</code> as defined by <a href="https://tools.ietf.org/html/rfc6265#section-4.2">RFC 6265 Section 4.2</a></li>
                        <li><code>set-cookie</code> as defined by <a href="https://tools.ietf.org/html/rfc6265#section-4.1">RFC 6265 Section 4.1</a></li>
                    </ul>
                    <h3 id="http-server">HTTP Server</h3>
                    <p>The Inverno <em>http-server</em> module provides fully reactive HTTP/1.x and HTTP/2 server based on <a href="https://netty.io/">Netty</a>.</p>
                    <p>It especially supports:</p>
                    <ul>
                        <li>HTTP/1.x pipelining</li>
                        <li>HTTP/2 over cleartext</li>
                        <li>WebSocket</li>
                        <li>HTTP Compression</li>
                        <li>TLS</li>
                        <li>Interceptors</li>
                        <li>Strongly typed contexts</li>
                        <li><code>application/x-www-form-urlencoded</code> body decoding</li>
                        <li><code>multipart/form-data</code> body decoding</li>
                        <li>Server-sent events</li>
                        <li>Cookies</li>
                        <li>zero-copy file transfer when supported for fast resource transfer</li>
                        <li>parameter conversion</li>
                    </ul>
                    <p>The server is fully reactive, based on the reactor pattern and non-blocking sockets which means it requires a limited number of threads to supports thousands of connections with high end performances. This design offers multiple advantages starting with maximizing the usage of resources. It is also easy to scale the server up and down by specifying the number of threads we want to allocate to the server, which ideally corresponds to the number of CPU cores. All this makes it a perfect choice for microservices applications running in containers in the cloud.</p>
                    <blockquote>
                        <p>This module lays the foundational service and API for building HTTP servers with more complex and advanced features, that is why you might sometimes find it a little bit low level but that is the price of performance. If you require higher level functionalities like request routing, content negotiation and automatic payload conversion please consider the <a href="#web">web module</a>.</p>
                    </blockquote>
                    <p>This module requires basic services like a <a href="#net-service">net service</a> and a <a href="#resource-service">resource service</a> which are usually provided by the <em>boot</em> module, so in order to use the Inverno <em>http-server</em> module, we should declare the following dependencies in the module descriptor:</p>
                    <pre><code class="language-java">@io.inverno.core.annotation.Module
module io.inverno.example.app_http {
    requires io.inverno.mod.boot;
    requires io.inverno.mod.http.server;
}
</code></pre>
                    <p>The <em>http-base</em> module which provides the header service used by the HTTP server is composed as a transitive dependency in the <em>http-server</em> module and as a result it doesn't need to be specified here nor provided in an enclosing module.</p>
                    <p>We also need to declare these dependencies in the build descriptor:</p>
                    <p>Using Maven:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-boot&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-http-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <p>Using Gradle:</p>
                    <pre><code class="language-java">...
compile 'io.inverno.mod:inverno-boot:1.5.2'
compile 'io.inverno.mod:inverno-http-server:1.5.2'
...
</code></pre>
                    <p>The resulting <em>app_http</em> module, thus created, can then be started as an application as follows:</p>
                    <pre><code class="language-java">package io.inverno.example.app_http;

import io.inverno.core.v1.Application;

public class Main {

    public static void main(String[] args) {
        Application.with(new App_http.Builder()).run();
    }
}
</code></pre>
                    <p>The above example starts a HTTP/1.x server using default configuration and a default server controller.</p>
                    <pre><code class="language-plaintext">2021-04-14 09:51:46,329 INFO  [main] i.w.c.v.Application - Inverno is starting...


     ╔════════════════════════════════════════════════════════════════════════════════════════════╗
     ║                      , ~~ ,                                                                ║
     ║                  , '   /\   ' ,                                                            ║
     ║                 , __   \/   __ ,      _                                                    ║
     ║                ,  \_\_\/\/_/_/  ,    | |  ___  _    _  ___   __  ___   ___                 ║
     ║                ,    _\_\/_/_    ,    | | / _ \\ \  / // _ \ / _|/ _ \ / _ \                ║
     ║                ,   __\_/\_\__   ,    | || | | |\ \/ /|  __/| | | | | | |_| |               ║
     ║                 , /_/ /\/\ \_\ ,     |_||_| |_| \__/  \___||_| |_| |_|\___/                ║
     ║                  ,     /\     ,                                                            ║
     ║                    ,   \/   ,                                  -- 1.5.1 --                 ║
     ║                      ' -- '                                                                ║
     ╠════════════════════════════════════════════════════════════════════════════════════════════╣
     ║ Java runtime        : OpenJDK Runtime Environment                                          ║
     ║ Java version        : 16+36-2231                                                           ║
     ║ Java home           : /home/jkuhn/Devel/jdk/jdk-16                                         ║
     ║                                                                                            ║
     ║ Application module  : io.inverno.example.app_http                                          ║
     ║ Application version : 1.0.0-SNAPSHOT                                                       ║
     ║ Application class   : io.inverno.example.app_http.Main                                     ║
     ║                                                                                            ║
     ║ Modules             :                                                                      ║
     ║  ....                                                                                      ║
     ╚════════════════════════════════════════════════════════════════════════════════════════════╝


2021-04-14 09:53:21,829 INFO  [main] i.w.e.a.App_http - Starting Module io.inverno.example.app_http...
2021-04-14 09:53:21,829 INFO  [main] i.w.m.b.Boot - Starting Module io.inverno.mod.boot...
2021-04-14 09:53:22,025 INFO  [main] i.w.m.b.Boot - Module io.inverno.mod.boot started in 195ms
2021-04-14 09:53:22,025 INFO  [main] i.w.m.h.s.Server - Starting Module io.inverno.mod.http.server...
2021-04-14 09:53:22,025 INFO  [main] i.w.m.h.b.Base - Starting Module io.inverno.mod.http.base...
2021-04-14 09:53:22,029 INFO  [main] i.w.m.h.b.Base - Module io.inverno.mod.http.base started in 3ms
2021-04-14 09:53:22,080 INFO  [main] i.w.m.h.s.i.HttpServer - HTTP Server (nio) listening on http://0.0.0.0:8080
2021-04-14 09:53:22,080 INFO  [main] i.w.m.h.s.Server - Module io.inverno.mod.http.server started in 55ms
2021-04-14 09:53:22,080 INFO  [main] i.w.e.a.App_http - Module io.inverno.example.app_http started in 252ms
</code></pre>
                    <p>You should be able to send a request to the server:</p>
                    <pre><code class="language-plaintext">$ curl -i http://localhost:8080/
HTTP/1.1 200
content-length: 5

Hello
</code></pre>
                    <p>The HTTP server uses a <strong>server controller</strong> to handle client request. The module provides a default implementation as overridable bean, a custom server controller can then be injected when creating the <em>http-server</em> module.</p>
                    <blockquote>
                        <p>this module can also be used to embed a HTTP server in any application, unlike other application frameworks, Inverno core IoC/DI framework is not pervasive and any Inverno modules can be safely used in various contexts and applications.</p>
                    </blockquote>
                    <h4 id="configuration-2">Configuration</h4>
                    <p>The first thing we might want to do is to create a configuration in the <em>app_http</em> module for easy <em>http-server</em> module setup. The HTTP server configuration is actually done in the <code>BootConfiguration</code> defined in the <em>boot</em> module for low level network configuration and <code>HttpServerConfiguration</code> in the <em>http-server</em> module configuration for the HTTP server itself.</p>
                    <p>The following configuration can then be created in the <em>app_http</em> module:</p>
                    <pre><code class="language-java">package io.inverno.example.app_http;

import io.inverno.core.annotation.NestedBean;
import io.inverno.mod.boot.BootConfiguration;
import io.inverno.mod.configuration.Configuration;
import io.inverno.mod.http.server.HttpServerConfiguration;

@Configuration
public interface App_httpConfiguration {

    @NestedBean
    BootConfiguration boot();

    @NestedBean
    HttpServerConfiguration http_server();
}
</code></pre>
                    <p>This should be enough for exposing a configuration in the <em>app_http</em> module that let us setup the server:</p>
                    <pre><code class="language-java">package io.inverno.example.app_http;

import io.inverno.core.v1.Application;

public class Main {

    public static void main(String[] args) {
        Application.with(new App_http.Builder()
            .setApp_httpConfiguration(
                App_httpConfigurationLoader.load(configuration -&gt; configuration
                    .http_server(server -&gt; server
                        .server_port(8081)
                        .h2c_enabled(true)
                    )
                    .boot(boot -&gt; boot
                        .reactor_event_loop_group_size(4)
                    )
                )
            )
        ).run();
    }
}
</code></pre>
                    <p>In the above code, we have set the server port to 8081, enabled HTTP/2 over cleartext and set the number of thread allocated to the reactor core IO event loop group to 4.</p>
                    <p>Please refer to the <a href="https://inverno.io/docs/release/api/index.html">API documentation</a> to have an exhaustive description of the different configuration properties. We can for instance configure low level network settings like TCP keep alive or TCP no delay as well as HTTP related settings like compression or TLS.</p>
                    <blockquote>
                        <p>You can also refer to the <a href="#configuration-1">configuration module documentation</a> to get more details on how configuration works and more especially how you can from here define the HTTP server configuration in command line arguments, property files...</p>
                    </blockquote>
                    <h5 id="logging">Logging</h5>
                    <p>The HTTP server can log access and error events at <code>INFO</code> and <code>ERROR</code> level respectively. They can be disabled by configuring <code>io.inverno.mod.http.server.Exchange</code> logger as follows:</p>
                    <pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;Configuration xmlns="http://logging.apache.org/log4j/2.0/config"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://logging.apache.org/log4j/2.0/config https://raw.githubusercontent.com/apache/logging-log4j2/rel/2.14.0/log4j-core/src/main/resources/Log4j-config.xsd" 
    status="WARN" shutdownHook="disable"&gt;

    &lt;Appenders&gt;
        &lt;Console name="LogToConsole" target="SYSTEM_OUT"&gt;
            &lt;PatternLayout pattern="%d{DEFAULT} %highlight{%-5level} [%t] %c{1.} - %msg%n%ex"/&gt;
        &lt;/Console&gt;
    &lt;/Appenders&gt;
    &lt;Loggers&gt;
        &lt;!-- Disable HTTP server access and error logs --&gt;
        &lt;Logger name="io.inverno.mod.http.server.Exchange" additivity="false" level="off"  /&gt;

        &lt;Root level="info"&gt;
            &lt;AppenderRef ref="LogToConsole"/&gt;
        &lt;/Root&gt;
    &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
                    <p>We can also create a more <em>production-like</em> logging configuration for a standard HTTP server that asynchronously logs access and error events in separate files in a JSON format for easy integration with log processing tools with a rolling strategy.</p>
                    <pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;Configuration status="WARN" name="Website" shutdownHook="disable"&gt;
    &lt;Appenders&gt;
        &lt;Console name="Console" target="SYSTEM_OUT"&gt;
             &lt;PatternLayout pattern="%d{DEFAULT} %highlight{%-5level} [%t] %c{1.} - %msg%n%ex"/&gt;
        &lt;/Console&gt;
        &lt;!-- Error log --&gt;
        &lt;RollingRandomAccessFile name="ErrorRollingFile" fileName="logs/error.log" filePattern="logs/error-%d{yyyy-MM-dd}-%i.log.gz"&gt;
            &lt;JsonTemplateLayout/&gt;
            &lt;NoMarkerFilter onMatch="ACCEPT" onMismatch="DENY"/&gt;
            &lt;Policies&gt;
                &lt;TimeBasedTriggeringPolicy /&gt;
                &lt;SizeBasedTriggeringPolicy size="10 MB"/&gt;
            &lt;/Policies&gt;
            &lt;DefaultRolloverStrategy&gt;
                &lt;Delete basePath="logs" maxDepth="2"&gt;
                    &lt;IfFileName glob="error-*.log.gz" /&gt;
                    &lt;IfLastModified age="10d" /&gt;
                &lt;/Delete&gt;
            &lt;/DefaultRolloverStrategy&gt;
        &lt;/RollingRandomAccessFile&gt;
        &lt;Async name="AsyncErrorRollingFile"&gt;
            &lt;AppenderRef ref="ErrorRollingFile"/&gt;
        &lt;/Async&gt;
        &lt;!-- Access log --&gt;
        &lt;RollingRandomAccessFile name="AccessRollingFile" fileName="logs/access.log" filePattern="logs/access-%d{yyyy-MM-dd}-%i.log.gz"&gt;
            &lt;JsonTemplateLayout/&gt;
            &lt;MarkerFilter marker="HTTP_ACCESS" onMatch="ACCEPT" onMismatch="DENY"/&gt;
            &lt;Policies&gt;
                &lt;TimeBasedTriggeringPolicy /&gt;
                &lt;SizeBasedTriggeringPolicy size="10 MB"/&gt;
            &lt;/Policies&gt;
            &lt;DefaultRolloverStrategy&gt;
                &lt;Delete basePath="logs" maxDepth="2"&gt;
                    &lt;IfFileName glob="access-*.log.gz" /&gt;
                    &lt;IfLastModified age="10d" /&gt;
                &lt;/Delete&gt;
            &lt;/DefaultRolloverStrategy&gt;
        &lt;/RollingRandomAccessFile&gt;
        &lt;Async name="AsyncAccessRollingFile"&gt;
            &lt;AppenderRef ref="AccessRollingFile"/&gt;
        &lt;/Async&gt;
    &lt;/Appenders&gt;

    &lt;Loggers&gt;
        &lt;Logger name="io.inverno.mod.http.server.Exchange" additivity="false" level="info"&gt;
            &lt;AppenderRef ref="AsyncAccessRollingFile" level="info"/&gt;
            &lt;AppenderRef ref="AsyncErrorRollingFile" level="error"/&gt;
        &lt;/Logger&gt;

        &lt;Root level="info" additivity="false"&gt;
            &lt;AppenderRef ref="Console" level="info" /&gt;
            &lt;AppenderRef ref="AsyncErrorRollingFile" level="error"/&gt;
        &lt;/Root&gt;
    &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre>
                    <blockquote>
                        <p>Note that access and error events are logged by the same logger, they are differentiated by markers, <code>HTTP_ACCESS</code> and <code>HTTP_ERROR</code> respectively.</p>
                    </blockquote>
                    <h5 id="transport">Transport</h5>
                    <p>By default, the HTTP server uses the Java NIO transport, but it is possible to use native <a href="https://en.wikipedia.org/wiki/Epoll">epoll</a> transport on Linux or <a href="https://en.wikipedia.org/wiki/Kqueue">kqueue</a> transport on BSD-like systems for optimized performances. This can be done by adding the corresponding Netty dependencies with the right classifier in the project descriptor:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.netty&lt;/groupId&gt;
            &lt;artifactId&gt;netty-transport-classes-epoll&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.netty&lt;/groupId&gt;
            &lt;artifactId&gt;netty-transport-native-epoll&lt;/artifactId&gt;
            &lt;classifier&gt;linux-x86_64&lt;/classifier&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <p>or</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.netty&lt;/groupId&gt;
            &lt;artifactId&gt;netty-transport-classes-kqueue&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.netty&lt;/groupId&gt;
            &lt;artifactId&gt;netty-transport-native-kqueue&lt;/artifactId&gt;
            &lt;classifier&gt;osx-x86_64&lt;/classifier&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <blockquote>
                        <p>When these dependencies are declared on the JVM module path, the corresponding Java modules must be added explicitly when running the application. This is typically the case when the application is run or packaged as an application image using the Inverno Maven plugin.</p>
                        <p>This can be done by defining the corresponding dependencies in the module descriptor:</p>
                        <pre><code class="language-java">@io.inverno.core.annotation.Module
module io.inverno.example.app {
    ...
    requires io.netty.transport.unix.common;
    requires io.netty.transport.classes.epoll,
    requires io.netty.transport.epoll.linux.x86_64;
}
</code></pre>
                        <p>This approach is fine as long as we are sure the application will run on Linux, but in order to create a properly portable application, we should prefer adding the modules explicitly when running the application:</p>
                        <pre><code class="language-plaintext">$ java --add-modules io.netty.transport.unix.common,io.netty.transport.classes.epoll,io.netty.transport.epoll.linux.x86_64 ...
</code></pre>
                        <p>When building an application image, this can be specified in the Inverno Maven plugin configuration:</p>
                        <pre><code class="language-xml">&lt;project&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;io.inverno.tool&lt;/groupId&gt;
                &lt;artifactId&gt;inverno-maven-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;configuration&gt;
                            &lt;vmOptions&gt;--add-modules io.netty.transport.unix.common,io.netty.transport.classes.epoll,io.netty.transport.epoll.linux.x86_64&lt;/vmOptions&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
                    </blockquote>
                    <h5 id="http-compression">HTTP compression</h5>
                    <p>HTTP compression can be activated by configuration for request and/or response. For instance:</p>
                    <pre><code class="language-java">public class Main {

    public static void main(String[] args) {
        Application.with(new App_http.Builder()
            .setApp_httpConfiguration(
                App_httpConfigurationLoader.load(configuration -&gt; configuration
                    .http_server(server -&gt; server
                        .decompression_enabled(true)
                        .compression_enabled(true)
                        .compression_level(6)
                    )
                )
            )
        ).run();
    }
}
</code></pre>
                    <p>Now if we send a request which accepts compression to the server, we should now receive a compressed response:</p>
                    <pre><code class="language-plaintext">$ curl -i --compressed -H 'accept-encoding: gzip, deflate' http://localhost:8080
HTTP/1.1 200 OK
content-type: text/plain
server: inverno
content-encoding: gzip
content-length: 39

Hello
</code></pre>
                    <h5 id="tls">TLS</h5>
                    <p>In order to activate TLS, we need first to obtain a private key and a certificate stored in a keystore.</p>
                    <p>A self-signed certificate can be generated using <code>keytool</code>, the resulting keystore should be placed in <code>src/main/resources</code> to make it available as a module resource:</p>
                    <pre><code class="language-plaintext">$ keytool -genkey -keyalg RSA -alias selfsigned -keystore keystore.jks -storepass password -validity 360 -keysize 2048
</code></pre>
                    <p>Then we need to configure the server to activate TLS using the certificate:</p>
                    <pre><code class="language-java">public class Main {

    public static void main(String[] args) {
        Application.with(new App_http.Builder()
            .setApp_httpConfiguration(
                App_httpConfigurationLoader.load(configuration -&gt; configuration
                    .http_server(server -&gt; server
                        .server_port(8443)
                        .tls_enabled(true)
                        .key_store(URI.create("module://io.inverno.example.app_http/keystore.jks"))
                        .key_alias("selfsigned")
                        .key_store_password("password")
                    )
                )
            )
        ).run();
    }
}
</code></pre>
                    <blockquote>
                        <p>When an application using the <em>http-server</em> module is packaged as an application image, you'll need to make sure TLS related modules from the JDK are included in the runtime image otherwise TLS might not work. You can refer to the <a href="https://docs.oracle.com/en/java/javase/11/security/oracle-providers.html">JDK providers documentation</a> in the security developer's guide to find out which modules should be added depending on your needs. Most of the time you'll simply add <code>jdk.crypto.ec</code> module in the Inverno Maven plugin configuration:</p>
                        <pre><code class="language-xml">&lt;project&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;io.inverno.tool&lt;/groupId&gt;
                &lt;artifactId&gt;inverno-maven-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;configuration&gt;
                            &lt;addModules&gt;jdk.crypto.ec&lt;/addModules&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
                    </blockquote>
                    <h4 id="server-controller">Server Controller</h4>
                    <p>The server controller specifies how exchanges and errors are handled by the server. It also provides the exchange context created and attached to the exchange by the server.</p>
                    <p>The <code>ServerController</code> interface bascially defines the following methods:</p>
                    <ul>
                        <li><code>Mono&lt;Void&gt; defer(Exchange&lt;ExchangeContext&gt; exchange)</code> which is used to handle an exchange</li>
                        <li><code>Mono&lt;Void&gt; defer(ErrorExchange&lt;ExchangeContext&gt; errorExchange)</code> which is used to handle an error exchange</li>
                        <li><code>ExchangeContext createContext()</code> which provides the context attached to an exchange</li>
                    </ul>
                    <blockquote>
                        <p>Methods <code>void handle(Exchange&lt;ExchangeContext&gt; exchange)</code> and <code>void handle(ErrorExchange&lt;ExchangeContext&gt; errorExchange)</code> are also defined, they can be more convenient when the handling logic does not have to be reactive. Note that the server will always invoke <code>defer()</code> methods which must then be properly implemented.</p>
                    </blockquote>
                    <p>As stated before, the <em>http-server</em> module provides a default <code>ServerController</code> implementation which returns <code>Hello</code> when a request is made to the root path <code>/</code> and (404) not found error otherwise. By default no context is created and <code>exchange.context()</code> returns <code>null</code>.</p>
                    <p>A custom server controller can be injected when creating the <em>app_http</em> module. In the following code, a socket bean is defined to inject the custom server controller and starts an HTTP server which responds with <code>Hello from app_http module!</code> to any request:</p>
                    <pre><code class="language-java">package io.inverno.example.app_http;

import io.inverno.core.annotation.Bean;
import io.inverno.core.v1.Application;
import io.inverno.mod.http.server.ErrorExchange;
import io.inverno.mod.http.server.Exchange;
import io.inverno.mod.http.server.ExchangeContext;
import io.inverno.mod.http.server.ServerController;
import java.util.function.Supplier;

public class Main {

    @Bean
	public static interface Controller extends Supplier&lt;ServerController&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;, ErrorExchange&lt;ExchangeContext&gt;&gt;&gt; {}

    public static void main(String[] args) {
        Application.with(new App_http.Builder()
            .setController(
                exchange -&gt; exchange.response().body().string().value("Hello from app_http module!")
            )
        ).run();
    }
}
</code></pre>
                    <p>The <code>ServerController</code> interface also exposes static methods to easily create a server controller with custom exchange and error exchange handlers:</p>
                    <pre><code class="language-java">package io.inverno.example.app_http;

import io.inverno.core.annotation.Bean;
import io.inverno.core.v1.Application;
import io.inverno.mod.http.server.ErrorExchange;
import io.inverno.mod.http.server.Exchange;
import io.inverno.mod.http.server.ExchangeContext;
import io.inverno.mod.http.server.ServerController;
import java.util.function.Supplier;

public class Main {

    @Bean
	public static interface Controller extends Supplier&lt;ServerController&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;, ErrorExchange&lt;ExchangeContext&gt;&gt;&gt; {}

    public static void main(String[] args) {
        Application.with(new App_http.Builder()
            .setController(
                ServerController.from(
                    exchange -&gt; {
                        exchange.response()
                            .body().string().value("Hello from app_http module!");
                    },
                    errorExchange -&gt; {
                        errorExchange.response()
                            .headers(headers -&gt; headers.status(Status.INTERNAL_SERVER_ERROR))
                            .body().string().value(errorExchange.getError().getMessage());
                    }
                )
            )
        ).run();
    }
}
</code></pre>
                    <p>It is also possible to provide a server controller bean in the <em>app_http</em> module:</p>
                    <pre><code class="language-java">package io.inverno.example.app_http;

import io.inverno.core.annotation.Bean;
import io.inverno.mod.http.base.HttpException;
import io.inverno.mod.http.server.ErrorExchange;
import io.inverno.mod.http.server.Exchange;
import io.inverno.mod.http.server.ExchangeContext;
import io.inverno.mod.http.server.ServerController;

@Bean
public class App_httpServerController implements ServerController&lt;App_httpServerController.CustomContext, Exchange&lt;App_httpServerController.CustomContext&gt;, ErrorExchange&lt;App_httpServerController.CustomContext&gt;&gt;{

    @Override
    public void handle(Exchange&lt;CustomContext&gt; exchange) throws HttpException {
        exchange.response().body().string().value("Hello " + exchange.context().getName() + " from app_http module!");
    }

    @Override
    public CustomContext createContext() {
        return new CustomContext();
    }
	
    public static class CustomContext implements ExchangeContext {

        private String name = "anonymous";

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }
}
</code></pre>
                    <p>This bean is automatically wired to the server controller socket defined by the <em>http-server</em> module overriding the default server controller.</p>
                    <blockquote>
                        <p>Note that above implementation still uses the default error handler.</p>
                    </blockquote>
                    <p>With this approach there is no need for a server controller socket bean and the server can be simply started as before:</p>
                    <pre><code class="language-java">package io.inverno.example.app_http;

import io.inverno.core.v1.Application;

public class Main {

    public static void main(String[] args) {
        Application.with(new App_http.Builder()).run();
    }
}
</code></pre>
                    <pre><code class="language-plaintext">2022-07-18 11:12:57,710 INFO  [main] i.i.c.v.Application - Inverno is starting...


     ╔════════════════════════════════════════════════════════════════════════════════════════════╗
     ║                      , ~~ ,                                                                ║
     ║                  , '   /\   ' ,                                                            ║
     ║                 , __   \/   __ ,      _                                                    ║
     ║                ,  \_\_\/\/_/_/  ,    | |  ___  _    _  ___   __  ___   ___                 ║
     ║                ,    _\_\/_/_    ,    | | / _ \\ \  / // _ \ / _|/ _ \ / _ \                ║
     ║                ,   __\_/\_\__   ,    | || | | |\ \/ /|  __/| | | | | | |_| |               ║
     ║                 , /_/ /\/\ \_\ ,     |_||_| |_| \__/  \___||_| |_| |_|\___/                ║
     ║                  ,     /\     ,                                                            ║
     ║                    ,   \/   ,                                  -- 1.5.1 --                 ║
     ║                      ' -- '                                                                ║
     ╠════════════════════════════════════════════════════════════════════════════════════════════╣
     ║ Java runtime        : OpenJDK Runtime Environment                                          ║
     ║ Java version        : 17.0.2+8-86                                                          ║
     ║ Java home           : /home/jkuhn/Devel/jdk/jdk-17.0.2                                     ║
     ║                                                                                            ║
     ║ Application module  : io.inverno.example.app_http                                          ║
     ║ Application version : 1.0.0-SNAPSHOT                                                       ║
     ║ Application class   : io.inverno.example.app_http.Main                                     ║
     ║                                                                                            ║
     ║ Modules             :                                                                      ║
     ║  ....                                                                                      ║
     ╚════════════════════════════════════════════════════════════════════════════════════════════╝


2022-07-18 11:12:57,713 INFO  [main] i.i.e.a.App_http - Starting Module io.inverno.example.app_http...
2022-07-18 11:12:57,713 INFO  [main] i.i.m.b.Boot - Starting Module io.inverno.mod.boot...
2022-07-18 11:12:57,935 INFO  [main] i.i.m.b.Boot - Module io.inverno.mod.boot started in 221ms
2022-07-18 11:12:57,935 INFO  [main] i.i.m.h.s.Server - Starting Module io.inverno.mod.http.server...
2022-07-18 11:12:57,935 INFO  [main] i.i.m.h.b.Base - Starting Module io.inverno.mod.http.base...
2022-07-18 11:12:57,940 INFO  [main] i.i.m.h.b.Base - Module io.inverno.mod.http.base started in 5ms
2022-07-18 11:12:57,994 INFO  [main] i.i.m.h.s.i.HttpServer - HTTP Server (nio) listening on http://0.0.0.0:8080
2022-07-18 11:12:57,995 INFO  [main] i.i.m.h.s.Server - Module io.inverno.mod.http.server started in 59ms
2022-07-18 11:12:57,995 INFO  [main] i.i.e.a.App_http - Module io.inverno.example.app_http started in 283ms
2022-07-18 11:12:57,998 INFO  [main] i.i.c.v.Application - Application io.inverno.example.app_http started in 333ms
</code></pre>
                    <p>Now if we send a request to the server we should get the following response:</p>
                    <pre><code class="language-plaintext">$ curl -i http://localhost:8080
HTTP/1.1 200 OK
content-length: 37

Hello anonymous from app_http module!
</code></pre>
                    <h4 id="http-server-api">HTTP Server API</h4>
                    <p>The module defines classes and interfaces to handle HTTP requests sent by a client or errors raised during that process.</p>
                    <p>As we just saw, a <code>ServerController</code> must be provided to handle <code>Exchange</code> and <code>ErrorExchange</code>. An exchange represents an HTTP communication between a client and a server, it is composed of a <code>Request</code>, a <code>Response</code> and an <code>ExchangeContext</code>. An error exchange is created whenever an error is raised during the normal processing of an exchange and allows to report the error to the client. The API has been designed to be fluent and reactive in order for the request to be <em>streamed</em> down to the response.</p>
                    <h5 id="exchange-handler">Exchange handler</h5>
                    <p>An exchange handler is defined in a server controller and used to handle client-server exchanges. The <code>ReactiveExchangeHandler</code> is a functional interface defining method <code>Mono&lt;Void&gt; defer(Exchange&lt;ExchangeContext&gt; exchange)</code> which is used to handle server exchanges in a reactive way. It is for instance possible to execute non-blocking operations before actually handling the exchange.</p>
                    <blockquote>
                        <p>Authentication is a typical example of a non-blocking operation that might be executed before handling the request.</p>
                    </blockquote>
                    <blockquote>
                        <p>Under the hood, the server first subscribes to the returned <code>Mono</code>, when it completes the server then subscribes to the response body data publisher and eventually sends a response to the client.</p>
                    </blockquote>
                    <p>The <code>ExchangeHandler</code> extends the <code>ReactiveExchangeHandler</code> with method <code>void handle(Exchange&lt;ExchangeContext&gt; exchange)</code> which is more convenient than <code>defer()</code> when no non-blocking operation other than the generation of the client response is required.</p>
                    <p>A basic exchange handler can then be created as follows:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    exchange.response().body().string().value("Hello, world!");
};
</code></pre>
                    <p>The above exchange handler sends a <code>Hello, world!</code> message in response to any request.</p>
                    <h5 id="response-body">Response body</h5>
                    <p>A response body must be sent back to the client in order to terminate the exchange, the API exposes several ways to provide response data and therefore terminate the exchange.</p>
                    <h6 id="empty">Empty</h6>
                    <p>An exchange can be ended with no response body as follows:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    exchange.response().body().empty();
};
</code></pre>
                    <h6 id="string">String</h6>
                    <p>We already saw how to send a single string response but we might also want to send the response in a reactive way as a stream of data in case the entire response payload is not available right away, if it doesn't fit in memory or if we simply want to send a response in multiple parts as soon as they become available (e.g. progressive display).</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    exchange.response().body().string().stream(Flux.just("Hello", ", world!"));
};
</code></pre>
                    <h6 id="raw">Raw</h6>
                    <p>Raw data (i.e. bytes) can also be sent in response to a request. As for the string response, the response can be a single byte buffer or a stream of byte buffers:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    Flux&lt;ByteBuf&gt; dataStream = Flux.just(
        Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("Hello", Charsets.DEFAULT)),
        Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(", world!", Charsets.DEFAULT))
    );

    exchange.response().body().raw().stream(dataStream);
};
</code></pre>
                    <blockquote>
                        <p>Returned <code>ByteBuf</code> are released as soon as they are sent to the client.</p>
                    </blockquote>
                    <h6 id="resource">Resource</h6>
                    <p>A <a href="#resource-api">resource</a> can be sent in a response body. When possible the server uses low-level (<a href="https://en.wikipedia.org/wiki/Zero-copy">zero-copy</a>) API for fast resource transfer.</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    exchange.response()
        .body().resource().value(new FileResource("/path/to/resource"));
};
</code></pre>
                    <p>The media type of the resource is resolved using a <a href="#media-type-service">media type service</a> and automatically set in the response <code>content-type</code> header field.</p>
                    <blockquote>
                        <p>If a specific resource is created as in above example the media type service used is the one defined when creating the resource or a default implementation if none was specified. If the resource is obtained with the resource service provided in the <em>boot</em> module the media type service used is the one provided in the <em>boot</em> module.</p>
                    </blockquote>
                    <h6 id="server-sent-events">Server-sent events</h6>
                    <p><a href="https://en.wikipedia.org/wiki/Server-sent_events">Server-sent events</a> provide a way to send server push notifications to a client. It is based on <a href="https://en.wikipedia.org/wiki/Chunked_transfer_encoding">chunked transfer encoding</a> over HTTP/1.x and regular streams over HTTP/2. The API provides an easy way to create SSE endpoints.</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    exchange.response().body().sse().from(
        (events, data) -&gt; data.stream(Flux.interval(Duration.ofSeconds(1))
            .map(seq -&gt; events.create(event -&gt; event
                .id(Long.toString(seq))
                .event("seq")
                .comment("Some comment")
                .value(Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("Event #" + seq, Charsets.DEFAULT))))
            )
        )
    );
};
</code></pre>
                    <p>In the above example, server-sent events are emitted every second and streamed to the response. This is done in a function accepting the server-sent event factory used to create events and the response data producer.</p>
                    <h5 id="request-body">Request body</h5>
                    <p>Request body can be handled in a similar way. The reactive API allows to process the payload of a request as the server receives it and therefore progressively build and send the corresponding response.</p>
                    <p>A request body is however optional as not all HTTP request has a body.</p>
                    <h6 id="string-1">String</h6>
                    <p>The request body can be consumed as <code>CharSequence</code> as follows:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    exchange.response()
        .body().string().stream(exchange.request().body()
            .map(body -&gt; Flux.from(body.string().stream()).map(s -&gt; Integer.toString(s.length())))
            .orElse(Flux.just("0"))
        );
};
</code></pre>
                    <p>In the above example, if a client sends a payload in the request, the server responds with the number of characters of each string received or it responds <code>0</code> if the request payload is empty. As before, request body is processed as a flow of data.</p>
                    <h6 id="raw-1">Raw</h6>
                    <p>It can also be consumed as raw data as follows:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    exchange.response()
        .body().raw().stream(exchange.request().body()
            .map(body -&gt; Flux.from(body.raw().stream())
                .map(chunk -&gt; {
                    try {
                        return Unpooled.unreleasableBuffer(Unpooled.buffer(4).writeInt(chunk.readableBytes()));
                    }
                    finally {
                        chunk.release();
                    }
                })
            )
            .orElse(Flux.just(Unpooled.unreleasableBuffer(Unpooled.buffer(4).writeInt(0))))
        );
};
</code></pre>
                    <p>In the above example, if a client sends a payload in the request, the server responds with the number of bytes of each chunk of data it receives or it responds <code>0</code> if the request payload is empty. This simple example illustrates how we can process requests as flow of data.</p>
                    <blockquote>
                        <p>Note that request's <code>ByteBuf</code> data must be released when they are consumed in the exchange handler.</p>
                    </blockquote>
                    <h6 id="url-encoded-form">URL Encoded form</h6>
                    <p>HTML form data are sent in the body of a POST request in the form of key/value pairs encoded in <a href="https://url.spec.whatwg.org/#application/x-www-form-urlencoded">application/x-www-form-urlencoded format</a>. The resulting list of <code>Parameter</code> can be obtained as follows:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    exchange.response()
        .body().string().stream(Flux.from(exchange.request().body().get().urlEncoded().stream())
            .map(parameter -&gt; "Received parameter " + parameter.getName() + " with value " + parameter.getValue())
        );
}
</code></pre>
                    <p>In the above example, for each form parameters the server responds with a message describing the parameters it just received. Again this shows that the API is fully reactive and form parameters can be processed as they are decoded.</p>
                    <p>A more traditional example though would be to obtained the map of parameters grouped by names (because multiple parameters with the same name can be sent):</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    exchange.response()
        .body().string().stream(Flux.from(exchange.request().body().get().urlEncoded().stream())
        .collectMultimap(Parameter::getName)
            .map(formParameters -&gt; "User selected options: " + formParameters.get("options").stream().map(Parameter::getValue).collect(Collectors.joining(", ")))
        );
}
</code></pre>
                    <blockquote>
                        <p>Here we may think that the aggregation of parameters in a map could <em>block</em> the I/O thread but this is actually not true, when a parameter is decoded, the reactive framework is notified and the parameter is stored in a map, after that the I/O thread can be reallocated. When the parameters publisher completes the resulting map is emitted to the mapping function which build the response. During all this process, no thread is ever waiting for anything.</p>
                    </blockquote>
                    <h6 id="multipart-form">Multipart form</h6>
                    <p>A <a href="https://tools.ietf.org/html/rfc7578">multipart/form-data</a> request can be handled in a similar way. Form parts can be obtained as follows:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    exchange.response()
        .body().string().stream(Flux.from(exchange.request().body().get().multipart().stream())
            .map(part -&gt; "Received part " + part.getName())
        );
};
</code></pre>
                    <p>Multipart form data is most commonly used for uploading files over HTTP. Such handler can be implemented as follows using the <a href="#resource-api">resource API</a> to store uploaded files:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    exchange.response().body().string().stream(
        Flux.from(exchange.request().body().get().multipart().stream())                                                           // 1 
            .flatMap(part -&gt; part.getFilename()                                                                                   // 2 
                .map(fileName -&gt; Flux.&lt;CharSequence, FileResource&gt;using(                                                          // 3 
                    () -&gt; new FileResource("uploads/" + part.getFilename().get()),                                                // 4 
                    file -&gt; file.write(part.raw().stream()).map(Flux::from).get()                                                 // 5 
                        .reduce(0, (acc, cur) -&gt; acc + cur)
                        .map(size -&gt; "Uploaded " + fileName + "(" + part.headers().getContentType() + "): " + size + " Bytes\n"),  
                    FileResource::close                                                                                           // 6 
                ))
                .orElseThrow(() -&gt; new BadRequestException("Not a file part"))                                                    // 7 
            )
    );
};
</code></pre>
                    <p>The above code uses multiple elements and deserves a detailed explanation:</p>
                    <ol>
                        <li>get the stream of parts</li>
                        <li>map the part to the response stream by starting to determine whether the part is a file part</li>
                        <li>if the part is a file part, map the part to the response stream by creating a Flux with a file resource</li>
                        <li>in this case the resource is the target file where the uploaded file will be stored</li>
                        <li>stream the part's payload to the target file resource and eventually provides the response in the form of a message stating that a file with a given size and media type has been uploaded</li>
                        <li>close the file resource when the publisher completes</li>
                        <li>if the part is not a file part respond with a bad request error</li>
                    </ol>
                    <p>The <code>Flux.using()</code> construct is the reactive counterpart of a try-with-resource statement. It is interesting to note that the content of the file is streamed up to the file and it is then never entirely loaded in memory. From there, it is quite easy to stop the upload of a file if a given size threshold is exceeded. We can also imagine how we could create a progress bar in a client UI to show the progression of the upload.</p>
                    <blockquote>
                        <p>In the above code we uploaded one or more file and stored their content on the local file system and during all that process, the I/O thread was never blocked.</p>
                    </blockquote>
                    <blockquote>
                        <p>Note that since part's <code>ByteBuf</code> data are consumed by the target file resource, there is no need to release them in the exchange handler.</p>
                    </blockquote>
                    <h5 id="error-exchange-handler">Error exchange handler</h5>
                    <p>An error exchange handler is defined in a server controller and used to handle errors raised during the normal processing of an exchange in the exchange handler.</p>
                    <p>It is basically an <code>ExchangeHandler</code> of <code>ErrorExchange</code>. An error exchange exposes the original error, it is then possible to implement different behaviours based on the type of error:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, ErrorExchange&lt;ExchangeContext&gt;&gt; errorHandler = errorExchange -&gt; {
    if(errorExchange.getError() instanceof BadRequestException) {
        errorExchange.response().body().raw().value(Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("client sent an invalid request", Charsets.DEFAULT)));
    }
    else {
        errorExchange.response().body().raw().value(Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("Unknown server error", Charsets.DEFAULT)));
    }
};
</code></pre>
                    <h5 id="exchange-interceptor">Exchange interceptor</h5>
                    <p>An exchange handler can be intercepted using an <code>ExchangeInterceptor</code>. An interceptor can be used to preprocess an exchange in order to check preconditions and potentially respond to the client instead of the handler, initialize a context (tracing, metrics...), decorate the exchange...</p>
                    <p>The <code>intercept()</code> method returns a <code>Mono</code> which makes it reactive and allows to invoke non-blocking operations before invoking the handler.</p>
                    <p>An intercepted exchange handler can be created as follows:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {...};

ExchangeInterceptor&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; interceptor = exchange -&gt; {
    LOGGER.info("Path: " + exchange.request().getPath());

    // exchange is returned unchanged and will be processed by the handler
    return Mono.just(exchange);
};

ReactiveExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; interceptedHandler = handler.intercept(interceptor);
</code></pre>
                    <p>An interceptor can also end an exchange, in which case it must return an empty <code>Mono</code> to stop the exchange handling chain.</p>
                    <pre><code class="language-java">ExchangeInterceptor&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; interceptor = exchange -&gt; {
    // Check some preconditions...
    if(...) {
        // Do some processing and terminate the exchange
        exchange.response().body().empty();

        // the exchange has been processed by the interceptor and it won't be processed by the handler
        return Mono.empty();
    }
    return Mono.just(exchange);
}
</code></pre>
                    <p>Mulitple interceptors can be chained by invoking <code>intercept()</code> method mutliple times:</p>
                    <pre><code class="language-java">// exchange handling chain: interceptor3 -&gt; interceptor2 -&gt; interceptor1 -&gt; handler
handler.intercept(interceptor1).intercept(interceptor2).intercept(interceptor3);
</code></pre>
                    <h5 id="exchange-context">Exchange context</h5>
                    <p>A strongly typed context is exposed in the <code>Exchange</code>, it allows to store or access data and to provide contextual operations throughout the process of the exchange. The server creates the context along with the exchange using the server controller. It is then possible to <em>customize</em> the exchange with a specific strongly types context.</p>
                    <p>The advantage of this approach is that the compiler can perform static type checking but also to avoid the usage of an untyped map of attributes which is less performant and provides no control over contextual data. Since the developer defines the context type, he can also implement logic inside.</p>
                    <p>A context can be used to store security information, tracing information, metrics... For instance, if we combine this with exchange interceptors:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;SecurityContext, Exchange&lt;SecurityContext&gt;&gt; handler = exchange -&gt; {
    if(exchange.context().isAuthenticated()) {
        exchange.response().body().string().value("Hello, world!");
    }
    else {
        exchange.response().body().empty();
    }
};

ExchangeInterceptor&lt;SecurityContext, Exchange&lt;SecurityContext&gt;&gt; securityInterceptor = exchange -&gt; {
    // Authenticate the request
    if(...) {
        exchange.context().setAuthenticated(true);
    }
    return Mono.just(exchange);
}

ReactiveExchangeHandler&lt;SecurityContext, Exchange&lt;SecurityContext&gt;&gt; interceptedHandler = handler.intercept(securityInterceptor);
</code></pre>
                    <blockquote>
                        <p>The server relies on the <code>ServerController</code> in order to create the context. Please refer to the <a href="#server-controller">Server Controller</a> section which explains this in details and describes how to setup the HTTP server.</p>
                    </blockquote>
                    <h5 id="misc">Misc</h5>
                    <p>The API is fluent and mostly self-describing as a result it should be easy to find out how to do something in particular, even so here are some miscellaneous elements</p>
                    <h6 id="request-headers">Request headers</h6>
                    <p>Request headers can be obtained as string values as follows:</p>
                    <pre><code class="language-java">handler = exchange -&gt; {
    // Returns the value of the first occurence of 'some-header' as string or returns null
    String someHeaderValue = exchange.request().headers().get("some-header").orElse(null);
    
    // Returns all 'some-header' values as strings
    List&lt;String&gt; someHeaderValues = exchange.request().headers().getAll("some-header");
    
    // Returns all headers as strings
    List&lt;Map.Entry&lt;String, String&gt;&gt; allHeadersValues = exchange.request().headers().getAll();
};
</code></pre>
                    <p>It is also possible to get headers as <code>Parameter</code> which allows to easily convert the value using a parameter converter:</p>
                    <pre><code class="language-java">handler = exchange -&gt; {
    // Returns the value of the first occurence of 'some-header' as LocalDateTime or returns null
    LocalDateTime someHeaderValue = exchange.request().headers().getParameter("some-header").map(Parameter::asLocalDateTime).orElse(null);
    
    // Returns all 'some-header' values as LocalDateTime
    List&lt;LocalDateTime&gt; someHeaderValues = exchange.request().headers().getAllParameter("some-header").stream().map(Parameter::asLocalDateTime).collect(Collectors.toList());
    
    // Returns all headers as parameters
    List&lt;Parameter&gt; allHeadersParameters = exchange.request().headers().getAllParameter();
};
</code></pre>
                    <p>The <em>http-server</em> module can also uses the <a href="#http-header-service">header service</a> provided by the <em>http-base</em> module to decode HTTP headers:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    // Returns the decoded 'content-type' header or null
    Headers.ContentType contenType = exchange.request().headers().&lt;Headers.ContentType&gt;getHeader(Headers.NAME_CONTENT_TYPE).orElse(null);
    
    String mediaType = contenType.getMediaType();
    Charset charset = contenType.getCharset();
    ...
};
</code></pre>
                    <blockquote>
                        <p>The header service can be extended with custom HTTP <code>HeaderCodec</code>. Please refer to <a href="#extending-http-services">Extending HTTP services</a> and the <a href="#http-base">http-base module</a> for more information.</p>
                    </blockquote>
                    <h6 id="query-parameters">Query parameters</h6>
                    <p>Query parameters in the request can be obtained as follows:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    ...
    // get a specific query parameter, if there are multiple parameters with the same name, the first one is returned
    int someInteger = exchange.request().queryParameters().get("some-integer").map(Parameter::asInteger).orElseThrow(() -&gt; new BadRequestException("Missing some-integer"));

    // get all query parameters with a given name
    List&lt;Integer&gt; someIntergers = exchange.request().queryParameters().getAll("some-integer").stream().map(Parameter::asInteger).collect(Collectors.toList());

    // get all query parameters
    Map&lt;String, List&lt;Parameter&gt;&gt; queryParameters = exchange.request().queryParameters().getAll();
    ...
};
</code></pre>
                    <h6 id="request-cookies">Request cookies</h6>
                    <p>Request cookie can be obtained in a similar way as follows:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    ...
    // get a specific cookie, if there are multiple cookie with the same name, the first one is returned
    int someInteger = exchange.request().cookies().get("some-integer").map(Parameter::asInteger).orElseThrow(() -&gt; new BadRequestException("Missing some-integer"));

    // get all cookies with a given name
    List&lt;Integer&gt; someIntergers = exchange.request().cookies().getAll("some-integer").stream().map(Parameter::asInteger).collect(Collectors.toList());

    // get all cookies
    Map&lt;String, List&lt;CookieParameter&gt;&gt; queryParameters = exchange.request().cookies().getAll();
    ...
};
</code></pre>
                    <h6 id="request-components">Request components</h6>
                    <p>The API also gives access to multiple request related information such as:</p>
                    <ul>
                        <li>the HTTP method:</li>
                    </ul>
                    <pre><code class="language-java">exchange.request().getMethod();
</code></pre>
                    <ul>
                        <li>the scheme (<code>http</code> or <code>https</code>):</li>
                    </ul>
                    <pre><code class="language-java">exchange.request().getScheme();
</code></pre>
                    <ul>
                        <li>the authority part of the requested URI (<code>host</code> header in HTTP/1.x and <code>:authority</code> pseudo-header in HTTP/2):</li>
                    </ul>
                    <pre><code class="language-java">exchange.request().getAuthority();
</code></pre>
                    <ul>
                        <li>the requested path including query string:</li>
                    </ul>
                    <pre><code class="language-java">exchange.request().getPath();
</code></pre>
                    <ul>
                        <li>the absolute path which is the normalized requested path without the query string:</li>
                    </ul>
                    <pre><code class="language-java">exchange.request().getAbsolutePath();
</code></pre>
                    <ul>
                        <li>the <code>URIBuilder</code> corresponding to the requested path to build relative paths:</li>
                    </ul>
                    <pre><code class="language-java">exchange.request().getPathBuilder().path("path/to/child/resource").build();
</code></pre>
                    <ul>
                        <li>the query string:</li>
                    </ul>
                    <pre><code class="language-java">exchange.request().getQuery();
</code></pre>
                    <ul>
                        <li>the socket address of the client or last proxy that sent the request:</li>
                    </ul>
                    <pre><code class="language-java">exchange.request().getRemoteAddress();
</code></pre>
                    <h6 id="response-status">Response status</h6>
                    <p>The response status can be set in the response headers following HTTP/2 specification as defined by <a href="https://tools.ietf.org/html/rfc7540#section-8.1.2.4">RFC 7540 Section 8.1.2.4</a>.</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    exchange.response()
        .headers(headers -&gt; headers.status(Status.OK))
        .body().raw();
};
</code></pre>
                    <h6 id="response-headerstrailers">Response headers/trailers</h6>
                    <p>Response headers can be added or set fluently using a configurator as follows:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    exchange.response()
        .headers(headers -&gt; headers
            .contentType(MediaTypes.TEXT_PLAIN)
            .set(Headers.NAME_SERVER, "inverno")
            .add("custom-header", "abc")
        )
        .body().raw()...;
};
</code></pre>
                    <p>Response trailers can be set in the exact same way:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    exchange.response()
        .trailers(headers -&gt; headers
            .add("some-trailer", "abc")
        )
        .body().raw()...;
};
</code></pre>
                    <h6 id="response-cookies">Response cookies</h6>
                    <p>Response cookies can be set fluently using a configurator as follows:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    exchange.response()
        .cookies(cookies -&gt; cookies
            .addCookie(cookie -&gt; cookie.name("cookie1")
                .httpOnly(true)
                .secure(true)
                .maxAge(3600)
                .value("abc")
            )
            .addCookie(cookie -&gt; cookie.name("cookie2")
                .httpOnly(true)
                .secure(true)
                .maxAge(3600)
                .value("def")
            )
        )
        .body().raw()...;
};
</code></pre>
                    <h4 id="websocket">WebSocket</h4>
                    <p>An HTTP exchange can be upgraded to a WebSocket exchange as defined by <a href="https://datatracker.ietf.org/doc/html/rfc6455">RFC 6455</a>.</p>
                    <p>The <code>webSocket()</code> method exposed on the <code>Exchange</code> allows to upgrade to the WebSocket protocol, it returns an optional <code>WebSocket</code> which might be empty if the original exchange does not support the upgrade. This is especially the case when using HTTP/2 for which Websocket upgrade is not supported or if the state of the exchange prevents the upgrade (e.g. error exchange).</p>
                    <p>The resulting <code>WebSocket</code> allows specifying a <code>WebSocketExchangeHandler</code> and a default action in case the WebSocket opening handshake fails (e.g. the client did not provide the correct headers for the upgrade...). A WebSocket exchange handler is used to handle the resulting <code>WebSocketExchange</code> which exposes WebSocket inbound and outbound data.</p>
                    <p>In the following example, the original HTTP <code>Exchange</code> is upgraded to a <code>WebSocketExchange</code> and all inbound frames are sent back to the client. An internal server error (500) is returned if WebSocket upgrade is not supported and a bad request error (400) is returned if the opening handshake failed:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    exchange.webSocket()
        .orElseThrow(() -&gt; new InternalServerErrorException("WebSocket not supported"))
        .handler(webSocketExchange -&gt; {
            webSocketExchange.outbound().frames(factory -&gt; webSocketExchange.inbound().frames());
        })
        .or(() -&gt; {
            throw new BadRequestException("Web socket handshake failed");
        });
};
</code></pre>
                    <p>It is possible to specify the supported subprotocols when creating the <code>WebSocket</code>, an <code>UnsupportedProtocolException</code> shall be raised if the subprotocol negotiation fails (i.e. the client requested a protocol that is not supported by the server)</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    // Indicates that the server supports the 'chat' subprotocol
    exchange.webSocket("chat")
        ...
};
</code></pre>
                    <p>The <code>WebSocketExchange</code> also exposes:</p>
                    <ul>
                        <li>the original HTTP request,</li>
                    </ul>
                    <pre><code class="language-java">webSocketExchange.request();
</code></pre>
                    <ul>
                        <li>the exchange context:</li>
                    </ul>
                    <pre><code class="language-java">webSocketExchange.context();
</code></pre>
                    <ul>
                        <li>the negotiated subprotocol:</li>
                    </ul>
                    <pre><code class="language-java">webSocketExchange.getSubProtocol();
</code></pre>
                    <ul>
                        <li>multiple methods for closing the WebSocket:</li>
                    </ul>
                    <pre><code class="language-java">webSocketExchange.close(WebSocketStatus.NORMAL_CLOSURE);
webSocketExchange.close((short)1000, "Goodbye!");
</code></pre>
                    <p>A WebSocket exchange finalizer can be specified to free resources once the WebSocket is closed:</p>
                    <pre><code class="language-java">webSocketExchange.finalizer(Mono.fromRunnable(() -&gt; {
    // Release some resources
    ...
}));
</code></pre>
                    <p>The WebSocket protocol is bidirectional and allows sending and receiving data on both ends exposed by <code>inbound()</code> and <code>outbound()</code> methods in the WebSocket exchange.</p>
                    <h5 id="inbound">Inbound</h5>
                    <p>In a WebSocket exchange, the <code>Inbound</code> exposes the stream of frames sent by the client to the server. It allows to consume WebSocket frames (text or binary) or messages (text or binary).</p>
                    <p>The following handler simply logs incoming frames:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    exchange.webSocket()
        .orElseThrow(() -&gt; new InternalServerErrorException())
        .handler(webSocketExchange -&gt; {
            Flux.from(webSocketExchange.inbound().frames()).subscribe(frame -&gt; {
                try {
                    LOGGER.info("Received WebSocket frame: kind = " + frame.getKind() + ", final = " + frame.isFinal() + ", size = " + frame.getBinaryData().readableBytes());
                }
                finally {
                    frame.release();
                }
            });
        });
};
</code></pre>
                    <p>As for request body <code>ByteBuf</code> data, WebSocket frames are reference counted and they must be released where they are consumed. In previous example, inbound frames are consumed in the handler which must release them.</p>
                    <p>The WebSocket protocol supports fragmentation as defined by <a href="https://datatracker.ietf.org/doc/html/rfc6455#section-5.4">RFC 6455 Section 5.4</a>, a WebSocket message can be fragmented into multiple frames, the final frame being flagged as final to indicate the end of the message. The <code>Inbound</code> can handle fragmented WebSocket messages and allows to consume corresponding fragmented data in multiple ways.</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    exchange.webSocket()
        .orElseThrow(() -&gt; new InternalServerErrorException())
        .handler(webSocketExchange -&gt; {
            Flux.from(webSocketExchange.inbound().messages()).subscribe(message -&gt; {
                // The stream of frames composing the message
                Publisher&lt;WebSocketFrame&gt; frames = message.frames();
            
                // The message data as stream of ByteBuf
                Publisher&lt;ByteBuf&gt; binary = message.binary();
                
                // The message data as stream of String
                Publisher&lt;String&gt; text = message.text();
                
                // Aggregate all fragments into a single ByteBuf
                Mono&lt;ByteBuf&gt; reducedBinary = message.reducedBinary();
                
                // Aggregate all fragments into a single String
                Mono&lt;String&gt; reducedText = message.reducedText();
                
                ...
            });
        });
};
</code></pre>
                    <blockquote>
                        <p>Note that the different publishers in previous example are all variants of the frames publisher, as a result they are exclusive and it is only possible to subscribe once to only one of them.</p>
                    </blockquote>
                    <p>Unlike WebSocket frames, WebSocket messages are not reference counted, however message fragments, which are basically frames, must be released when consumed as WebSocket frames or <code>ByteBuf</code>.</p>
                    <p>Messages can be filtered by type (text or binary) by invoking <code>WebSocketExchange.Inbound#textMessages()</code> and <code>WebSocketExchange.Inbound#binaryMessages()</code>.</p>
                    <h5 id="outbound">Outbound</h5>
                    <p>In a WebSocket exchange, the <code>Outbound</code> exposes the stream of frames sent by the server to the client. It allows to specify the stream of WebSocket frames (text or binary) or messages (text or binary) to send to the client. WebSocket frames and messages are created using provided factories.</p>
                    <p>The following handler simply sends three text frames to the client. The WebSocket is closed automatically when the outbound publisher terminates.</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    exchange.webSocket()
        .orElseThrow(() -&gt; new InternalServerErrorException())
        .handler(webSocketExchange -&gt; {
            webSocketExchange.outbound().frames(factory -&gt; Flux.just("ONE", "TWO", "THREE").map(factory::text));
        });
}
</code></pre>
                    <p>Likewise we can send messages to the client, in the following example three Websocket frames are sent to the client per message: the constant <code>message:</code>, the actual message content and an empty final frame which marks the end of the message. Frames and messages publisher are exclusive, only one of them can be specified.</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    exchange.webSocket()
        .orElseThrow(() -&gt; new InternalServerErrorException())
        .handler(webSocketExchange -&gt; {
            webSocketExchange.outbound().messages(factory -&gt; Flux.just("ONE", "TWO", "THREE").map(content -&gt; factory.text(Flux.just("message: ", content))));
        });
}
</code></pre>
                    <h5 id="a-simple-chat-server">A simple chat server</h5>
                    <p>Using the reactive API, a simple chat server can be implemented quite easily. The following exchange handler uses a sink to broadcast the frames received to every connected clients:</p>
                    <pre><code class="language-java">package io.inverno.example.app_http_websocket;

import io.inverno.core.annotation.Bean;
import io.inverno.core.annotation.Destroy;
import io.inverno.core.annotation.Init;
import io.inverno.mod.base.resource.MediaTypes;
import io.inverno.mod.base.resource.PathResource;
import io.inverno.mod.base.resource.Resource;
import io.inverno.mod.http.base.HttpException;
import io.inverno.mod.http.server.ErrorExchange;
import io.inverno.mod.http.server.Exchange;
import io.inverno.mod.http.server.ExchangeContext;
import io.inverno.mod.http.server.ServerController;
import io.inverno.mod.http.server.ws.WebSocketFrame;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Sinks;

@Bean
public class ChatServerController implements ServerController&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;, ErrorExchange&lt;ExchangeContext&gt;&gt; {

    private Sinks.Many&lt;WebSocketFrame&gt; chatSink;

    @Init
    public void init() {
        this.chatSink = Sinks.many().multicast().onBackpressureBuffer(16, false);                                                  // 0 
    }

    @Destroy
    public void destroy() {
        this.chatSink.tryEmitComplete();
    }

    @Override
    public void handle(Exchange&lt;ExchangeContext&gt; exchange) throws HttpException {
        exchange.webSocket().ifPresentOrElse(
            websocket -&gt; websocket
                .handler(webSocketExchange -&gt; {
                    Flux.from(webSocketExchange.inbound().frames())                                                                // 1 
                        .subscribe(frame -&gt; {                                                                                      // 2 
                            try {
                                this.chatSink.tryEmitNext(frame);                                                                  // 3 
                            }
                            finally {
                                frame.release();                                                                                   // 4 
                            }
                        });
                    webSocketExchange.outbound().frames(factory -&gt; this.chatSink.asFlux().map(WebSocketFrame::retainedDuplicate)); // 5 
                })
                .or(() -&gt; exchange.response()
                    .body().string().value("Web socket handshake failed")
                ),
            () -&gt; exchange.response()
                .body().string().value("WebSocket not supported")
        );
    }
}
</code></pre>
                    <ol start="0">
                        <li>Create a multicast chat sink with autocancel set to false to broadcast inbound frames to all connected clients.</li>
                        <li>When receiving a new connection, get the inbound frames stream.</li>
                        <li>Subscribe to the inbound frames stream.</li>
                        <li>For each frame received, broadcast the frame using the chat sink.</li>
                        <li>Release the inbound frame.</li>
                        <li>Set the WebSocket outbound using the chat sink: on each frame, retain and duplicate.</li>
                    </ol>
                    <p>As stated before, WebSocket frames are reference counted and inbound WebSocket frames must be released since the handler is the one consuming them. Furthermore for each connected client, the frame must be duplicated, since it is written multiple times, and retained to increment the reference counter, since it must stay in memory until it has been sent to all connected clients.</p>
                    <blockquote>
                        <p>This chat server could have been implemented more simply without bothering with reference counting by emitting string data instead of frames in the chat sink. But this would actually be far less optimal as it would involve memory copy. In above solution, the incoming data is never copied into memory, there is only one <code>ByteBuf</code> written to all connected client. As always, it is important to find the right balance between performance, simplicity and readability.</p>
                    </blockquote>
                    <h4 id="extending-http-services">Extending HTTP services</h4>
                    <p>The <em>http-server</em> module also defines a socket to plug a custom parameter converter which is a basic <code>StringConverter</code> by default. Since we created the <em>app_http</em> module by composing <em>boot</em> and <em>http-server</em> modules, the parameter converter provided by the <em>boot</em> module should then override the default. This converter is a <code>StringCompositeConverter</code> which can be extended by injecting custom <code>CompoundDecoder</code> and/or <code>CompoundEncoder</code> instances in the <em>boot</em> module as described in the <a href="#composite-converter">composite converter documentation</a>.</p>
                    <p>The <code>HeaderService</code> provided by the <em>http-basic</em> module composed in the <em>http-server</em> module can also be extended by injecting custom <code>HeaderCodec</code> instances used to encode/decode custom HTTP headers.</p>
                    <p>In practice, all we have to do to extend these services is to provide <code>HeaderCodec</code>, <code>CompoundDecoder</code> or <code>CompoundEncoder</code> beans in the <em>app_http</em> module.</p>
                    <h4 id="wrap-up">Wrap-up</h4>
                    <p>If we put all we've just seen together, here is a complete example showing how to create a HTTP/2 server with HTTP compression using a custom server controller:</p>
                    <pre><code class="language-java">package io.inverno.example.app_http;

import io.inverno.core.annotation.Bean;
import io.inverno.core.v1.Application;
import io.inverno.mod.base.Charsets;
import io.inverno.mod.http.server.ErrorExchange;
import io.inverno.mod.http.server.Exchange;
import io.inverno.mod.http.server.ExchangeContext;
import io.inverno.mod.http.server.ServerController;
import io.netty.buffer.Unpooled;
import java.net.URI;
import java.util.function.Supplier;

public class Main {

    @Bean
    public static interface Controller extends Supplier&lt;ServerController&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;, ErrorExchange&lt;ExchangeContext&gt;&gt;&gt; {}

    public static void main(String[] args) {
        // Starts the server
        Application.run(new App_http.Builder()
            // Setups the server
            .setApp_httpConfiguration(
                    App_httpConfigurationLoader.load(configuration -&gt; configuration
                    .http_server(server -&gt; server
                        // HTTP compression
                        .decompression_enabled(true)
                        .compression_enabled(true)
                        // TLS
                        .server_port(8443)
                        .tls_enabled(true)
                        .key_store(URI.create("module:/keystore.jks"))
                        .key_store_password("password")
                        // Enable HTTP/2
                        .h2_enabled(true)
                    )
                )
            )
            // Sets the server controller
            .setController(ServerController.from(
                exchange -&gt; {
                    exchange.response()
                        .body().raw().value(Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("Hello from main!", Charsets.DEFAULT)));
                },
                errorExchange -&gt; {
                    errorExchange.response()
                        .headers(headers -&gt; headers.status(500))
                        .body().raw().value(Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("Error: " + errorExchange.getError().getMessage(), Charsets.DEFAULT)));
                }
            ))
        );
    }
}
</code></pre>
                    <pre><code class="language-plaintext">$ curl -i --insecure https://localhost:8443/
HTTP/2 200 
content-length: 16

Hello from main!
</code></pre>
                    <h3 id="web">Web</h3>
                    <p>The Inverno <em>web</em> module provides extended functionalities on top of the <em>http-server</em> module for developing high-end Web and RESTfull applications.</p>
                    <p>It especially provides:</p>
                    <ul>
                        <li>advanced HTTP request routing and interception</li>
                        <li>content negotiation</li>
                        <li>automatic message payload conversion</li>
                        <li>path parameters</li>
                        <li>static handler for serving static resources</li>
                        <li>version agnostic <a href="https://www.webjars.org/">WebJars</a> support</li>
                        <li>smooth Web/REST controller development</li>
                        <li><a href="https://www.openapis.org/">OpenAPI</a> specifications generation using Web/REST controllers JavaDoc comments</li>
                        <li>SwaggerUI integration</li>
                        <li>an Inverno compiler plugin providing static validation of the routes and generation of Web server controller configurers</li>
                    </ul>
                    <p>The <em>web</em> module composes the <em>http-server</em> module and therefore starts a HTTP server. Just like the <em>http-server</em> module, it requires a net service and a resource service as well as a list of <a href="#media-type-converter">media type converters</a> for message payload conversion. Basic implementations of these services are provided by the <em>boot</em> module which provides <code>application/json</code>, <code>application/x-ndjson</code> and <code>text/plain</code> media type converters. Additional media type converters can also be provided by implementing the <code>MediaTypeConverter</code> interface.</p>
                    <p>In order to use the Inverno <em>web</em> module, we should declare the following dependencies in the module descriptor:</p>
                    <pre><code class="language-java">@io.inverno.core.annotation.Module
module io.inverno.example.app_web {
    requires io.inverno.mod.boot;
    requires io.inverno.mod.web;
}
</code></pre>
                    <p>We also need to declare these dependencies in the build descriptor:</p>
                    <p>Using Maven:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-boot&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <p>Using Gradle:</p>
                    <pre><code class="language-java">...
compile 'io.inverno.mod:inverno-boot:1.5.2'
compile 'io.inverno.mod:inverno-web:1.5.2'
...
</code></pre>
                    <h4 id="web-routing-api">Web Routing API</h4>
                    <p>The <em>web</em> module defines an API for routing HTTP requests to the right handlers.</p>
                    <p>A <strong>router</strong> is a server exchange handler as defined by the <em>http-server</em> module API which can be used to handle exchanges or error exchanges in the server controller of the HTTP server, its role is to route an exchange to an handler based on a set of rules applied to the exchange.</p>
                    <p>A <strong>route</strong> specifies the rules that an exchange must matched to be routed to a particular handler. A <strong>route interceptor</strong> specifies the rules that a route must match to be intercepted by a particular exchange interceptor.</p>
                    <p>A <strong>route manager</strong> is used to manage the routes in a router or, more explicitly, to list, create, enable or disable routes in a router. An <strong>interceptor manager</strong> is used to configure the route interceptors in an intercepted router.</p>
                    <blockquote>
                        <p>The module defines a high level SPI in <code>io.inverno.mod.spi</code> package that can be used as a base to implement custom routing implementations in addition to the provided Web routing implementations. Nevertheless, it is more of a guideline, one can choose a totally different approach to implement routing, in the end the HTTP server expects a <code>ServerController</code> with an <code>ExchangeHandler&lt;ExchangeContext, Exchange&lt;ExchangeContext&gt;&gt;</code> to handle exchange and an <code>ExchangeHandler&lt;ExchangeContext, ErrorExchange&lt;ExchangeContext&gt;&gt;</code> to handle errors, what is done inside these handlers is completely opaque, the SPI only shows one way to do it.</p>
                    </blockquote>
                    <p>A <code>WebRouter</code> is used to route a <code>WebExchange</code> to the right <code>ExchangeHandler</code>, it extends <code>ExchangeHandler</code> and it is typically used as the exchange handler in a the server controller of the HTTP server.</p>
                    <p>An <code>ErrorRouter</code> is used to route an <code>ErrorWebExchange</code> to the right <code>ExchangeHandler</code> when an exception is thrown during the normal processing of an exchange, it extends <code>ExchangeHandler</code> and it is typically used as the error exchange handler in a the server controller of the HTTP server.</p>
                    <h5 id="web-exchange">Web exchange</h5>
                    <p>The <em>web</em> module API extends the <a href="#http-server-api">server exchange API</a> defined in the <em>http-server</em> module. It defines the server <code>WebExchange</code> composed of a <code>WebRequest</code>/<code>WebResponse</code> pair in a HTTP communication between a client and a server. These interfaces respectively extends the <code>Exchange</code>, <code>Request</code> and <code>Response</code> interfaces defined in the <em>http-server</em> module. A web exchange handler (i.e. <code>ExchangeHandler&lt;ExchangeContext, WebExchange&lt;ExchangeContext&gt;&gt;</code>) is typically attached to one or more Web routes defined in a <code>WebRouter</code>.</p>
                    <p>The Web exchange provides additional functionnalities on top of the exchange including support for path parameters, request/response body decoder/encoder based on the content type, WebSocket inbound/outbound data decoder/encoder based on the subprotocol.</p>
                    <h6 id="path-parameters">Path parameters</h6>
                    <p>Path parameters are exposed in the <code>WebRequest</code>, they are extracted from the requested path by the <a href="#web-router">Web router</a> when the handler is attached to a route matching a parameterized path as defined in a <a href="#uris">URI builder</a>.</p>
                    <p>For instance, if the handler is attached to a route matching <code>/book/{id}</code>, the <code>id</code> path parameter can be retrieved as follows:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, WebExchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    exchange.request().pathParameters().get("id")
        .ifPresentOrElse(
            id -&gt; {
                ...
            },
            () -&gt; exchange.response().headers(headers -&gt; headers.status(Status.NOT_FOUND)).body().empty()
        );
};
</code></pre>
                    <h6 id="request-body-decoder">Request body decoder</h6>
                    <p>The request body can be decoded based on the content type defined in the request headers.</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, WebExchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    Mono&lt;Result&gt; storeBook = exchange.request().body().get()
        .decoder(Book.class)
        .one()
        .map(book -&gt; storeBook(book));
    exchange.response().body()
        .string().stream(storeBook.map(result -&gt; result.getMessage()));
};
</code></pre>
                    <p>When invoking the <code>decoder()</code> method, a <a href="#media-type-converter">media type converter</a> corresponding to the request content type is selected to decode the payload. The <code>content-type</code> header MUST be specified in the request, otherwise (400) bad request error is returned indicating an empty media type. If there is no converter corresponding to the media type, a (415) unsupported media type error is returned indicating that no decoder was found matching the content type.</p>
                    <p>A decoder is obtained by specifying the type of the object to decode in the <code>decoder()</code> method, the type can be a <code>Class&lt;T&gt;</code> or a <code>java.lang.reflect.Type</code> which allows to decode parameterized types at runtime bypassing type erasure. Parameterized Types can be built at runtime using the <a href="#reflection-api">reflection API</a>.</p>
                    <p>As you can see in the above example the decoder is fully reactive, a request payload can be decoded in a single object by invoking method <code>one()</code> on the decoder which returns a <code>Mono&lt;T&gt;</code> publisher or in a stream of objects by invoking method <code>many()</code> on the decoder which returns a <code>Flux&lt;T&gt;</code> publisher.</p>
                    <p>Decoding multiple payload objects is indicated when a client streams content to the server. For instance, it can send a request with <code>application/x-ndjson</code> content type in order to send multiple messages in a single request. Since everything is reactive the server doesn't have to wait for the full request and it can process a message as soon as it is received. What is remarkable is that the code is widely unchanged.</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, WebExchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    Flux&lt;Result&gt; storeBook = exchange.request().body().get()
        .decoder(Book.class)
        .many()
        .map(book -&gt; storeBook(book));
    exchange.response().body()
        .string().stream(storeBook.map(result -&gt; result.getMessage()));
};
</code></pre>
                    <p>Conversion of a multipart form data request body is also supported, the payload of each part being decoded independently based on the content type of the part. For instance we can upload multiple books in multiple files in a <code>multipart/form-data</code> request and decode them on the fly as follows:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, WebExchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    exchange.response()
        .body().string().stream(Flux.from(exchange.request().body().get().multipart().stream()) // 1 
            .flatMap(part -&gt; part.decoder(Book.class).one())                                    // 2 
            .map(book -&gt; storeBook(book))                                                       // 3 
            .map(result -&gt; result.getMessage())                                                 // 4
        );
};
</code></pre>
                    <p>In the previous example:</p>
                    <ol>
                        <li>A stream of files is received in a <code>multipart/form-data</code> request (note that we assume all parts are file parts).</li>
                        <li>Each part is decoded to a <code>Book</code> object, the media type must be specified in the <code>content-type</code> header field of the part.</li>
                        <li>The book object so obtained is processed.</li>
                        <li>The result for each upload is returned to the client.</li>
                    </ol>
                    <p>All this process is done in a reactive way, the first chunk of response can be sent before all parts have been processed.</p>
                    <h6 id="response-body-encoder">Response body encoder</h6>
                    <p>As for the request body, the response body can be encoded based on the content type defined in the response headers. Considering previous example we can do the following:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, WebExchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    Mono&lt;Result&gt; storeBook = exchange.request().body().get()
        .decoder(Book.class)
        .one()
        .map(book -&gt; storeBook(book));
    exchange.response()
        .headers(headers -&gt; headers.contentType(MediaTypes.APPLICATION_JSON))
        .body()
            .encoder(Result.class)
            .one(storeBook);
};
</code></pre>
                    <p>When invoking the <code>encoder()</code> method, a <a href="#media-type-converter">media type converter</a> corresponding to the response content type is selected to encode the payload. The <code>content-type</code> header MUST be specified in the response, otherwise a (500) internal server error is returned indicating an empty media type. If there is no converter corresponding to the media type, a (500) internal server error is returned indicating that no encoder was found matching the content type.</p>
                    <p>A single object is encoded by invoking method <code>one()</code> on the encoder or multiple objects can be encoded by invoking method <code>many()</code> on the encoder. Returning multiple objects in a stream is particularly suitable to implement progressive display in a Web application, for example to display search results as soon as some are available.</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, WebExchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    Flux&lt;SearchResult&gt; searchResults = ...;
    exchange.response()
        .headers(headers -&gt; headers.contentType(MediaTypes.APPLICATION_X_NDJSON))
        .body()
            .encoder(SearchResult.class)
            .many(searchResults);
};
</code></pre>
                    <h6 id="websocket-message-decoderencoder">WebSocket message decoder/encoder</h6>
                    <p>A Web exchange can be upgraded to a Web WebSocket exchange. The <code>Web2SocketExchange</code> thus created extends <code>WebSocketExchange</code> and allows to respectively decode/encode WebSocket inbound and outbound messages based on the subprotocol negotiated during the opening handshake.</p>
                    <p>As for request and response payloads, a <a href="#media-type-converter">media type converter</a> corresponding to the subprotocol is selected to decode/encode inbound and outbound messages. If there is no converter corresponding to the subprotocol, a <code>WebSocketException</code> is thrown resulting in a (500) internal server error returned to the client indicating that no converter was found matching the subprotocol.</p>
                    <p>The subprotocol must then correspond to a valid media type. Unlike request and response payloads which expect strict media type representation, compact <code>application/</code> media type representation can be specified as subprotocol. In practice, it is possible to open a WebSocket connection with subprotocol <code>json</code> to select the <code>application/json</code> media type converter.</p>
                    <blockquote>
                        <p>As defined by <a href="https://datatracker.ietf.org/doc/html/rfc6455">RFC 6455</a>, a WebSocket subprotocol is not a media type and is registered separately, however using media type is very handy in this case as it allows to reuse the data conversion facility. Supporting compact <code>application/</code> media type representation allows to mitigate this specification violation as it is then possible to specify a valid subprotocol while still being able to select a media type converter. Let's consider the registered subprotocol <code>v2.bookings.example.net</code> (taken from <a href="https://datatracker.ietf.org/doc/html/rfc6455#section-1.9">RFC 6455 Section 1.9</a>), we can then create a media type converter for <code>application/v2.bookings.example.net</code> that will be selected when receiving connection for that particular subprotocol.</p>
                    </blockquote>
                    <p>The following example is a variant of the <a href="#a-simple-chat-server">simple chat server</a> which shows how JSON messages can be automatically decoded and encoded:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, WebExchange&lt;ExchangeContext&gt;&gt; handler = exchange -&gt; {
    exchange.webSocket("json")
        .orElseThrow(() -&gt; new InternalServerErrorException("WebSocket not supported"))
        .handler(webSocketExchange -&gt; {
            Flux.from(webSocketExchange.inbound().decodeTextMessages(Message.class)).subscribe(message -&gt; this.chatSink.tryEmitNext(message));
            webSocketExchange.outbound().encodeTextMessages(this.chatSink.asFlux());
        })
        .or(() -&gt; exchange.response()
            .body().string().value("Web socket handshake failed")
        );
};
</code></pre>
                    <h5 id="web-route">Web route</h5>
                    <p>A Web route specifies the routing rules and the exchange handler that shall be invoked to handle a matching exchange. It can combine the following routing rules which are matched in that order: the path, method and content type of the request, the media ranges and language ranges accepted by the client. For instance, a Web exchange is matched against the path routing rule first, then the method routing rule... Multiples routes can then match a given exchange but only one will be retained to actually process the exchange which is the one matching the highest routing rules.</p>
                    <p>If a route doesn't define a particular routing rule, the routing rule is simply ignored and matches all exchanges. For instance, if a route doesn't define any method routing rule, exchanges are matched regardless of the method.</p>
                    <p>The <code>WebRoutable</code> interface defines a fluent API for the definition of Web routes. The following is an example of the definition of a Web route which matches all exchanges, this is the simplest route that can be defined:</p>
                    <pre><code class="language-java">routable
    .route()                                                   // 1
        .handler(exchange -&gt; {                                 // 2
            exchange.response()
                .headers(headers -&gt; 
                    headers.contentType(MediaTypes.TEXT_PLAIN)
                )
                .body()
                .encoder()
                .value("Hello, world!");
        });
</code></pre>
                    <ol>
                        <li>A new <code>WebRouteManager</code> instance is obtained to configure a <code>WebRoute</code></li>
                        <li>We only define the handler of the route as a result any exchange might be routed to that particular route unless a more specific route matching the exchange exists.</li>
                    </ol>
                    <p>An exchange handler can be attached to multiple routes at once by providing multiple routing rules to the route manager, the following example actually results in 8 individual routes being defined:</p>
                    <pre><code class="language-java">routable
    .route()
        .path("/doc")
        .path("/document")
        .method(Method.GET)
        .method(Method.POST)
        .consumes(MediaTypes.APPLICATION_JSON)
        .consumes(MediaTypes.APPLICATION_XML)
        .handler(exchange -&gt; {
            ...
        });
</code></pre>
                    <p>The Web routable also allows to select all routes that matches the rules defined in a Web route manager using the <code>findRoutes()</code> method. The following example select all routes matching <code>GET</code> method:</p>
                    <pre><code class="language-java">Set&lt;WebRoute&lt;ExchangeContext&gt;&gt; routes = router
    .route()
        .method(Method.GET)
        .findRoutes();
</code></pre>
                    <p>It is also possible to enable, disable or remove a set of routes in a similar way:</p>
                    <pre><code class="language-java">// Disables all GET routes
routable
    .route()
        .method(Method.GET)
        .disable();

// Enables all GET routes
routable
    .route()
        .method(Method.GET)
        .enable();

// remove all GET routes
routable
    .route()
        .method(Method.GET)
        .remove();
</code></pre>
                    <p>Individual routes can be enabled, disabled or removed as follows:</p>
                    <pre><code class="language-java">// Disables all GET routes producing 'application/json'
routable
    .route()
        .method(Method.GET)
        .findRoutes()
        .stream()
        .filter(route -&gt; route.getProduce().equals(MediaTypes.APPLICATION_JSON))
        .forEach(WebRoute::disable);

// Enables all GET routes producing 'application/json'
routable
    .route()
        .method(Method.GET)
        .findRoutes()
        .stream()
        .filter(route -&gt; route.getProduce().equals(MediaTypes.APPLICATION_JSON))
        .forEach(WebRoute::enable);

// Removes all GET routes producing 'application/json'
routable
    .route()
        .method(Method.GET)
        .findRoutes()
        .stream()
        .filter(route -&gt; route.getProduce().equals(MediaTypes.APPLICATION_JSON))
        .forEach(WebRoute::remove);
</code></pre>
                    <p>Routes can also be configured as blocks in reusable <code>WebRoutesConfigurer</code> by invoking <code>configureRoutes()</code> methods:</p>
                    <pre><code class="language-java">WebRoutesConfigurer&lt;ExchangeContext&gt; public_routes_configurer = routable -&gt; {
    routable
        .route()
        ...
};

WebRoutesConfigurer&lt;ExchangeContext&gt; private_routes_configurer = routable -&gt; {
    routable
        .route()
        ...
};

routable
    .configureRoutes(public_routes_configurer)
    .configureRoutes(private_routes_configurer)
    .route()
    ...
</code></pre>
                    <h6 id="path-routing-rule">Path routing rule</h6>
                    <p>The path routing rule matches exchanges whose request targets a specific path or a path that matches against a particular pattern. The path or path pattern of a routing rule must be absolute (ie. start with <code>/</code>).</p>
                    <p>We can for instance define a route to handle all requests to <code>/bar/foo</code> as follows:</p>
                    <pre><code class="language-java">routable
    .route()
        .path("/foo/bar")
        .handler(exchange -&gt; {
            ...
        });
</code></pre>
                    <p>The route in the preceding example specifies an exact match for the exchange request path, it is also possible to make the route match the path with or without a trailing slash as follows:</p>
                    <pre><code class="language-java">routable
    .route()
        .path("/foo/bar", true)
        .handler(exchange -&gt; {
            ...
        });
</code></pre>
                    <p>A path pattern following the parameterized or path pattern <a href="#uris">URIs notation</a> can also be specified to create a routing rule matching multiple paths. This also allows to specify <a href="#path-parameters">path parameters</a> that can be retrieved from the <code>WebExchange</code>.</p>
                    <p>In the following example, the route will match all exchanges whose request path is <code>/book/1</code>, <code>/book/abc</code>... and store the extracted parameter value in path parameter <code>id</code>:</p>
                    <pre><code class="language-java">routable
    .route()
        .path("/book/{id}")
        .handler(exchange -&gt; {
            exchange.request().pathParameters().get("id")...
        });
</code></pre>
                    <p>A parameter is matched against a regular expression set to <code>[^/]*</code> by default which is why previous route does not match <code>/book/a/b</code>. Parameterized URIs allow to specify the pattern matched by a particular path parameter using <code>{[&lt;name&gt;][:&lt;pattern&gt;]}</code> notation, we can then put some constraints on path parameters value. For instance, we can make sure the <code>id</code> parameter is a number between 1 and 999:</p>
                    <pre><code class="language-java">routable
    .route()
        .path("/book/{id:[1-9][0-9]{0,2}}")
        .handler(exchange -&gt; {
            ...
        });
</code></pre>
                    <p>If we just want to match a particular path without extracting path parameters, we can omit the parameter name and simply write:</p>
                    <pre><code class="language-java">routable
    .route()
        .path("/book/{}")
        .handler(exchange -&gt; {
            ...
        });
</code></pre>
                    <h6 id="method-routing-rule">Method routing rule</h6>
                    <p>The method routing rule matches exchanges that have been sent with a particular HTTP method.</p>
                    <p>In order to handle all <code>GET</code> exchanges, we can do:</p>
                    <pre><code class="language-java">routable
    .route()
        .method(Method.GET)
        .handler(exchange -&gt; {
            ...
        });
</code></pre>
                    <h6 id="consume-routing-rule">Consume routing rule</h6>
                    <p>The consume routing rule matches exchanges whose request body content type matches a particular media range as defined by <a href="https://tools.ietf.org/html/rfc7231#section-5.3.2">RFC 7231 Section 5.3.2</a>.</p>
                    <p>For instance, in order to match all exchanges with an <code>application/json</code> request payload, we can do:</p>
                    <pre><code class="language-java">routable
    .route()
        .method(Method.POST)
        .consumes(MediaTypes.APPLICATION_JSON)
        .handler(exchange -&gt; {
            ...
        });
</code></pre>
                    <p>We can also specify a media range to match, for example, all exchanges with a <code>*/json</code> request payload:</p>
                    <pre><code class="language-java">routable
    .route()
        .method(Method.POST)
        .consumes("*/json")
        .handler(exchange -&gt; {
            ...
        });
</code></pre>
                    <p>The two previous routes are different and as a result they can be both defined, a content negotiation algorithm is used to determine which route should process a particular exchange as defined in <a href="https://tools.ietf.org/html/rfc7231#section-5.3">RFC 7231 Section 5.3</a>.</p>
                    <p>Routes are sorted by consumed media ranges as follows:</p>
                    <ul>
                        <li>quality value is compared first as defined by <a href="https://tools.ietf.org/html/rfc7231#section-5.3.1">RFC7231 Section 5.3.1</a>, the default quality value is 1.</li>
                        <li>type and subtype wildcards are considered after: <code>a/b</code> &gt; <code>a/*</code> &gt; <code>*/b</code> &gt; <code>*/*</code></li>
                        <li>parameters are considered last, the most precise media range which is the one with the most parameters with matching values gets the highest priority (eg. <code>application/json;p1=a;p2=2</code> &gt; <code>application/json;p1=b</code> &gt; <code>application/json;p1</code>)</li>
                    </ul>
                    <p>The first route whose media range matches the request's <code>content-type</code> header field is selected.</p>
                    <p>If we consider previous routes, an exchange with an <code>application/json</code> request payload will be matched by the first route while an exchange with a <code>text/json</code> request will be matched by the second route.</p>
                    <p>A media range can also be parameterized which allows for interesting setup such as:</p>
                    <pre><code class="language-java">routable
    .route()
        .path("/document")
        .method(Method.POST)
        .consumes("application/json;version=1")
        .handler(exchange -&gt; {
            ...
        })
    .route()
        .path("/document")
        .method(Method.POST)
        .consumes("application/json;version=2")
        .handler(exchange -&gt; {
            ...
        })
    .route()
        .path("/document")
        .method(Method.POST)
        .consumes("application/json")
        .handler(exchange -&gt; {
            ...
        });
</code></pre>
                    <p>In the above example, an exchange with a <code>application/json;version=1</code> request payload is matched by the first route, <code>application/json;version=2</code> request payload is matched by the second route and any other <code>application/json</code> request payload is matched by the third route.</p>
                    <p>If there is no route matching the content type of a request of an exchange matched by previous routing rules, a (415) unsupported media type error is returned.</p>
                    <blockquote>
                        <p>As described before, if no route is defined with a consume routing rule, exchanges are matched regardless of the request content type, content negotiation is then eventually delegated to the handler which must be able to process the payload whatever the content type.</p>
                    </blockquote>
                    <h6 id="produce-routing-rule">Produce routing rule</h6>
                    <p>The produce routing rule matches exchanges based on the acceptable media ranges supplied by the client in the <code>accept</code> header field of the request as defined by <a href="https://tools.ietf.org/html/rfc7231#section-5.3.2">RFC 7231 Section 5.3.2</a>.</p>
                    <p>A HTTP client (eg. Web browser) typically sends an <code>accept</code> header to indicate the server which response media types are acceptable in the response. The best matching route is determined based on the media types produced by the routes matching previous routing rules.</p>
                    <p>We can for instance define the following routes:</p>
                    <pre><code class="language-java">routable
    .route()
        .path("/doc")
        .produces(MediaTypes.APPLICATION_JSON)
        .handler(exchange -&gt; {
            ...
        }) 
    .route()
        .path("/doc")
        .produces(MediaTypes.TEXT_XML)
        .handler(exchange -&gt; {
            ...
        });
</code></pre>
                    <p>Now let's consider the following <code>accept</code> request header field:</p>
                    <pre><code class="language-plaintext">accept: application/json, application/xml;q=0.9, */xml;q=0.8
</code></pre>
                    <p>This field basically tells the server that the client wants to receive first an <code>application/json</code> response payload, if not available an <code>application/xml</code> response payload and if not available any <code>*/xml</code> response payload.</p>
                    <p>The content negotiation algorithm is similar as the one described in the <a href="#consume-routing-rule">consume routing rule</a>, it is simply reversed in the sense that it is the acceptable media ranges defined in the <code>accept</code> header field that are sorted and the route producing the media type matching the media range with the highest priority is selected.</p>
                    <p>Considering previous routes, a request with previous <code>accept</code> header field is then matched by the first route.</p>
                    <p>A request with the following <code>accept</code> header field is matched by the second route:</p>
                    <pre><code class="language-plaintext">accept: application/xml;q=0.9, */xml;q=0.8
</code></pre>
                    <p>The exchange is also matched by the second route with the following <code>accept</code> header field:</p>
                    <pre><code class="language-plaintext">accept: application/json;q=0.5, text/xml;q=1.0
</code></pre>
                    <p>If there is no route producing a media type that matches any of the acceptable media ranges, then a (406) not acceptable error is returned.</p>
                    <blockquote>
                        <p>As described before, if no route is defined with a produce routing rule, exchanges are matched regardless of the acceptable media ranges, content negotiation is then eventually delegated to the handler which becomes responsible to return an acceptable response to the client.</p>
                    </blockquote>
                    <h6 id="language-routing-rule">Language routing rule</h6>
                    <p>The language routing rule matches exchanges based on the acceptable languages supplied by client in the <code>accept-language</code> header field of the request as defined by <a href="https://tools.ietf.org/html/rfc7231#section-5.3.5">RFC 7231 Section 5.3.5</a>.</p>
                    <p>A HTTP client (eg. Web browser) typically sends a <code>accept-language</code> header to indicate the server which languages are acceptable for the response. The best matching route is determined based on the language tags produced by the routes matching previous routing rules.</p>
                    <p>We can defines the following routes to return a particular resource in English or in French:</p>
                    <pre><code class="language-java">routable
    .route()
        .path("/doc")
        .language("en-US")
        .handler(exchange -&gt; {
            ...
        });

routable
    .route()
        .path("/doc")
        .language("fr-FR")
        .handler(exchange -&gt; {
            ...
        });
</code></pre>
                    <p>The content negotiation is similar to the one described in the <a href="#produce-routing-rule">produce routing rule</a> but using language ranges and language types instead of media ranges and media types. Acceptable language ranges are sorted as follows:</p>
                    <ul>
                        <li>quality value is compared first as defined by <a href="https://tools.ietf.org/html/rfc7231#section-5.3.1">RFC 7231 Section 5.3.1</a>, the default quality value is 1.</li>
                        <li>primary and secondary language tags and wildcards are considered after: <code>fr-FR</code> &gt; <code>fr</code> &gt; <code>*</code></li>
                    </ul>
                    <p>The route whose produced language tag matches the language range with the highest priority is selected.</p>
                    <p>As for the produce routing rule, if there is no route defined with a language tag that matches any of the acceptable language ranges, then a (406) not acceptable error is returned. However, unlike the produce routing rule, a default route can be defined to handle such unmatched exchanges.</p>
                    <p>For instance, we can add the following default route to the router:</p>
                    <pre><code class="language-java">routable
    .route()
        .path("/doc")
        .handler(exchange -&gt; {
            ...
        });
</code></pre>
                    <p>A request with the following <code>accept-language</code> header field is then matched by the default route:</p>
                    <pre><code class="language-plaintext">accept-language: it-IT
</code></pre>
                    <h5 id="websocket-route">WebSocket route</h5>
                    <p>The <code>WebRoutable</code> interface also exposes <code>webSocketRoute()</code> which returns a <code>WebSocketRouteManager</code> which allows defining WebSocket routes. A WebSocket route specifies the routing rules and the WebSocket exchange handler that shall be invoked after upgrading a matching exchange to a WebSocket exchange. it can combine the following routing rules which are matched in that order: the path of the request, the language ranges accepted by the client and the supported subprotocol. Unlike a regular Web route, a WebSocket exchange does not support method, consume and produce routing rules, this difference can be explain by the fact that a WebSocket upgrade request is always a <code>GET</code> request and that consumed and produced media types have just no meaning in the context of a WebSocket.</p>
                    <p>When an exchange matches a WebSocket route, the Web router automatically handle the upgrade and setup the WebSocket exchange handler specified in the route. If the WebSocket upgrade is not supported, a <code>WebSocketException</code> is thrown resulting in a (500) internal server error returned to the client.</p>
                    <p>A WebSocket endpoint can then be easily defined as follows:</p>
                    <pre><code class="language-java">routable
    .webSocketRoute()
        .path("/ws")
        .subprotocol("json")
        .handler(webSocketExchange -&gt; {
            webSocketExchange.outbound().messages(factory -&gt; webSocketExchange.inbound().messages());
        });
</code></pre>
                    <p><code>WebSocketRoute</code> extends <code>WebRoute</code>, as a result, just like Web routes, WebSocket routes matching particular rules can be selected, enabled, disabled or removed:</p>
                    <pre><code class="language-java">// Disables all WebSocket routes supporting subprotocol 'json'
routable
    .webSocketRoute()
        .subprotocol("json")
        .findRoutes()
        .stream()
        .forEach(WebSocketRoute::disable);

// Enables all routes (including WebSocket routes) with path matching '/ws'
routable
    .route()
        .path("/ws")
        .enable();
</code></pre>
                    <h6 id="subprotocol-routing-rule">Subprotocol routing rule</h6>
                    <p>The produce routing rule matches exchanges based on the supported subprotocols supplied by the client in the <code>sec-websocket-version</code> header field of the request as defined by <a href="https://datatracker.ietf.org/doc/html/rfc6455">RFC 6455</a>.</p>
                    <p>A HTTP client (eg. Web browser) wishing to open a WebSocket connection typically sends a <code>sec-websocket-version</code> header to indicate the server which subprotocols it supports by order of preference. The best matching route is determined based on the subprotocol supported by the routes matching previous routing rules.</p>
                    <p>We can then define the following WebSocket routes that handle different subprotocols:</p>
                    <pre><code class="language-java">routable
    .webSocketRoute()
        .path("/ws")
        .subprotocol("json")
        .handler(webSocketExchange -&gt; {
            ...
        })
    .webSocketRoute()
        .path("/ws")
        .subprotocol("xml")
        .handler(webSocketExchange -&gt; {
            ...
        })
    .webSocketRoute()
        .path("/ws")
        .handler(webSocketExchange -&gt; {
            ...
        });
</code></pre>
                    <p>Let's consider a request with the following <code>sec-websocket-version</code> header field:</p>
                    <pre><code class="language-plaintext">sec-websocket-version: xml, json
</code></pre>
                    <p>This field basically tells the server that the client wants to open a WebSocket connection using the <code>xml</code> subprotocol and if not supported the <code>json</code> subprotocol. As a result the request is matched by the second route in above example.</p>
                    <p>If there is no route supporting any of the subprotocols provided by the client, an <code>UnsupportedProtocolException</code> is thrown resulting in a (500) internal server error returned to the client. The last route in above example is therefore not a default route, it is only matched when the client open a WebSocket connection with no subprotocol.</p>
                    <h5 id="web-route-interceptor">Web route interceptor</h5>
                    <p>A Web route interceptor specifies the rules and the exchange interceptor that shall be applied to a matching route. It can combine the same rules as for the definition of a route: the path and method of the route, media range matching the content consumed by the route, media range and language range matching the media type and language produced by the route.</p>
                    <p>Multiple web exchange interceptors (i.e. <code>ExchangeInterceptor&lt;ExchangeContext, WebExchange&lt;ExchangeContext&gt;&gt;</code>) can be applied to one or more web routes.</p>
                    <p>The <code>WebInterceptable</code> interface defines a fluent API similar to the <code>WebRoutable</code> for the definition of Web interceptors. The following is an example of the definition of a Web route interceptor that is applied to routes matching <code>GET</code> methods and consuming <code>application/json</code> payloads:</p>
                    <pre><code class="language-java">interceptable.
    .intercept()
        .method(Method.GET)
        .consumes(MediaTypes.APPLICATION_JSON)
        .interceptor(exchange -&gt; {
            LOGGER.info("Intercepted!");
            return Mono.just(exchange);
        });
</code></pre>
                    <p>As for an exchange handler, an exchange interceptor can be applied to multiple routes at once by providing multiple rules to the route interceptor manager, the following example is used to apply a route interceptor to <code>/doc</code> and <code>/document</code> routes consuming <code>application/json</code> or <code>application/xml</code> payloads:</p>
                    <pre><code class="language-java">interceptable
    .intercept()
        .path("/doc")
        .path("/document")
        .consumes(MediaTypes.APPLICATION_JSON)
        .consumes(MediaTypes.APPLICATION_XML)
        .interceptor(exchange -&gt; {
            ...
        });
</code></pre>
                    <p>Multiple interceptors can be applied to a route at once using the <code>interceptors()</code> methods. The following example is equivalent as applying <code>interceptor1</code> then <code>interceptor2</code> on all routes matching <code>/some_path</code> (i.e. <code>interceptor2</code> is then invoked before <code>interceptor1</code>):</p>
                    <pre><code class="language-java">ExchangeInterceptor&lt;ExchangeContext, WebExchange&lt;ExchangeContext&gt;&gt; interceptor1 = ...;
ExchangeInterceptor&lt;ExchangeContext, WebExchange&lt;ExchangeContext&gt;&gt; interceptor2 = ...;

interceptable
    .intercept()
        .path("/some_path")
        .interceptors(List.of(interceptor1, interceptor2));
</code></pre>
                    <p>The list of exchange interceptors applied to a route can be obtained from a <code>WebRoute</code> instance:</p>
                    <pre><code class="language-java">// Use a WebRoutable to find a WebRoute
WebRoute&lt;ExchangeContext&gt; route = ...

List&lt;? extends ExchangeInterceptor&lt;ExchangeContext, WebExchange&lt;ExchangeContext&gt;&gt; routeInterceptors = route.getInterceptors();
</code></pre>
                    <p>In a similar way, it is possible to explicitly set exchange interceptors on a specific <code>WebRoute</code> instance:</p>
                    <pre><code class="language-java">Set&lt;WebRoute&lt;ExchangeContext&gt;&gt; routes = router.getRoutes();

ExchangeInterceptor&lt;ExchangeContext, WebExchange&lt;ExchangeContext&gt;&gt; serverHeaderInterceptor = exchange -&gt; {
    exchange.response()
        .headers(headers -&gt; headers.set(Headers.NAME_SERVER, "Inverno Web Server");

    return Mono.just(exchange);
};

ExchangeInterceptor&lt;ExchangeContext, WebExchange&lt;ExchangeContext&gt;&gt; securityInterceptor = exchange -&gt; {...};

routes.stream().forEach(route -&gt; route.setInterceptors(List.of(serverHeaderInterceptor, securityInterceptor));
</code></pre>
                    <p>Route interceptors can also be configured as blocks in reusable <code>WebInterceptorsConfigurer</code> by invoking <code>configureInterceptors()</code> methods:</p>
                    <pre><code class="language-java">WebInterceptorsConfigurer&lt;ExchangeContext&gt; public_interceptors_configurer = interceptable -&gt; {
    interceptable
        .intercept()
        ...
};

WebInterceptorsConfigurer&lt;ExchangeContext&gt; private_interceptors_configurer = interceptable -&gt; {
    interceptable
        .intercept()
        ...
};

interceptable
    .configureInterceptors(public_interceptors_configurer)
    .configureInterceptors(private_interceptors_configurer)
    .intercept()
    ...
</code></pre>
                    <p>The definition of an interceptor is very similar to the definition of a route, however there are some peculiarities. For instance, a route can only produce one particular type of content in one particular language that are matched by a route interceptor with matching media and language ranges.</p>
                    <p>For performance reasons, route interceptor's rules should not be evaluated each time an exchange is processed but once when a route is defined. Unfortunately, this is not always possible and sometimes some rules have to be evaluated when processing the exchange. This happens when the difference between the set of exhanges matched by a route and the set of exchanges matched by a route interceptor is not empty which basically means that the route matches more exchanges than the route interceptor.</p>
                    <p>In these situations, the actual exchange interceptor is wrapped in order to evaluate the problematic rule on each exchange. A typical example is when a route defines a path pattern (eg. <code>/path/*.jsp</code>) that matches the specific path of a route interceptor (eg. <code>/path/private.jsp</code>), the exchange interceptor must only be invoked on an exchange that matches the route interceptor's path. This can also happens with method and consumes rules.</p>
                    <blockquote>
                        <p>Path patterns are actually very tricky to match <em>offline</em>, the <code>WebInterceptedRouter</code> implementation uses the <code>URIPattern#includes()</code> to determine whether a given URIs set is included into another, when this couldn't be determine with certainty, the exchange interceptor is wrapped. Please refer to the <a href="#uris">URIs</a> documentation for more information.</p>
                    </blockquote>
                    <blockquote>
                        <p>Particular care must be taken when listing the exchange interceptor attached to a route as these are the actual interceptors and not the wrappers. If you set interceptors explicitly on a <code>WebRoute</code> instance, they will be invoked whenever the route is invoked.</p>
                    </blockquote>
                    <p>When a route interceptor is defined with specific produce and language rules, it can only be applied on routes that actually specify matching produce and language rules. Since there is no way to determine which content type and language will be produced by an exchange handler, it is not possible to determine whether an exchange interceptor should be invoked prior to the exchange handler unless specified explicitly on the route. In such case, a warning is logged to indicate that the interceptor is ignored for the route due to missing produce or language rules on the route.</p>
                    <h5 id="web-router">Web router</h5>
                    <p>The <code>WebRouter</code> extends both <code>WebRoutable</code> and <code>WebInterceptable</code> interfaces. As such routes and route interceptors are defined in the <code>WebRouter</code> bean exposed in the <em>web</em> module and used in the web server controller to handle web exchange. This internal web server controller is wired to the <em>http-server</em> module to override the default HTTP server controller.</p>
                    <p>In addition to <code>configureRoutes()</code> and <code>configureInterceptors()</code> methods defined by <code>WebRoutable</code> and <code>WebInterceptable</code>, the <code>WebRouter</code> interface provides <code>configure()</code> methods that accepts <code>WebRouterConfigurer</code> to fluently apply blocks of configuration.</p>
                    <pre><code class="language-java">WebRouter&lt;ExchangeContext&gt; router = ...

WebRouterConfigurer&lt;ExchangeContext&gt; configurer = ...
List&lt;WebRouterConfigurer&lt;ExchangeContext&gt;&gt; configurers = ...

router
    .configure(configurers)
    .configure(configurer)
    .route()
        .handler(exchange -&gt; ...)
</code></pre>
                    <blockquote>
                        <p>Please refer to the <a href="#web-server">Web Server documentation</a> to see in details how to properly configure Web server routes and interceptors.</p>
                    </blockquote>
                    <p>Route interceptors are only applied to routes defined on a <code>WebInterceptedRouter</code> which is obtained by defining one or more route interceptor on the web router. The following example shows how it works:</p>
                    <pre><code class="language-java">router
    .route()
        .path("/public")
        .handler(exchange -&gt; {
            ...
        })
    .intercept()
        .interceptor(exchange -&gt; {
            ...
        })
    .route()
        .path("/private")
        .handler(exchange -&gt; {
            ...
        })
    .getRouter()
    .route()
        .path("/static/**")
        .handler(new StaticHandler&lt;&gt;(resourceService.getResource(URI.create("file:/path/to/web-root/"))));
</code></pre>
                    <p>In the preceding example, only <code>/private</code> route is intercepted, both <code>/public</code> and <code>/static/**</code> routes are not intercepted since they are defined on the original Web router which is not intercepted. Note the call to <code>getRouter()</code> method which returns the original Web router instance and basically <em>rollbacks</em> the interceptors configuration.</p>
                    <p>A Web intercepted router can also be used to apply interceptors to all routes previously defined in a Web router.</p>
                    <pre><code class="language-java">router
    .intercept()
        .method(Method.GET)
        .interceptor(exchange -&gt; {...})
    .applyInterceptors()
</code></pre>
                    <p>In the previous example, all <code>GET</code> routes previsously defined in the Web router will be intercepted.</p>
                    <blockquote>
                        <p>The Web router bean specifies default Web routes and error Web routes created when the router is initialized and therefore not intercepted. You must keep in mind that they exist and if you wish to intercept them, you'll have to explicitly invoke <code>applyInterceptors()</code>.</p>
                    </blockquote>
                    <h5 id="error-web-exchange">Error web exchange</h5>
                    <p>The <em>web</em> module API extends the <a href="#http-server-api">server exchange API</a> defined in the <em>http-server</em> module. It defines the server <code>WebExchange</code> composed of a <code>WebRequest</code>/<code>WebResponse</code> pair in a HTTP communication between a client and a server. These interfaces respectively extends the <code>Exchange</code>, <code>Request</code> and <code>Response</code> interfaces defined in the <em>http-server</em> module. A web exchange handler (i.e. <code>ExchangeHandler&lt;ExchangeContext, WebExchange&lt;ExchangeContext&gt;&gt;</code>) is typically attached to one or more Web routes defined in a <code>WebRouter</code>.</p>
                    <p>The Error Web exchange provides additional functionnalities on top of the exchange such as path parameters and response body encoding based on the content type.</p>
                    <p>As the <code>WebExchange</code>, the <code>ErrorWebExchange</code> exposes a <code>WebResponse</code> which supports automatic response payload encoding based on the content type specified in the response headers. The usage is exactly the same as for the Web server exchange <a href="#response-body-encoder">response body encoder</a>.</p>
                    <p>The following error Web route matches <code>IllegalArgumentException</code> errors for client accepting <code>application/json</code> media type in the response:</p>
                    <pre><code class="language-java">ExchangeHandler&lt;ExchangeContext, ErrorWebExchange&lt;ExchangeContext&gt;&gt; errorHandler = errorExchange -&gt; {
    errorExchange.response()
        .headers(headers -&gt; headers.status(Status.INTERNAL_SERVER_ERROR))
        .body()
        .encoder(Message.class)
        .value(new Message(errorExchange.getError().getMessage()));
};
</code></pre>
                    <h5 id="error-web-route">Error Web route</h5>
                    <p>An Error Web route specifies the routing rules and the error exchange handler that shall be invoked to handle a matching error exchange. Similar to a <a href="#web-route">Web route</a>, it can combine the following routing rules which are matched in that order: the type of error, the path of the request, the media ranges and language ranges accepted by the client.</p>
                    <p>The <code>ErrorWebRoutable</code> interface defines a fluent API for the definition of Error Web routes. The following is an example of the definition of an Error Web route which matches <code>IllegalArgumentException</code> errors for client accepting <code>application/json</code> media type:</p>
                    <pre><code class="language-java">errorRoutable
    .route()
        .error(IllegalArgumentException.class)
        .produces(MediaTypes.APPLICATION_JSON)
        .handler(errorExchange -&gt; 
            errorExchange.response()
                .body()
                .encoder(Message.class)
                .value(new Message("IllegalArgumentException"))
        );
</code></pre>
                    <p>As with a Web routable, the Error Web routable allows to select routes matching specific rules defined in an <code>ErrorWebRouteManager</code> and enable, disable or remove specific routes.</p>
                    <p>The following example disable all routes matching <code>SomeCustomException</code> error type:</p>
                    <pre><code class="language-java">errorRoutable
    .route()
        .error(SomeCustomException.class)
        .disable();
</code></pre>
                    <h6 id="error-type-routing-rule">Error type routing rule</h6>
                    <p>The error type routing rule matches error exchanges whose error is of a particular type.</p>
                    <p>For instance, in order to handle all error exchanges whose error is an instance of <code>SomeCustomException</code>, we can do:</p>
                    <pre><code class="language-java">errorRoutable
    .route()
        .error(SomeCustomException.class)
        .handler(exchange -&gt; {
            ...
        });
</code></pre>
                    <h6 id="produce-routing-rule-1">Produce routing rule</h6>
                    <p>The produce routing rule, when applied to an error route behaves exactly the same as for a <a href="#produce-routing-rule">Web route</a>. It allows to define error handlers that produce responses of different types based on the set of media range accepted by the client.</p>
                    <p>This is particularly useful to returned specific error responses to a particular client in a particular context. For instance, a backend application might want to receive errors in a parseable format like <code>application/json</code> whereas a Web browser might want to receive errors in a human readable format like <code>text/html</code>.</p>
                    <h6 id="language-routing-rule-1">Language routing rule</h6>
                    <p>The language routing rule, when applied to an error route behaves exactly the same as for a <a href="#language-routing-rule">Web route</a>. It allows to define error handlers that produce responses with different languages based on the set of language range accepted by the client fallbacking to the default route when content negotiation did not give any match.</p>
                    <h5 id="error-web-route-interceptor">Error Web route interceptor</h5>
                    <p>Error Web routes can be intercepted in a similar way as for <a href="#web-route-interceptor">Web route</a> by combining the same rules as for the definition of an Error Web route.</p>
                    <p>Multiple Error Web exchange interceptors (i.e. <code>ExchangeInterceptor&lt;ExchangeContext, ErrorWebExchange&lt;ExchangeContext&gt;&gt;</code>) can be applied to one or more Error Web routes.</p>
                    <p>The <code>ErrorWebInterceptable</code> interface defines a fluent API similar to the <code>ErrorWebRoutable</code> for the definition of Error Web interceptors. The following is an example of the definition of an Error Web route interceptor for intercepting Error Web exchange with <code>SomeCustomException</code> errors and <code>/some_path</code> path:</p>
                    <p>̀<code>java errorInterceptable .intercept() .path("/some_path") .error(SomeCustomException.class) .interceptor(errorExchange -&gt; { ... }); ̀</code></p>
                    <p>As for <code>WebRoute</code>, the <code>ErrorWebRoute</code> allows to list the Error interceptors applied to an Error route and explicitly set interceptors:</p>
                    <pre><code class="language-java">// Use an ErrorWebRoutable to find an ErrorWebRoute
ErrorWebRoute&lt;ExchangeContext&gt; errorRoute = ...

List&lt;ExchangeInterceptor&lt;ExchangeContext, ErrorWebExchange&lt;ExchangeContext&gt;&gt;&gt; errorRouteInterceptors = new ArrayList&lt;&gt;(errorRoute.getInterceptors());
errorRouteInterceptors.add(errorExchange -&gt; {
    ...
});

errorRoute.setInterceptors(errorRouteInterceptors);
</code></pre>
                    <p>The <code>ErrorWebInterceptable</code> offers the same features as the <code>WebInterceptable</code> and allows configuring error interceptors as blocks in reusable <code>ErrorWebInterceptorsConfigurer</code> by invoking <code>configureInterceptors()</code> methods:</p>
                    <pre><code class="language-java">ErrorWebInterceptorsConfigurer&lt;ExchangeContext&gt; public_error_interceptors_configurer = errInterceptable -&gt; {
    errInterceptable
        .intercept()
        ...
};

ErrorWebInterceptorsConfigurer&lt;ExchangeContext&gt; private_error_interceptors_configurer = errInterceptable -&gt; {
    errInterceptable
        .intercept()
        ...
};

errorInterceptable
    .configureInterceptors(public_error_interceptors_configurer)
    .configureInterceptors(private_error_interceptors_configurer)
    .intercept()
    ...
</code></pre>
                    <h5 id="error-web-router">Error Web router</h5>
                    <p>The <code>ErrorWebRouter</code> extends both <code>ErrorWebRoutable</code> and <code>ErrorWebInterceptable</code> interfaces. As such Error routes and Error route interceptors are defined in the <code>ErrorWebRouter</code> bean exposed in the <em>web</em> module and used in the web server controller to handle Error Web exchange. This internal web server controller is wired to the <em>http-server</em> module to override the default HTTP server controller.</p>
                    <p>Just like the <code>WebRouter</code> interface, the <code>ErrorWebRouter</code> exposes the <code>configure()</code> method which accepts <code>ErrorWebRouterConfigurer</code> to fluently apply blocks of configuration. The same configuration rules as for the <a href="#web-router">Web router</a> applies:</p>
                    <pre><code class="language-java">ErrorWebRouter&lt;ExchangeContext&gt; errorRouter = ...

ErrorWebRouterConfigurer&lt;ExchangeContext&gt; configurer = ...
List&lt;ErrorWebRouterConfigurer&lt;ExchangeContext&gt;&gt; configurers = ...

router
    .configure(configurers)
    .configure(configurer)
    .intercept()
        .interceptor(errorExchange -&gt; {
            ...
        })
    .applyInterceptors() // Apply interceptor to previously defined Error routes
    .route()
        .path("/intercepted")
        .handler(exchange -&gt; {
            ...
        })
    .getRouter()
    .route()
        .path("/not_intercepted")
        .handler(exchange -&gt; {
            ...
        });
</code></pre>
                    <blockquote>
                        <p>Please refer to the <a href="#web-server">Web Server documentation</a> to see in details how to properly configure Web server error routes and interceptors.</p>
                    </blockquote>
                    <h4 id="web-server">Web Server</h4>
                    <p>The <em>web</em> module composes the <em>http-server</em> module and as a result it requires a <code>NetService</code> and a <code>ResourceService</code>. A set of <a href="#media-type-converter">media type converters</a> is also required for message payload conversion. All these services are provided by the <em>boot</em> module, so one way to create an application with a Web server is to create an Inverno module composing <em>boot</em> and <em>web</em> modules.</p>
                    <pre><code class="language-java">@io.inverno.core.annotation.Module
module io.inverno.example.app_web {
    requires io.inverno.mod.boot;
    requires io.inverno.mod.web;
}
</code></pre>
                    <p>The resulting <em>app_web</em> module, thus created, can then be started as an application as follows:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.core.v1.Application;

public class Main {

    public static void main(String[] args) {
        Application.with(new App_web.Builder()).run();
    }
}
</code></pre>
                    <p>The above example starts a Web server using default configuration which is a HTTP/1.x server with a Web router as root handler and an error router as error handler.</p>
                    <pre><code class="language-plaintext">2021-04-14 11:00:18,308 INFO  [main] i.w.c.v.Application - Inverno is starting...


     ╔════════════════════════════════════════════════════════════════════════════════════════════╗
     ║                      , ~~ ,                                                                ║
     ║                  , '   /\   ' ,                                                            ║
     ║                 , __   \/   __ ,      _                                                    ║
     ║                ,  \_\_\/\/_/_/  ,    | |  ___  _    _  ___   __  ___   ___                 ║
     ║                ,    _\_\/_/_    ,    | | / _ \\ \  / // _ \ / _|/ _ \ / _ \                ║
     ║                ,   __\_/\_\__   ,    | || | | |\ \/ /|  __/| | | | | | |_| |               ║
     ║                 , /_/ /\/\ \_\ ,     |_||_| |_| \__/  \___||_| |_| |_|\___/                ║
     ║                  ,     /\     ,                                                            ║
     ║                    ,   \/   ,                                  -- 1.5.1 --                 ║
     ║                      ' -- '                                                                ║
     ╠════════════════════════════════════════════════════════════════════════════════════════════╣
     ║ Java runtime        : OpenJDK Runtime Environment                                          ║
     ║ Java version        : 16+36-2231                                                           ║
     ║ Java home           : /home/jkuhn/Devel/jdk/jdk-16                                         ║
     ║                                                                                            ║
     ║ Application module  : io.inverno.example.app_web                                           ║
     ║ Application version : 1.0.0-SNAPSHOT                                                       ║
     ║ Application class   : io.inverno.example.app_web.Main                                      ║
     ║                                                                                            ║
     ║ Modules             :                                                                      ║
     ║  ...                                                                                       ║
     ╚════════════════════════════════════════════════════════════════════════════════════════════╝


2021-04-14 11:00:18,313 INFO  [main] i.w.e.a.App_web - Starting Module io.inverno.example.app_web...
2021-04-14 11:00:18,313 INFO  [main] i.w.m.b.Boot - Starting Module io.inverno.mod.boot...
2021-04-14 11:00:18,494 INFO  [main] i.w.m.b.Boot - Module io.inverno.mod.boot started in 181ms
2021-04-14 11:00:18,494 INFO  [main] i.w.m.w.Web - Starting Module io.inverno.mod.web...
2021-04-14 11:00:18,495 INFO  [main] i.w.m.h.s.Server - Starting Module io.inverno.mod.http.server...
2021-04-14 11:00:18,495 INFO  [main] i.w.m.h.b.Base - Starting Module io.inverno.mod.http.base...
2021-04-14 11:00:18,499 INFO  [main] i.w.m.h.b.Base - Module io.inverno.mod.http.base started in 4ms
2021-04-14 11:00:18,570 INFO  [main] i.w.m.h.s.i.HttpServer - HTTP Server (nio) listening on http://0.0.0.0:8080
2021-04-14 11:00:18,570 INFO  [main] i.w.m.h.s.Server - Module io.inverno.mod.http.server started in 75ms
2021-04-14 11:00:18,571 INFO  [main] i.w.m.w.Web - Module io.inverno.mod.web started in 76ms
2021-04-14 11:00:18,571 INFO  [main] i.w.e.a.App_web - Module io.inverno.example.app_web started in 259ms
</code></pre>
                    <p>The Web router doesn't define any routes by default so if we hit the server, a (404) not found error is returned showing the default error Web router in action:</p>
                    <pre><code class="language-plaintext">$ curl -i -H 'accept: application/json' http://locahost:8080
HTTP/1.1 404 Not Found
content-type: application/json
content-length: 47

{"status":"404","path":"/","error":"Not Found"}
</code></pre>
                    <p>Now if you open <code>http://locahost:8080</code> in a Web browser, you should see the following (404) whitelabel error page:</p> <img class="img-fluid shadow mb-4" src="doc/img/404_whitelabel.png" alt="HTTP 404 whitelabel error page" />
                    <h5 id="configuration-3">Configuration</h5>
                    <p>The Web server configuration is done in the the <em>web</em> module configuration <code>WebConfiguration</code> which includes the <em>http-server</em> module configuration <code>HttpServerConfiguration</code>. As for the <em>http-server</em> module, the net service configuration can also be considered to set low level network configuration in the <em>boot</em> module.</p>
                    <p>Let's create the following configuration in the <em>app_web</em> module:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.core.annotation.NestedBean;
import io.inverno.mod.boot.BootConfiguration;
import io.inverno.mod.configuration.Configuration;
import io.inverno.mod.web.WebConfiguration;

@Configuration
public interface App_webConfiguration {

    @NestedBean
    BootConfiguration boot();

    @NestedBean
    WebConfiguration web();
}
</code></pre>
                    <p>The Web server can then be configured. For instance, we can enable HTTP/2 over cleartext, TLS, HTTP compression... as described in the <a href="#http-server">http-server module documentation</a>.</p>
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.core.v1.Application;

public class Main {

    public static void main(String[] args) {
        Application.with(new App_web.Builder()
            .setApp_webConfiguration(
                    App_webConfigurationLoader.load(configuration -&gt; configuration
                        .web(web -&gt; web
                            .http_server(server -&gt; server
                                .server_port(8081)
                                .h2c_enabled(true)
                                .server_event_loop_group_size(4)
                            )
                        )
                    )
                )
        ).run();
    }
}
</code></pre>
                    <h5 id="configuring-the-web-server-controller">Configuring the Web server controller</h5>
                    <p>As explained before, the module specifies a <code>ServerController</code> bean as defined by the <a href="#http-server"><em>http-server</em> module</a> and wired to the HTTP server overriding the default server controller. It is composed of the Web router and the Error Web router beans which respectively route exchanges and error exchanges to the right handlers.</p>
                    <p>The Web server controller bean is private, its Web router and Error Web router are configured by defining a single <code>WebServerControllerConfigurer</code> bean. The <code>WebServerControllerConfigurer</code> interface extends both <code>WebRouterConfigurer</code> and <code>ErrorWebRouterConfigurer</code> and specifies a <code>createContext()</code> method used to initialize the exchange context as specified in <a href="#exchange-context">http-server module documentation</a>. The Web server controller configurer is responsible for configuring routes in the Web server. It is invoked after default routes have been initiliazed but it doesn't replace them, they can however be overridden by defining routes matching the same rules.</p>
                    <h6 id="web-configurers">Web configurers</h6>
                    <p>In a complex application with many route definitions sometimes dispatched into multiple modules and using complex interceptor setup, having a single configuration might not always be ideal and we should prefer defining multiple consistent configurers later aggregated into one Web server controller configurer bean. Following <a href="#web-routing-api">Web routing API documentation</a>, we know routes and interceptors can be configured using a combination of <code>WebRoutesConfigurer</code>, <code>WebInterceptorsConfigurer</code>, <code>WebRouterConfigurer</code>, <code>ErrorWebRoutesConfigurer</code>, <code>ErrorWebInterceptorsConfigurer</code> or <code>ErrorWebRouterConfigurer</code> beans. At compile time, the Inverno Web compiler plugin will then automatically generates a <code>WebServerControllerConfigurer</code> bean that aggregates all these beans into one single configuration. This way we don't have to create a Web server controller configurer bean and we can compose with above configurers which offer more flexibility, particularly in relation to the exchange context.</p>
                    <p>For instance, the Web router and the error Web router can be configured into separate configurer beans in the <em>app_web</em> module as follows:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.core.annotation.Bean;
import io.inverno.mod.base.resource.MediaTypes;
import io.inverno.mod.http.server.ExchangeContext;
import io.inverno.mod.web.WebRouter;
import io.inverno.mod.web.WebRouterConfigurer;

@Bean( visibility = Bean.Visibility.PRIVATE )
public class App_webWebRouterConfigurer implements WebRouterConfigurer&lt;ExchangeContext&gt; {

    @Override
    public void configure(WebRouter&lt;ExchangeContext&gt; router) {
        router
            .route()
                .path("/hello")
                .produces(MediaTypes.TEXT_PLAIN)
                .language("en-US")
                .handler(exchange -&gt; exchange
                    .response()
                        .body()
                        .encoder(String.class)
                        .value("Hello!")
                )
            .route()
                .path("/hello")
                .produces(MediaTypes.TEXT_PLAIN)
                .language("fr-FR")
                .handler(exchange -&gt; exchange
                    .response()
                        .body()
                        .encoder(String.class)
                        .value("Bonjour!")
                )
            .route()
                .path("/custom_exception")
                .handler(exchange -&gt; {
                    throw new SomeCustomException();
                });
    }
}
</code></pre>
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.core.annotation.Bean;
import io.inverno.mod.base.resource.MediaTypes;
import io.inverno.mod.http.base.Status;
import io.inverno.mod.http.base.UnauthorizedException;
import io.inverno.mod.http.base.header.Headers;
import io.inverno.mod.http.server.ExchangeContext;
import io.inverno.mod.web.ErrorWebRouter;
import io.inverno.mod.web.ErrorWebRouterConfigurer;
import reactor.core.publisher.Mono;

@Bean( visibility = Bean.Visibility.PRIVATE )
public class App_webErrorWebRouterConfigurer implements ErrorWebRouterConfigurer&lt;ExchangeContext&gt; {

    @Override
    public void configure(ErrorWebRouter&lt;ExchangeContext&gt; errorRouter) {
        errorRouter
            .route()
                .error(SomeCustomException.class)
                .handler(errorExchange -&gt; errorExchange
                    .response()
                    .headers(headers -&gt; headers
                        .status(Status.BAD_REQUEST)
                        .contentType(MediaTypes.TEXT_PLAIN)
                    )
                    .body()
                    .encoder()
                    .value("A custom exception was raised")
                )
            .intercept()
                .error(UnauthorizedException.class)
                .interceptor(errorExchange -&gt; {
                    errorExchange.response().headers(headers -&gt; headers.add(Headers.NAME_WWW_AUTHENTICATE, "basic realm=inverno"));
                    return Mono.just(errorExchange);
                })
            // We must apply interceptors to intercept error routes defined by default in the web server module
            .applyInterceptors();
    }
}
</code></pre>
                    <p>After compilation, class <code>App_web_WebServerContollerConfigurer</code> aggregating the two configurer beans should have been generated and the corresponding bean wired into the Web server module.</p>
                    <p>Now we can test the application:</p>
                    <pre><code class="language-plaintext">$ curl -i http://locahost:8080/
HTTP/1.1 404 Not Found
content-length: 0
</code></pre>
                    <pre><code class="language-plaintext">$ curl -i http://locahost:8080/hello
HTTP/1.1 200 OK
content-type: text/plain
content-length: 6

Hello!
</code></pre>
                    <pre><code class="language-plaintext">$ curl -i -H 'accept-language: fr' http://locahost:8080/hello
HTTP/1.1 200 OK
content-type: text/plain
content-length: 8

Bonjour!
</code></pre>
                    <pre><code class="language-plaintext">$ curl -i -H 'accept: application/json' http://locahost:8080/hello
HTTP/1.1 406 Not Acceptable
content-type: application/json
content-length: 81

{"status":"406","path":"/hello","error":"Not Acceptable","accept":["text/plain"]}
</code></pre>
                    <pre><code class="language-plaintext">$ curl -i http://locahost:8080/custom_exception
HTTP/1.1 400 Bad Request
content-type: text/plain
content-length: 29

A custom exception was raised
</code></pre>
                    <blockquote>
                        <p>Since Web configurers are all defined as interfaces, you can easily centralize configuration by implementing one or more configurers. For instance, previous configurers could have been defined in one single bean implementing <code>WebRouterConfigurer&lt;ExchangeContext&gt;</code> and <code>ErrorWebRouterConfigurer&lt;ExchangeContext&gt;</code>.</p>
                    </blockquote>
                    <blockquote>
                        <p>Note that it is still possible to use a custom <code>WebServerControllerConfigurer</code> bean instead of the one generated by the Inverno Web compiler plugin. This basically requires to explicitly wire the custom bean into the <em>web</em> module using a <code>@Wire</code> annotation (otherwise compilation will fail indicating a dependency injection conflict as two beans can then be wired to the Web server controller configurer socket). This can be justified when there are specific needs regarding the exchange context. It is however recommended to use the generated configurer which greatly simplifies configuration.</p>
                    </blockquote>
                    <p>When defining Web configurer beans, it is important to make them private inside the module in order to avoid side effects when composing the module as they may interfere with the generated server controller configurer, which already aggregates module's Web configurer beans, resulting in routes being configured twice. Compilation warnings shall be raised when a Web configurer is defined as a public bean.</p>
                    <p>Web configurers are applied by the generated Web server controller configurer in the following order starting by <code>WebInterceptorsConfigurer</code> beans, then <code>WebRouterConfigurer</code> beans and finally <code>WebRoutesConfigurer</code> beans. This basically means that the interceptors defined in <code>WebInterceptorsConfigurer</code> beans in the module will be applied to all routes defined in the module including throse provided in component modules. Although it is possible to define multiple <code>WebInterceptorsConfigurer</code> beans, it is recommended to have only one because the order in which they are injected in the Web server controller configurer is not guaranteed which might be problematic under certain circumstances.</p>
                    <h6 id="exchange-context-1">Exchange context</h6>
                    <p>The exchange context is global to all routes and interceptors, and basically specific to any application as it directly depends on what is expected by the routes and interceptors. Considering a complex application, this can quickly become very tricky. A safe approach would be to define a single global context type for the whole application and use it in all routes and interceptors definitions. Unfortunately we might have to include routes provided by third party modules that can't possibly use that context type. Besides, we might not want to expose the whole context to every routes and interceptors. The exchange context is unique and therefore necessarily global but ideally it should be possible to define different context types corresponding to the routes being defined. For instance, a secured route might require some kind of security context unlike a public route.</p>
                    <p>The exchange context is provided by the Web server controller which basically delegates to the <code>createContext()</code> method of the Web server controller configurer. Since it is generated by the Inverno Web compiler plugin, the plugin must also generate the global context based on the routes and interceptors definitions aggregated in the generated <code>WebServerControllerConfigurer</code> bean.</p>
                    <blockquote>
                        <p>The fact that the <em>web</em> module only accepts one Web server controller configurer guarantees that there will be only one context provider.</p>
                    </blockquote>
                    <p>Let's consider the case of an application which defines routes and interceptors that can use different exchange context depending on their functional area. For instance, we can imagine an application exposing front office and back office services using <code>FrontOfficeContext</code> and <code>BackOfficeContext</code> respectively.</p>
                    <p>Front office routes are then defined to handle exchanges exposing the <code>FrontOfficeContext</code> and back office routes, that may be specified in a completely different module, are defined to handle exchanges exposing the <code>BackOfficeContext</code>.</p>
                    <p>Let's start by defining these contexts and see how the global context is generated by the Inverno Web compiler plugin.</p>
                    <p>Exchange contexts must be defined as interfaces extending <code>ExchangeContext</code>:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web.test;

import io.inverno.mod.http.server.ExchangeContext;

public interface FrontOfficeContext extends ExchangeContext {
    
    void setMarket(String market);
    
    String getMarket();
}
</code></pre>
                    <pre><code class="language-java">package io.inverno.example.app_web.test;

import io.inverno.mod.http.server.ExchangeContext;

public interface BackOfficeContext extends ExchangeContext {

    void setVar(double var);
    
    double getVar();
}
</code></pre>
                    <p>Then we can define different beans to configure front office and back office routers:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.core.annotation.Bean;
import io.inverno.mod.base.resource.MediaTypes;
import io.inverno.mod.http.base.Method;
import io.inverno.mod.web.WebInterceptable;
import io.inverno.mod.web.WebInterceptorsConfigurer;
import io.inverno.mod.web.WebRoutable;
import io.inverno.mod.web.WebRoutesConfigurer;
import reactor.core.publisher.Mono;

@Bean( visibility = Bean.Visibility.PRIVATE )
public class FrontOfficeRouterConfigurer implements WebRoutesConfigurer&lt;FrontOfficeContext&gt;, WebInterceptorsConfigurer&lt;FrontOfficeContext&gt;  {

    @Override
    public void configure(WebRoutable&lt;FrontOfficeContext, ?&gt; routes) {
        routes
            .route()
                .path("/frontOffice")
                .method(Method.GET)
                .handler(exchange -&gt; {
                    exchange.response()
                        .headers(headers -&gt; headers.contentType(MediaTypes.TEXT_PLAIN))	
                        .body().string().value("I've done some stuff on market: " + exchange.context().getMarket());
                });
    }

    @Override
    public void configure(WebInterceptable&lt;FrontOfficeContext, ?&gt; interceptors) {
        interceptors
            .intercept()
                .path("/frontOffice/**")
                .interceptor(exchange -&gt; {
                    // Resolve the market from the request, session or else
                    exchange.context().setMarket("market");
                    return Mono.just(exchange);
                });
    }
}
</code></pre>
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.core.annotation.Bean;
import io.inverno.mod.base.resource.MediaTypes;
import io.inverno.mod.http.base.Method;
import io.inverno.mod.web.WebInterceptable;
import io.inverno.mod.web.WebInterceptorsConfigurer;
import io.inverno.mod.web.WebRoutable;
import io.inverno.mod.web.WebRoutesConfigurer;
import reactor.core.publisher.Mono;

@Bean( visibility = Bean.Visibility.PRIVATE )
public class BackOfficeRouterConfigurer implements WebRoutesConfigurer&lt;BackOfficeContext&gt;, WebInterceptorsConfigurer&lt;BackOfficeContext&gt; {
    
    @Override
    public void configure(WebRoutable&lt;BackOfficeContext, ?&gt; routes) {
        routes
            .route()
                .path("/backOffice")
                .method(Method.GET)
                .handler(exchange -&gt; {
                    exchange.response()
                        .headers(headers -&gt; headers.contentType(MediaTypes.TEXT_PLAIN))	
                        .body().string().value("VaR is: " + exchange.context().getVar());
                });
    }

    @Override
    public void configure(WebInterceptable&lt;BackOfficeContext, ?&gt; interceptors) {
        interceptors
            .intercept()
                .path("/backOffice/**")
                .interceptor(exchange -&gt; {
                    // Resolve the VaR from the request, session or else
                    exchange.context().setVar(1234.5678);				
                    return Mono.just(exchange);
                });
    }
}
</code></pre>
                    <p>Now if we compile the module, the Inverno Web compiler plugin generates interface <code>App_web_WebServerContollerConfigurer.Context</code> inside the generated <code>App_web_WebServerContollerConfigurer</code> which extends all context types encountered while aggregating the configurer beans. It will also implement method <code>createContext()</code> in order to return a concrete implementation of the context:</p>
                    <ul>
                        <li>Getter and setter methods (i.e. <code>T get*()</code> and <code>void set*(T value)</code> methods) are implemented in order be able to set and get data on the context as shown in above examples.</li>
                        <li>Other methods with no default implementation gets a blank implementation (i.e. no-op).</li>
                    </ul>
                    <p>If we open the generated <code>App_web_WebServerContollerConfigurer</code> we should see:</p>
                    <pre><code class="language-java">...
@Override
public Context createContext() {
    return new Context() {
        private String market;
        private double var;

        @Override
        public String getMarket() {
            return this.market;
        }

        @Override
        public void setMarket(String market) {
            this.market = market;
        }

        @Override
        public double getVar() {
            return this.var;
        }

        @Override
        public void setVar(double var) {
            this.var = var;
        }
    };
}

public static interface Context extends BackOfficeContext, FrontOfficeContext, ExchangeContext {}
...
</code></pre>
                    <p>Using such generated context guarantees that the context created by the Web server controller complies with what is expected by route handlers and interceptors. This allows to safely compose mutliple Web modules in an application, developped by separate teams and using different context types.</p>
                    <p>This doesn't come without limitations. For instance, exchange context must be defined as interfaces since multiple inheritance is not supported in Java. If you try to use a class, a compilation error will be raised.</p>
                    <p>Another limitation comes from the fact that it might difficult to define a route that uses many context types, using configurers the only way to achieve this is to create an intermediary interface that extends the required context types. Although this is acceptable, it is not ideal semantically speaking. Hopefully this issue can be mitigated, at least for route definition, when routes are defined in a declarative way in a <a href="#web-controller">Web controller</a> which allows to specify context type using intersection types on the route method (e.g. <code>&lt;T extends FrontOfficeContext &amp; BackOfficeContext&gt;</code>).</p>
                    <p>Finally, the Inverno Web compiler plugin only generates concrete implementations for getter and setter methods which might seem simplistic but actual logic can still be provided using default implementations in the context interface. For example, role based access control can be implemented in a security context as follows:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.mod.http.server.ExchangeContext;
import java.util.Set;

public interface SecurityContext extends ExchangeContext {

    void setRoles(Set&lt;String&gt; roles);
    
    Set&lt;String&gt; getRoles();
    
    default boolean hasRole(String role) {
        return this.getRoles().contains(role);
    }
}
</code></pre>
                    <p>Exposing <code>setRoles()</code> methods to actual services which should only be concerned by controlling access might not be ideal. There are two concerns to consider here: first resolving the roles of the authenticated user and set them into the context which is the responsability of a security interceptor and then controlling the access to a secured service or resource which is the responsability of a service or another security interceptor. Since we can compose multiple configurers using multiple context types automatically aggregated into one server controller configurer we can easily solve that issue by splitting previous security context:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.mod.http.server.ExchangeContext;
import java.util.Set;

public interface SecurityContext extends ExchangeContext {

    Set&lt;String&gt; getRoles();
    
    default boolean hasRole(String role) {
        return this.getRoles().contains(role);
    }
}
</code></pre>
                    <pre><code class="language-java">package io.inverno.example.app_web;

import java.util.Set;

public interface ConfigurableSecurityContext extends SecurityContext {

    void setRoles(Set&lt;String&gt; roles);
}
</code></pre>
                    <p>Particular care must be taken when declaring context types with generics (e.g. <code>Context&lt;A&gt;</code>), we must always make sure that for a given erased type (e.g. <code>Context</code>) there is one type that is assignable to all others which will then be retained during the context type generation. This basically follows Java language specification which prevents from implementing the same interface twice with different arguments as a result the generated context can only implement one which must obviously be assignable to all others. A compilation error shall be reported if inconsistent exchange context types have been defined.</p>
                    <blockquote>
                        <p>In order to avoid any misuse and realize the benefits of the context generation, it is important to understand the purpose of the exchange context and why we choose to have it strongly typed.</p>
                        <p>The exchange context is mainly used to propagate contextual information across the routing chain composed by interceptors and the exchange handler, it is not necessarily meant to expose any logic.</p>
                        <p>Unlike many other frameworks which use untyped map, the exchange context is strongly typed which has many advantages:</p>
                        <ul>
                            <li>static checking can be performed by the compiler,</li>
                            <li>an handler or an interceptor have guarantees over the information exposed in the context (<code>ClassCastException</code> are basically impossible),</li>
                            <li>as we just saw it is also possible to expose some logic using default interface methods,</li>
                            <li>actual services can be exposed right away in the context without having to use error prone string keys or explicit cast.</li>
                        </ul>
                        <p>The generation of the context by the Inverno Web compiler plugin is here to reduce the complexity induced by strong typing as long as above rules are respected.</p>
                    </blockquote>
                    <h5 id="static-handler">Static handler</h5>
                    <p>The <code>StaticHandler</code> is a built-in exchange handler that can be used to define routes for serving static resources resolved with the <a href="#resource-api">Resource API</a>.</p>
                    <p>For instance, we can create a route to serve files stored in a <code>web-root</code> directory as follows:</p>
                    <pre><code class="language-java">router
    .route()
        .path("/static/{path:.*}")                                   // 1
        .handler(new StaticHandler&lt;&gt;(new FileResource("web-root/"))) // 2
</code></pre>
                    <ol>
                        <li>The path must be parameterized with a <code>path</code> parameter which can include <code>/</code>, for the static handler to be able to determine the relative path of the resource in the <code>web-root</code> directory</li>
                        <li>The base resource is defined directly as a <code>FileResource</code>, although it is also possible to use a <code>ResourceService</code> to be more flexible in terms of the kind of resource</li>
                    </ol>
                    <p>The static handler relies on the resource abstraction to resolve resources, as a result, these can be located on the file system, on the class path, on the module path...</p>
                    <p>The static handler also looks for a welcome page when a directory resource is requested. For instance considering the following <code>web-root</code> directory:</p>
                    <pre><code class="language-plaintext">web-root/
├── index.html
└── snowflake.svg
</code></pre>
                    <p>A request to <code>http://127.0.0.1/static/</code> would return the <code>index.html</code> file.</p>
                    <h5 id="100-continue-interceptor">100-continue interceptor</h5>
                    <p>The <code>ContinueInterceptor</code> class which can be used to automatically handles <code>100-continue</code> as defined by <a href="https://tools.ietf.org/html/rfc7231#section-5.1.1">RFC 7231 Section 5.1.1</a>.</p>
                    <pre><code class="language-java">router
    .intercept()
        .interceptor(new ContinueInterceptor())
    .route()
    ...
</code></pre>
                    <blockquote>
                        <p>Note that in order to comply with RFC 7231, an HTTP server must respond with a (100) status to a request with a 100-continue expectation. The <code>ContinueInterceptor</code> allows to automatize this, otherwise it must be done explicitly:</p>
                        <pre><code class="language-java">...
if(exchange.request().headers().contains(Headers.NAME_EXPECT, Headers.VALUE_100_CONTINUE)) {
    exchange.response().sendContinue();
}
...
</code></pre>
                    </blockquote>
                    <h5 id="webjars">WebJars</h5>
                    <p>The <code>WebJarsRoutesConfigurer</code> is a <code>WebRoutesConfigurer</code> implementation used to configure routes to WebJars static resources available on the module path or class path. Paths to the resources are version agnostic: <code>/webjars/{webjar_module}/{path:.*}</code> where <code>{webjar_module}</code> corresponds to the <em>modularized</em> name of the WebJar minus <code>org.webjars</code>. For example the location of the Swagger UI WebJar would be <code>/webjars/swagger.ui/</code>.</p>
                    <p>The <code>WebJarsRoutesConfigurer</code> requires a <code>ResourceService</code> to resolve WebJars resources. WebJars routes can be configured as follows:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.core.annotation.Bean;
import io.inverno.mod.base.resource.ResourceService;
import io.inverno.mod.http.server.ExchangeContext;
import io.inverno.mod.web.WebJarsRoutesConfigurer;
import io.inverno.mod.web.WebRouter;
import io.inverno.mod.web.WebRouterConfigurer;

@Bean
public class App_webWebRouterConfigurer implements WebRouterConfigurer&lt;ExchangeContext&gt; {

    private final ResourceService resourceService;

    public App_webWebRouterConfigurer(ResourceService resourceService) {
        this.resourceService = resourceService;
    }

    @Override
    public void accept(WebRouter&lt;ExchangeContext&gt; router) {
        router
            .configureRoutes(new WebJarsRoutesConfigurer&lt;&gt;(this.resourceService))
            ...
    }
}
</code></pre>
                    <p>Then we can declare WebJars dependencies such as the Swagger UI in the build descriptor:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.webjars&lt;/groupId&gt;
            &lt;artifactId&gt;swagger-ui&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <p>The Swagger UI should be accessible at <code>http://locahost:8080/webjars/swagger.ui/</code>.</p>
                    <p>Sadly WebJars are rarely modular JARs, they are not even named modules which causes several issues when dependencies are specified on the module path. That's why when an application is run or packaged using <a href="https://github.com/inverno-io/inverno-tools">Inverno tools</a>, such dependencies and WebJars in particular are <em>modularized</em>. A WebJar such as <code>swagger-ui</code> is modularized into <code>org.webjars.swagger.ui</code> module which explains why it is referred to by its module name: <code>swagger.ui</code> in the WebJars resource path (the <code>org.webjars</code> part is omitted since the context is known).</p>
                    <p>When running a fully modular Inverno application, <em>modularized</em> WebJars modules must be added explicitly to the JVM using the <code>--add-modules</code> option, otherwise they are not resolved when the JVM starts. For instance:</p>
                    <pre><code class="language-plaintext">$ java --add-modules org.webjars.swagger.ui ...
</code></pre>
                    <p>Hopefully, the Inverno Maven plugin adds unnamed modules by default when running or packaging an application, so you shouldn't have to worry about it. The following command automatically adds the unnamed modules when running the JVM:</p>
                    <pre><code class="language-plaintext">$ mvn inverno:run
</code></pre>
                    <p>This can be disabled in order to manually control which modules should be added:</p>
                    <pre><code class="language-plaintext">$ mvn inverno:run -Dinverno.exec.addUnnamedModules=false -Dinverno.exec.vmOptions="--add-modules org.webjars.swagger.ui"
</code></pre>
                    <blockquote>
                        <p>It might also be possible to define the dependency in the module descriptor, unfortunately since WebJars modules are unnamed, they are named after the name of the JAR file which is greatly unstable and can't be trusted, so previous approach is by far the safest. If you need to create a WebJar you should make it a named module with the <code>Automatic-Module-Name</code> attribute sets to <code>org.webjars.{webjar_module}</code> in the manifest file and with resources located under <code>META-INF/resources/webjars/{webjar_module}/{webjar_version}/</code>.</p>
                    </blockquote>
                    <p>Note that when the application is run with non-modular WebJars specified on the class path, they can be accessed without any particular configuration as part of the UNNAMED module using the same path notation.</p>
                    <h5 id="openapi-specification">OpenAPI specification</h5>
                    <p>The <code>OpenApiRoutesConfigurer</code> is a <code>WebRoutesConfigurer</code> implementation used to configure routes to <a href="https://www.openapis.org/">OpenAPI specifications</a> defined in <code>/META-INF/inverno/web/openapi.yml</code> resources in application modules.</p>
                    <p>OpenAPI routes can be configured on the Web router as follows:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.core.annotation.Bean;
import io.inverno.mod.base.resource.ResourceService;
import io.inverno.mod.http.server.ExchangeContext;
import io.inverno.mod.web.OpenApiRoutesConfigurer;
import io.inverno.mod.web.WebRouter;
import io.inverno.mod.web.WebRouterConfigurer;

@Bean
public class App_webWebRouterConfigurer implements WebRouterConfigurer&lt;ExchangeContext&gt; {

    private final ResourceService resourceService;

    public App_webWebRouterConfigurer(ResourceService resourceService) {
        this.resourceService = resourceService;
    }

    @Override
    public void accept(WebRouter&lt;ExchangeContext&gt; router) {
        router
            .configureRoutes(new OpenApiRoutesConfigurer&lt;&gt;(this.resourceService))
            ...
    }
}
</code></pre>
                    <p>The configurer will scan for OpenAPI specifications files <code>/META-INF/inverno/web/openapi.yml</code> in the application modules and configure the following routes:</p>
                    <ul>
                        <li><code>/open-api</code> returning the list of available OpenAPI specifications in <code>application/json</code></li>
                        <li><code>/open-api/{moduleName}</code> returning the OpenAPI specifications defined for the specified module name or (404) not found error if there is no OpenAPI specification defined in the module or no module with that name.</li>
                    </ul>
                    <p>By default the configurer also configures these routes to display OpenAPI specifications in a <a href="https://swagger.io/tools/swagger-ui/">Swagger UI</a> when accessed from a Web browser (ie. with <code>accept: text/html</code>) assuming the Swagger UI WebJar dependency is present:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.webjars&lt;/groupId&gt;
            &lt;artifactId&gt;swagger-ui&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <p>Swagger UI support can be disabled from the <code>OpenApiRoutesConfigurer</code> constructor:</p>
                    <pre><code class="language-java">router
    .configureRoutes(new OpenApiRoutesConfigurer&lt;&gt;(this.resourceService, false))
    ...
</code></pre>
                    <blockquote>
                        <p>OpenAPI specifications are usually automatically generated by the Web Inverno compiler plugin for routes defined in a <a href="#web-controller">Web controller</a> but you can provide manual or generated specifications using the tool of your choice, as long as it is not conflicting with the Web compiler plugin.</p>
                    </blockquote>
                    <h4 id="web-controller">Web Controller</h4>
                    <p>The <a href="#web-routing-api">Web routing API</a> provides a <em>programmatic</em> way of defining the Web routes of a Web server but it also provides a set of annotations for defining Web routes in a more declarative way.</p>
                    <p>A <strong>Web controller</strong> is a regular module bean annotated with <code>@WebController</code> which defines methods annotated with <code>@WebRoute</code> describing Web routes. These beans are scanned at compile time by the Inverno Web compiler plugin in order to include corresponding <em>programmatic</em> configuration in the generated Web server controller configurer.</p>
                    <p>For instance, in order to create a book resource with basic CRUD operations, we can start by defining a <code>Book</code> model in a dedicated <code>*.dto</code> package (we'll see later why this matters):</p>
                    <pre><code class="language-java">package io.inverno.example.app_web.dto;

public class Book {

    private String isbn;
    private String title;
    private String author;
    private int pages;
    
    // Constructor, getters, setters, hashcode, equals...
}
</code></pre>
                    <p>Now we can define a <code>BookResource</code> Web controller as follows:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web;

import java.util.Set;

import io.inverno.core.annotation.Bean;
import io.inverno.example.app_web.dto.Book;
import io.inverno.mod.base.resource.MediaTypes;
import io.inverno.mod.http.base.Method;
import io.inverno.mod.web.annotation.Body;
import io.inverno.mod.web.annotation.PathParam;
import io.inverno.mod.web.annotation.WebController;
import io.inverno.mod.web.annotation.WebRoute;

@Bean( visibility = Bean.Visibility.PRIVATE )                                                  // 1
@WebController( path = "/book" )                                                               // 2
public class BookResource {

    @WebRoute( method = Method.POST, consumes = MediaTypes.APPLICATION_JSON )                  // 3
    public void create(@Body Book book) {                                                      // 4
        ...
    }
    
    @WebRoute( path = "/{isbn}", method = Method.PUT, consumes = MediaTypes.APPLICATION_JSON )
    public void update(@PathParam String isbn, @Body Book book) {
        ...
    }
    
    @WebRoute( method = Method.GET, produces = MediaTypes.APPLICATION_JSON )
    public Set&lt;Book&gt; list() {
        ...
    }
    
    @WebRoute( path = "/{isbn}", method = Method.GET, produces = MediaTypes.APPLICATION_JSON )
    public Book get(@PathParam String isbn) {
        ...
    }
    
    @WebRoute( path = "/{isbn}", method = Method.DELETE )
    public void delete(@PathParam String isbn) {
        ...
    }
}
</code></pre>
                    <p>Implementations details have been omitted for clarity, here is what's important:</p>
                    <ol>
                        <li>A Web controller must be a module bean because it will be wired into the generated Web router configurer and used to invoke the right handler method attached to a Web route. Besides this is convenient for implementation as it allows a repository to be wired into the <code>BookResource</code> bean for instance.</li>
                        <li>The <code>@WebController</code> annotation tells the Web compiler plugin to process the bean as a Web controller. The controller root path can also be specified in this annotation, if not specified it defaults to <code>/</code> which is the root path of the Web server.</li>
                        <li>The <code>@WebRoute</code> annotation on a method tells the Web compiler plugin to define a route whose handler should invoke that method. The set of routing rules (ie. path, method, consume, produce, language) describing the route can all be specified in the annotation.</li>
                        <li>Request Parameters and body are specified as method parameters annotated with <code>@CookieParam</code>, <code>@FormParam</code>, <code>@HeaderParam</code>, <code>@PathParam</code>, <code>@QueryParam</code> and <code>@Body</code> annotations.</li>
                    </ol>
                    <p>Some other contextual objects like the underlying <code>WebExchange</code> or the exchange context can also be injected in the Web controller method.</p>
                    <p>Assuming we have provided proper implementations to create, update, list, get and delete a book in a data store, we can compile the module. The generated Web server controller configurer bean should configure the routes corresponding to the Web controller's annotated methods in the Web router. The generated class uses the same APIs described before, it is perfectly readable and debuggable and above all it eliminates the overhead of resolving Web controllers or Web routes at runtime.</p>
                    <p>Now let's go back to the <code>Book</code> DTO, we said earlier that it must be created in a dedicated package, the reason is actually quite simple. Since above routes consume and produce <code>application/json</code> payloads, the <code>application/json</code> media type converter will be invoked to convert <code>Book</code> objects from/to JSON data. This converter uses an <code>ObjectMapper</code> object from module <code>com.fasterxml.jackson.databind</code> which uses reflection to instantiate the objects and populate them from a parsed JSON tree. Unfortunately or hopefully the Java modular system prevents unauthorized reflective access and as a result the <code>ObjectMapper</code> can't access the <code>Book</code> class unless we explicitly export the package containing DTOs to module <code>com.fasterxml.jackson.databind</code> in the module descriptor as follows:</p>
                    <pre><code class="language-java">module io.inverno.example.app_web {
    ...    
    exports io.inverno.example.app_web.dto to com.fasterxml.jackson.databind;
}
</code></pre>
                    <p>Using a dedicated package for DTOs allows then to limit and control the access to the module classes.</p>
                    <blockquote>
                        <p>If you're not familiar with the Java modular system and used to Java 8&lt;, you might find this a bit distressing but if you want to better structure and secure your applications, this is the way.</p>
                    </blockquote>
                    <p>We can now run the application and test the book resource:</p>
                    <pre><code class="language-plaintext">$ curl -i http://localhost:8080/book
HTTP/1.1 200 OK
content-type: application/json
content-length: 2

[]
</code></pre>
                    <pre><code class="language-plaintext">$ curl -i -X POST -H 'content-type: application/json' -d '{"isbn":"978-0132143011","title":"Distributed Systems: Concepts and Design","author":"George Coulouris, Jean Dollimore, Tim Kindberg, Gordon Blair","pages":1080}' http://localhost:8080/book
HTTP/1.1 200 OK
content-length: 0

</code></pre>
                    <pre><code class="language-plaintext">$ curl -i http://localhost:8080/book
HTTP/1.1 200 OK
content-type: application/json
content-length: 163

[{"isbn":"978-0132143011","title":"Distributed Systems: Concepts and Design","author":"George Coulouris, Jean Dollimore, Tim Kindberg, Gordon Blair","pages":1080}]
</code></pre>
                    <pre><code class="language-plaintext">$ curl -i http://localhost:8080/book/978-0132143011
HTTP/1.1 200 OK
content-type: application/json
content-length: 161

{"isbn":"978-0132143011","title":"Distributed Systems: Concepts and Design","author":"George Coulouris, Jean Dollimore, Tim Kindberg, Gordon Blair","pages":1080}
</code></pre>
                    <p>It is possible to separate the API from the implementation by defining the Web controller and the Web routes in an interface implemented in a module bean. For instance:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.example.app_web.dto.Book;
import io.inverno.mod.base.resource.MediaTypes;
import io.inverno.mod.http.base.Method;
import io.inverno.mod.web.annotation.Body;
import io.inverno.mod.web.annotation.PathParam;
import io.inverno.mod.web.annotation.WebController;
import io.inverno.mod.web.annotation.WebRoute;
import java.util.Set;

@WebController( path = "/book" )
public interface BookResource {

    @WebRoute( method = Method.POST, consumes = MediaTypes.APPLICATION_JSON )
    void create(@Body Book book);
    
    @WebRoute( path = "/{isbn}", method = Method.PUT, consumes = MediaTypes.APPLICATION_JSON )
    void update(@PathParam String isbn, @Body Book book);
    
    @WebRoute( method = Method.GET, produces = MediaTypes.APPLICATION_JSON )
    Set&lt;Book&gt; list();
    
    @WebRoute( path = "/{isbn}", method = Method.GET, produces = MediaTypes.APPLICATION_JSON )
    Book get(@PathParam String isbn);
    
    @WebRoute( path = "/{isbn}", method = Method.DELETE )
    void delete(@PathParam String isbn);
}
</code></pre>
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.core.annotation.Bean;
import io.inverno.example.app_web.dto.Book;
import io.inverno.mod.http.base.BadRequestException;
import io.inverno.mod.http.base.NotFoundException;
import io.inverno.mod.web.annotation.Body;
import io.inverno.mod.web.annotation.PathParam;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

@Bean( visibility = Bean.Visibility.PRIVATE )
public class BookResourceImpl implements BookResource {

    @Override
    public void create(@Body Book book) {
        ...
    }
    
    @Override
    public void update(@PathParam String isbn, @Body Book book) {
        ...
    }
    
    @Override
    public Set&lt;Book&gt; list() {
        ...
    }
    
    @Override
    public Book get(@PathParam String isbn) {
        ...
    }
    
    @Override
    public void delete(@PathParam String isbn) {
        ...
    }
}
</code></pre>
                    <p>This provides better modularity and allows defining the API in a dedicated module which can later be used to implement various server and/or client implementations in different modules. Another advantage is that it allows to split a Web controller interface into multiple interfaces.</p>
                    <p>Generics are also supported, we can for instance create the following generic <code>CRUD&lt;T&gt;</code> interface:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.mod.base.resource.MediaTypes;
import io.inverno.mod.http.base.Method;
import io.inverno.mod.web.annotation.Body;
import io.inverno.mod.web.annotation.PathParam;
import io.inverno.mod.web.annotation.WebRoute;
import java.util.Set;

public interface CRUD&lt;T&gt; {

    @WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_JSON)
    void create(@Body T resource);
    
    @WebRoute(path = "/{id}", method = Method.PUT, consumes = MediaTypes.APPLICATION_JSON)
    void update(@PathParam String id, @Body T resource);
    
    @WebRoute(method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
    Set&lt;T&gt; list();
    
    @WebRoute(path = "/{id}", method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
    T get(@PathParam String id);
    
    @WebRoute(path = "/{id}", method = Method.DELETE)
    void delete(@PathParam String id);
}
</code></pre>
                    <p>And then create multiple specific resources using that interface:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.example.app_web.dto.Book;
import io.inverno.mod.web.annotation.WebController;

@WebController(path = "/book")
public interface BookResource extends CRUD&lt;Book&gt; {

}
</code></pre>
                    <p>The book resource as we defined it doesn't seem very reactive, this statement is both true and untrue: the API and the Web server are fully reactive, as a result Web routes declared in the book resource Web controller are configured using a reactive API in the generated Web server controller configurer, nonetheless the methods in the Web controller are not reactive.</p>
                    <p>Luckily, we can easily transform previous interface and make it fully reactive:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.mod.base.resource.MediaTypes;
import io.inverno.mod.http.base.Method;
import io.inverno.mod.web.annotation.Body;
import io.inverno.mod.web.annotation.PathParam;
import io.inverno.mod.web.annotation.WebRoute;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

public interface CRUD&lt;T&gt; {

    @WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_JSON)
    Mono&lt;Void&gt; create(@Body Mono&lt;T&gt; resource);
    
    @WebRoute(path = "/{id}", method = Method.PUT, consumes = MediaTypes.APPLICATION_JSON)
    Mono&lt;Void&gt; update(@PathParam String id, @Body Mono&lt;T&gt; resource);
    
    @WebRoute(method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
    Flux&lt;T&gt; list();
    
    @WebRoute(path = "/{id}", method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
    Mono&lt;T&gt; get(@PathParam String id);
    
    @WebRoute(path = "/{id}", method = Method.DELETE)
    Mono&lt;Void&gt; delete(@PathParam String id);
}
</code></pre>
                    <p>There is one remaining thing to do to make the book resource a proper REST resource. When creating a book we must return a 201 Created HTTP code with a <code>location</code> header as defined by <a href="https://tools.ietf.org/html/rfc7231#section-7.1.2">RFC7231 Section 7.1.2</a>. This can be done by injecting the <code>WebExchange</code> directly in the <code>create()</code> method:</p>
                    <pre><code class="language-java">public interface CRUD&lt;T&gt; {

    @WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_JSON, produces = MediaTypes.APPLICATION_JSON)
    Mono&lt;Void&gt; create(@Body Mono&lt;T&gt; resource, WebExchange&lt;?&gt; exchange);
    ...
}
</code></pre>
                    <p>We can then do the following in the book resource implementation to set the status and <code>location</code> header:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.core.annotation.Bean;
import io.inverno.example.app_web.dto.Book;
import io.inverno.mod.http.base.Status;
import io.inverno.mod.http.base.header.Headers;
import io.inverno.mod.web.WebExchange;
import reactor.core.publisher.Mono;

@Bean
public class BookResourceImpl implements BookResource {

    @Override
    public Mono&lt;Void&gt; create(Mono&lt;Book&gt; book, WebExchange&lt;?&gt; exchange) {
        ...
        exchange.response().headers(headers -&gt; headers
            .status(Status.CREATED)
            .add(Headers.NAME_LOCATION, exchange.request().getPathBuilder().segment(b.getIsbn()).buildPath())
        );
        ...
    }
    ...
}
</code></pre>
                    <p>Now if we run the application and create a book resource we should get the following:</p>
                    <pre><code class="language-plaintext">$ curl -i -X POST -H 'content-type: application/json' -d '{"isbn":"978-0132143011","title":"Distributed Systems: Concepts and Design","author":"George Coulouris, Jean Dollimore, Tim Kindberg, Gordon Blair","pages":1080}' http://locahost:8080/book
HTTP/1.1 201 Created
content-type: application/json
location: /book/978-0132143012
content-length: 0
</code></pre>
                    <p>Declarative routes are configured last in the generated Web server controller configurer which means they override any route prevously defined in a Web configurer but above all they are intercepted by the interceptors defined in <code>WebInterceptorsConfigurer</code> beans in the module.</p>
                    <h5 id="declarative-web-route">Declarative Web route</h5>
                    <p>So far, we have described a concrete Web controller use case which should already give a good idea on how to configure route in a declarative way. Now, let's examine in details how a Web route is declared in a Web controller.</p>
                    <p>A Web route or HTTP endpoint or REST endpoint... in short an HTTP request/response exchange is essentially defined by:</p>
                    <ul>
                        <li>An input, basically an HTTP request characterized by the following components: path, method, query parameters, headers, cookies, path parameters, request body.</li>
                        <li>A normal output, basically a successful HTTP response and more precisely: a status (2xx or 3xx), headers and a response body.</li>
                        <li>A set of error outputs, basically unsuccessful HTTP responses and more precisely: a status (4xx or 5xx), headers and a response body.</li>
                    </ul>
                    <p>Web routes are defined as methods in a Web controller which match this definition: the Web route input is defined as method parameters, the Web route normal output is defined by the return type of the method and finally the exceptions thrown by the method define the Web route error outputs.</p>
                    <p>It then remains to bind the Web route semantic to the method, this is done using various annotations on the method and its parameters.</p>
                    <h6 id="routing-rules">Routing rules</h6>
                    <p>Routing rules, as defined in the <a href="#web-route">Web routing API</a>, are specified in a single <code>@WebRoute</code> annotation on a Web controller method. It allows to define paths, methods, consumed media ranges, produced media types and produced languages of the Web routes that route a matching request to the handler implemented by the method.</p>
                    <p>For instance, we can define multiple paths and/or multiple produced media types in order to expose a resource at different locations in various formats:</p>
                    <pre><code class="language-java">@WebRoute( path = { "/book/current", "/book/v1" }, produces = { MediaTypes.APPLICATION_JSON, MediaTypes.APPLICATION_XML } )
Flux&lt;T&gt; list();
</code></pre>
                    <p>The <code>matchTrailingSlash</code> parameter can be used to indicate that the defined paths should be matched taking the trailing slash into account or not.</p>
                    <blockquote>
                        <p>Note that this exactly corresponds to the <a href="#web-routing-api">Web routing API</a>.</p>
                    </blockquote>
                    <h6 id="parameter-bindings">Parameter bindings</h6>
                    <p>As stated above, a <code>@WebRoute</code> annotated method must be bound to a Web exchange. In particular, method parameters are bound to the various elements of the request using <code>@*Param</code> annotations defined in the Web routing API.</p>
                    <p>Such parameters can be of any type, as long as the parameter converter plugged into the <em>web</em> module can convert it, otherwise a <code>ConverterException</code> is thrown. The default parameter converter provided in the <em>boot</em> module is able to convert primitive and common types including arrays and collections. Please refer to the <a href="#extending-http-services">HTTP server documentation</a> to learn how to extend the parameter converter to convert custom types.</p>
                    <p>In the following example, the value or values of query parameter <code>isbns</code> is converted to an array of strings:</p>
                    <pre><code class="language-java">@WebRoute( path = { "/book/byIsbn" }, produces = { MediaTypes.APPLICATION_JSON } )
Flux&lt;T&gt; getBooksByIsbn(@QueryParam String[] isbns);
</code></pre>
                    <p>If the above route is queried with <code>/book/byIsbn?isbns=978-0132143011,978-0132143012,978-0132143013&amp;isbns=978-0132143014</code> the <code>isbns</code> parameter is then: <code>["978-0132143011", "978-0132143012", "978-0132143013", "978-0132143014"]</code>.</p>
                    <p>A parameter defined like this is required by default and a <code>MissingRequiredParameterException</code> is thrown if one or more parameters are missing from the request but it can be declared as optional by defining it as an <code>Optional&lt;T&gt;</code>:</p>
                    <p>In the following example, query parameter <code>limit</code> is optional and no exception will be thrown if it is missing from the request:</p>
                    <pre><code class="language-java">@WebRoute( path = { "/book" }, produces = { MediaTypes.APPLICATION_JSON } )
Flux&lt;T&gt; getBooks(@QueryParam Optional&lt;Integer&gt; limit);
</code></pre>
                    <p><em>Query parameter</em></p>
                    <p>Query parameters are declared using the <code>@QueryParam</code> annotation as follows:</p>
                    <pre><code class="language-java">@WebRoute( path = { "/book/byIsbn" }, produces = { MediaTypes.APPLICATION_JSON } )
Flux&lt;T&gt; getBooksByIsbn(@QueryParam String[] isbns);
</code></pre>
                    <p>Note that the name of the method parameter actually defines the name of the query parameter.</p>
                    <blockquote>
                        <p>This contrasts with other RESTful API, such as JAX-RS, which requires to specify the parameter name, again, in the annotation. Since the Inverno Web compiler plugin works at compile time, it has access to actual method parameter names defined in the source.</p>
                    </blockquote>
                    <p><em>Path parameter</em></p>
                    <p>Path parameters are declared using the <code>@PathParam</code> annotation as follows:</p>
                    <pre><code class="language-java">@WebRoute(path = "/{id}", method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
Mono&lt;T&gt; get(@PathParam String id);
</code></pre>
                    <p>Note that the name of the method parameter must match the name of the path parameter of the route path defined in the <code>@WebRoute</code> annotation.</p>
                    <p><em>Cookie parameter</em></p>
                    <p>It is possible to bind cookie values as well using the <code>@cookieParam</code> annotation as follows:</p>
                    <pre><code class="language-java">@WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_JSON)
Mono&lt;Void&gt; create(@CookieParam String book_store, @Body Mono&lt;T&gt; book, WebExchange exchange);
</code></pre>
                    <p>In previous example, the route must be queried with a <code>book_store</code> cookie which is not declared as optional:</p>
                    <pre><code class="language-plaintext">$ curl -i -X POST -H 'cookie: book_store=store1' -H 'content-type: application/json' -d '...' http://locahost:8080/book
...
</code></pre>
                    <p><em>Header parameter</em></p>
                    <p>Header field can also be bound using the <code>@HeaderParam</code> annotation as follows:</p>
                    <pre><code class="language-java">@WebRoute(method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
Flux&lt;T&gt; list(@HeaderParam Optional&lt;Format&gt; format);
</code></pre>
                    <p>In previous example, the <code>Format</code> type is an enumeration indicating how book references must be returned (eg. <code>SHORT</code>, <code>FULL</code>...), a <code>format</code> header may or may not be added to the request since it is declared as optional:</p>
                    <pre><code class="language-plaintext">$ curl -i -H 'format: SHORT' http://locahost:8080/book
...
</code></pre>
                    <p><em>Form parameter</em></p>
                    <p>Form parameters are bound using the <code>@FormParam</code> annotation as follows:</p>
                    <pre><code class="language-java">@WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_X_WWW_FORM_URLENCODED)
Mono&lt;Void&gt; createAuthor(
    @FormParam String forename, 
    @FormParam Optional&lt;String&gt; middlename, 
    @FormParam String surname, 
    @FormParam LocalDate birthdate, 
    @FormParam Optional&lt;LocalDate&gt; deathdate, 
    @FormParam String nationality);
</code></pre>
                    <p>Form parameters are sent in a request body following <code>application/x-www-form-urlencoded</code> format as defined by <a href="https://url.spec.whatwg.org/#application/x-www-form-urlencoded">living standard</a>. They can be sent using a HTML form submitted to the server resulting in the following request body:</p>
                    <pre><code class="language-plaintext">forename=Leslie,middlename=B.,surname=Lamport,birthdate=19410207,nationality=US
</code></pre>
                    <p>Previous route can then be queried as follows:</p>
                    <pre><code class="language-plaintext">$ curl -i -X POST -H 'content-type:application/x-www-form-urlencoded' -d 'forename=Leslie,middlename=B.,surname=Lamport,birthdate=19410207,nationality=US' http://locahost:8080/author
</code></pre>
                    <p>Form parameters results from the parsing of the request body and as such, <code>@FormParam</code> annotations can't be used together with <code>@Body</code> on route method parameters.</p>
                    <h6 id="contextual-parameters">Contextual parameters</h6>
                    <p>A contextual parameter is directly related to the context into which an exchange is processed in the route method, it can be injected in the route method by specifying a method parameter of a supported contextual parameter type.</p>
                    <p><em>WebExchange</em></p>
                    <p>The underlying Web exchange can be injected by specifying a method parameter of a type assignable from <code>WebExchange</code>.</p>
                    <pre><code class="language-java">@WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_JSON)
Mono&lt;Void&gt; create(@Body Mono&lt;T&gt; resource, WebExchange&lt;?&gt; exchange) throws BadRequestException;
</code></pre>
                    <blockquote>
                        <p>The exchange gives full access to the underlying request and response. Although it allows to manipulate the request and response bodies, this might conflict with the generated Web route and as a result the exchange should only be used to access request parameters, headers, cookies... or specify a specific response status, response cookies or headers...</p>
                    </blockquote>
                    <p>The Web exchange also gives access to the exchange context, if a route handler requires a particular context type, it can be specified as a type parameter as follows:</p>
                    <pre><code class="language-java">@WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_JSON)
Mono&lt;Void&gt; create(@Body Mono&lt;T&gt; resource, WebExchange&lt;SecurityContext&gt; exchange) throws BadRequestException;
</code></pre>
                    <p>Context types declared in a declarative Web route are aggregated in the Web server controller configurer by the Inverno Web compiler plugin in the same way as for Web server <a href="#configuring-the-web-server-controller">configurers</a>. However declarative Web routes make it possible to use interaction types when multiple context types are expected using a type variable which brings more flexibility.</p>
                    <pre><code class="language-java">@WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_JSON)
&lt;E extends TracingContext &amp; SecurityContext&gt; Mono&lt;Void&gt; create(@Body Mono&lt;T&gt; resource, WebExchange&lt;E&gt; exchange) throws BadRequestException;
</code></pre>
                    <p>When declaring generic context types, we must make sure they are all consistent (i.e. there is one type that is assignable to all others). When declaring a route using generic context type, it is then good practice to use upper bound wildcards as follows:</p>
                    <pre><code class="language-java">@WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_JSON)
Mono&lt;Void&gt; create(@Body Mono&lt;T&gt; resource, WebExchange&lt;SecurityContext&lt;? extends PersonIdentity, ? extends AccessController&gt;&gt; exchange) throws BadRequestException;
</code></pre>
                    <p>Previous code basically means that the route requires a <code>SecurityContext</code> with any <code>PersonIdentity</code> types and any <code>AccessContoller</code> types. This is quite different than if we defined it as <code>SecurityContext&lt;PersonIdentity, AccessController&gt;</code>, in the first case we can assign <code>SecurityContext&lt;PersonIdentity, RoleBasedAccessController&gt;</code> whereas in the second case we can only assign <code>SecurityContext&lt;PersonIdentity, RoleBasedAccessController&gt;</code>. Using upper bound wildcards then provides greater flexibility and more integration options: routes basically don't have to be defined using the same context type definition.</p>
                    <p><em>Exchange context</em></p>
                    <p>The exchange context can also be injected directly by specifying a method parameter of a type assignable from <code>ExchangeContext</code>.</p>
                    <pre><code class="language-java">@WebRoute(path = "/{id}", method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
Mono&lt;T&gt; get(@PathParam String id, WebContext webContext);
</code></pre>
                    <p>As for the Web exchange, it is possible to specify intersection types using a type variable:</p>
                    <pre><code class="language-java">@WebRoute(path = "/{id}", method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
&lt;E extends WebContext &amp; InterceptorContext&gt; Mono&lt;T&gt; get(@PathParam String id, E context);
</code></pre>
                    <p>As before, context types declared in a declarative Web route are aggregated in the Web server controller configurer by the Inverno Web compiler plugin.</p>
                    <h6 id="request-body-1">Request body</h6>
                    <p>The request body can be bound to a route method parameter using the <code>@Body</code> annotation. Request body is automatically converted based on the media type declared in the <code>content-type</code> header field of the request as described in the <a href="#request-body-decoder">Web server exchange documentation</a>. The body parameter method can then be of any type as long as there is a media type converter for the media type specified in the request that can convert it.</p>
                    <p>In the following example, the request body is bound to parameter <code>book</code> of type <code>Book</code>, it is then converted from <code>application/json</code> into a <code>Book</code> instance:</p>
                    <pre><code class="language-java">@WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_JSON)
void create(@Body Book book);
</code></pre>
                    <p>Unlike parameters, the request body can be specified in a reactive way, the previous example can then be rewritten using a <code>Mono&lt;T&gt;</code>, a <code>Flux&lt;T&gt;</code> or more broadly a <code>Publisher&lt;T&gt;</code> as body parameter type as follows:</p>
                    <pre><code class="language-java">@WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_JSON)
Mono&lt;Void&gt; create(@Body Mono&lt;Book&gt; book);
</code></pre>
                    <p>A stream of objects can be processed when the media type converter supports it. For instance, the <code>application/x-ndjson</code> converter can emit converted objects each time a new line is encountered, this allows to process content without having to wait for the entire message resulting in better response time and reduced memory consumption.</p>
                    <pre><code class="language-java">@WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_X_NDJSON)
Mono&lt;Void&gt; create(@Body Flux&lt;Book&gt; book);
</code></pre>
                    <blockquote>
                        <p>The <code>application/json</code> also supports such streaming capability by emitting converted objects while parsing a JSON array.</p>
                    </blockquote>
                    <p>The <code>@Body</code> annotation can not be used together with the <code>@FormParam</code> annotation on route method parameters because the request body can only be consumed once.</p>
                    <p><em>Multipart form data</em></p>
                    <p>Multipart form data request body can be bound by defining a body parameter of type <code>Mono&lt;WebPart&gt;</code> if one part is expected, <code>Flux&lt;WebPart&gt;</code> if multiple parts are expected or more broadly of type <code>Publisher&lt;WebPart&gt;</code>.</p>
                    <p>We can then rewrite the example described in <a href="#request-body-decoder">Web server exchange documentation</a> as follows:</p>
                    <pre><code class="language-java">@WebRoute( path = "/bulk", method = Method.POST, consumes = MediaTypes.MULTIPART_FORM_DATA)
Flux&lt;Result&gt; createBulk(@Body Flux&lt;WebPart&gt; parts) {
    return parts
        .flatMap(part -&gt; part.decoder(Book.class).one())
        .map(book -&gt; storeBook(book));
}
</code></pre>
                    <blockquote>
                        <p>It is not possible to bind particular parts to a route method parameter. This design choice has been motivated by performance and resource consumption considerations. Indeed, this would require to consume and store the entire request body in memory before invoking the method. As a result, multipart data must still be handled <em>manually</em> using and processed in sequence (i.e. a part must be fully consumed before we can consume the next one).</p>
                    </blockquote>
                    <h6 id="response-body-1">Response body</h6>
                    <p>The response body is specified by the return type of the route method.</p>
                    <pre><code class="language-java">@WebRoute(path = "/{id}", method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
Book get(@PathParam String id);
</code></pre>
                    <p>As for the request body, the response body can be reactive if specified as a <code>Mono&lt;T&gt;</code>, a <code>Flux&lt;T&gt;</code> or more broadly as a <code>Publisher&lt;T&gt;</code>:</p>
                    <pre><code class="language-java">@WebRoute(path = "/{id}", method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
Mono&lt;Book&gt; get(@PathParam String id);
</code></pre>
                    <p>Depending on the media type converter, partial responses can be sent to the client as soon as they are complete. For instance a stream of responses can be sent to a client as follows:</p>
                    <pre><code class="language-java">@WebRoute(path = "/", method = Method.GET, produces = MediaTypes.APPLICATION_X_NDJSON)
Publisher&lt;Book&gt; list();
</code></pre>
                    <p>In the preceding example, as soon as a book is retrieved from a data store it can be sent to the client which can then process responses as soon as possible reducing the latency and resource consumption on both client and server. The response content type is <code>application/x-ndjson</code>, so each book is encoded in JSON before a newline delimiter to let the client detects partial responses as defined by <a href="http://ndjson.org/">the ndjon format</a>.</p>
                    <p><em>Server-sent events</em></p>
                    <p><a href="https://en.wikipedia.org/wiki/Server-sent_events">Server-sent events</a> can be streamed in the response body when declared together with a server-sent event factory route method parameter. A server-sent event factory can be bound to a route method parameter using the <code>@SseEventFactory</code> annotation.</p>
                    <p>In the following example, we declare a basic server-sent events Web route producing events with a <code>String</code> message:</p>
                    <pre><code class="language-java">@WebRoute(path = "/event", method = Method.GET)
Publisher&lt;WebResponseBody.SseEncoder.Event&lt;String&gt;&gt; getBookEvents(@SseEventFactory WebResponseBody.SseEncoder.EventFactory&lt;String&gt; events);
</code></pre>
                    <p>Server-sent event return type can be any of <code>Mono&lt;WebResponseBody.SseEncoder.Event&lt;T&gt;&gt;</code> if only one event is expected, <code>Flux&lt;WebResponseBody.SseEncoder.Event&lt;T&gt;&gt;</code> if multiple events are expected or more broadly <code>Publisher&lt;WebResponseBody.SseEncoder.Event&lt;T&gt;&gt;</code>.</p>
                    <p>By default, the media type of a server-sent event message is <code>text/plain</code> but it can be encoded using a specific media type converter as well by specifying a media type in the <code>@SseEventFactory</code> annotation.</p>
                    <p>We can rewrite previous example with messages of a custom type serialized in JSON as follows:</p>
                    <pre><code class="language-java">@WebRoute(path = "/event", method = Method.GET)
public Publisher&lt;WebResponseBody.SseEncoder.Event&lt;BookEvent&gt;&gt; getBookEvents(@SseEventFactory(MediaTypes.APPLICATION_JSON) WebResponseBody.SseEncoder.EventFactory&lt;BookEvent&gt; events) {
    return Flux.interval(Duration.ofSeconds(1))
        .map(seq -&gt; events.create(
                event -&gt; event
                    .id(Long.toString(seq))
                    .event("bookEvent")
                    .value(new BookEvent("some book event"))
            )
        );
}
</code></pre>
                    <h5 id="declarative-websocket-route">Declarative WebSocket route</h5>
                    <p>Just like Web route, a WebSocket route can be declared using the <code>@WebSocketRoute</code> annotation with slightly different semantic and bindings. A WebSocket exchange is essentially defined by an inbound stream of messages and an outbound stream of messages.</p>
                    <p>WebSocket routes are defined as methods in a Web controller with the following rules:</p>
                    <ul>
                        <li>The WebSocket <code>Web2SocketExchange.Inbound</code> may be injected as method parameter.</li>
                        <li>The WebSocket inbound may be injected as method parameter as a <code>Mono&lt;T&gt;</code>, a <code>Flux&lt;T&gt;</code> or more broadly as a <code>Publisher&lt;T&gt;</code>. When defined that way, the <code>Web2SocketExchange.Inbound</code> can not be injected as method parameter.</li>
                        <li>The WebSocket <code>Web2SocketExchange.Outbound</code> may be injected as method parameter and if so the method must be <code>void</code>.</li>
                        <li>The WebSocket WebSocket outbound may be specified as method's return type as a <code>Mono&lt;T&gt;</code>, a <code>Flux&lt;T&gt;</code> or more broadly as a <code>Publisher&lt;T&gt;</code> which closes the WebSocket when it terminates. When defined that way, the <code>Web2SocketExchange.Outbound</code> can not be injected as method parameter.</li>
                        <li>The <code>Web2SocketExchange</code> may always be injected as method parameter.</li>
                        <li>The exchange context may always be injected as method parameter just like for regular Web routes.</li>
                    </ul>
                    <h6 id="routing-rules-1">Routing rules</h6>
                    <p>WebSocket routing rules, as defined in the <a href="#websocket-route">Web routing API</a>, are specified in a single <code>@WebSocketRoute</code> annotation on a Web controller method. It allows to define paths, produced languages, supported subprotocols and the message type consumed and produced by the WebSocket routes that route a matching request to the handler implemented by the method.</p>
                    <p>A basic WebSocket route consuming and producing JSON text messages can be declared as follows:</p>
                    <pre><code class="language-java">@WebSocketRoute( path = "/chat", subprotocol = { "json" } )
Flux&lt;Message&gt; chat(Flux&lt;Message&gt; inbound);
</code></pre>
                    <blockquote>
                        <p>Note that this exactly corresponds to the <a href="#web-routing-api">Web routing API</a>.</p>
                    </blockquote>
                    <h6 id="contextual-parameters-1">Contextual parameters</h6>
                    <p>The <code>Web2SocketExchange</code> and the exchange context can be injected in the WebSocket route handler method just as for a regular <a href="#contextual-parameters">Web route</a>.</p>
                    <pre><code class="language-java">@WebSocketRoute( path = "/chat", subprotocol = { "json" } )
Flux&lt;Message&gt; chat(Flux&lt;Message&gt; inbound, Web2SocketExchange&lt;? extends ExchangeContext&gt; webSocketExchange);
</code></pre>
                    <pre><code class="language-java">@WebSocketRoute( path = "/chat", subprotocol = { "json" } )
&lt;E extends SecurityContext &amp; ChatContext&gt; Flux&lt;Message&gt; chat(Flux&lt;Message&gt; inbound, E context);
</code></pre>
                    <h6 id="websocket-inbound">WebSocket inbound</h6>
                    <p>The WebSocket inbound can be specified as method parameter in two ways, either by injecting the <code>Web2SocketExchange.Inbound</code> or by injecting a <code>Mono&lt;T&gt;</code>, a <code>Flux&lt;T&gt;</code> or more broadly as a <code>Publisher&lt;T&gt;</code>.</p>
                    <p>When specified as <code>Web2SocketExchange.Inbound</code> parameter, inbound frames or messages can be consumed as defined in the <a href="#websocket-route">Web Routing API documentation</a>:</p>
                    <pre><code class="language-java">@WebSocketRoute( path = "/ws" )
public void webSocket(Web2SocketExchange.Inbound inbound) {
    Flux.from(inbound.messages()).flatMap(WebSocketMessage::reducedText).subscribe(LOGGER::info);
}
</code></pre>
                    <p>When specified as a <code>Publisher&lt;T&gt;</code> parameter, <code>&lt;T&gt;</code> can be basically a <code>ByteBuf</code>, a <code>String</code> or any types that can be converted using a converter matching the negotiated subprotocol.</p>
                    <p>For instance, raw inbound messages can be consumed as follows:</p>
                    <pre><code class="language-java">@WebSocketRoute( path = "/ws" )
public void webSocket(Flux&lt;ByteBuf&gt; inbound) {
    inbound.subscribe(message -&gt; {
        try {
            LOGGER.info(message.toString(Charsets.DEFAULT));
        }
        finally {
            // ByteBuf must be released where they are consumed
            message.release();
        }
    });
}
</code></pre>
                    <p>It is also possible to consume raw frame data composing inbound messages as follows:</p>
                    <pre><code class="language-java">@WebSocketRoute( path = "/ws" )
public void webSocket(Flux&lt;Flux&lt;ByteBuf&gt;&gt; inbound) {

    inbound
        .doOnNext(message -&gt; LOGGER.info("Message start"))
        .flatMap(message -&gt; message.doOnComplete(() -&gt; LOGGER.info("Message end")))
        .subscribe(message -&gt; {
            try {
                LOGGER.info(message.toString(Charsets.DEFAULT));
            }
            finally {
                // ByteBuf must be released where they are consumed
                message.release();
            }
        });
}
</code></pre>
                    <p>Finally, inbound messages can also be automatically decoded using a converter matching the subprotocol negotiated during the opening handshake:</p>
                    <pre><code class="language-java">@WebSocketRoute( path = "/ws", subprotocol = { "json" } )
public void webSocket(Flux&lt;Message&gt; inbound) {
    inbound.subscribe(message -&gt; {
        LOGGER.info(message.getNickname() + ": " + message.getMessage());
    });
}
</code></pre>
                    <h6 id="websocket-outbound">WebSocket outbound</h6>
                    <p>The WebSocket outbound can be specified in two ways, either as method parameter by injecting the <code>Web2SocketExchange.Outbound</code> or as method's return type as a <code>Mono&lt;T&gt;</code>, a <code>Flux&lt;T&gt;</code> or more broadly as a <code>Publisher&lt;T&gt;</code>.</p>
                    <p>When specified as <code>Web2SocketExchange.Outbound</code>, outbound frames or messages can be provided as defined in the <a href="#websocket-route">Web Routing API documentation</a>:</p>
                    <pre><code class="language-java">@WebSocketRoute( path = "/ws" )
public void webSocket(Web2SocketExchange.Outbound outbound) {
    outbound.messages(factory -&gt; Flux.interval(Duration.ofSeconds(1)).map(ign -&gt; factory.text(ZonedDateTime.now().toString())));
}
</code></pre>
                    <p>When specified as method's return type as a <code>Publisher&lt;T&gt;</code>, <code>&lt;T&gt;</code> can be basically a <code>ByteBuf</code>, a <code>String</code> or any types that can be converted using a converter matching the negotiated subprotocol.</p>
                    <p>For instance, <code>String</code> outbound messages can be provided as follows:</p>
                    <pre><code class="language-java">@WebSocketRoute( path = "/ws" )
public Flux&lt;String&gt; webSocket() {
    return Flux.just("messge 1", "message 2", "message 3");
}
</code></pre>
                    <p>It is also possible to produce fragmented raw messages as follows:</p>
                    <pre><code class="language-java">@WebSocketRoute( path = "/ws" )
public Flux&lt;Flux&lt;ByteBuf&gt;&gt; webSocket() {
    return Flux.just(
        Flux.just(
            Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("message", Charsets.DEFAULT)), 
            Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(" 1", Charsets.DEFAULT))
        ), 
        Flux.just(
            Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("message ", Charsets.DEFAULT)), 
            Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(" 2", Charsets.DEFAULT))
        ), 
        Flux.just(
            Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("message ", Charsets.DEFAULT)), 
            Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(" 3", Charsets.DEFAULT))
        )
    );
}
</code></pre>
                    <p>Finally, outbound messages can be automatically encoded using a converter matching the subprotocol negotiated during the opening handshake:</p>
                    <pre><code class="language-java">@WebSocketRoute( path = "/ws", subprotocol = { "json" } )
public Flux&lt;Message&gt; webSocket() {
    return Flux.just(
        new Message("john", "message 1"),
        new Message("bob", "message 2"),
        new Message("alice", "message 3")
    );
}
</code></pre> <br />
                    <blockquote>
                        <p>Putting it all together, the <a href="#a-simple-chat-server">simple chat server</a> can be simply implemented as follows:</p>
                        <pre><code class="language-java">package io.inverno.example.app_web_websocket;

import io.inverno.core.annotation.Bean;
import io.inverno.core.annotation.Destroy;
import io.inverno.core.annotation.Init;
import io.inverno.example.app_web_websocket.dto.Message;
import io.inverno.mod.web.annotation.WebController;
import io.inverno.mod.web.annotation.WebSocketRoute;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Sinks;

@Bean
@WebController
public class App_web_websocketWebController {

    private Sinks.Many&lt;Message&gt; chatSink;

    @Init
    public void init() {
        this.chatSink = Sinks.many().multicast().onBackpressureBuffer(16, false);
    }

    @Destroy
    public void destroy() {
        this.chatSink.tryEmitComplete();
    }

    @WebSocketRoute(path = "/ws", subprotocol = "json")
    public Flux&lt;Message&gt; ws2(Flux&lt;Message&gt; inbound) {
        inbound.subscribe(message -&gt; this.chatSink.tryEmitNext(message));
        return this.chatSink.asFlux();
    }
}
</code></pre>
                    </blockquote>
                    <h5 id="composite-web-module">Composite Web module</h5>
                    <p>The Web Inverno compiler plugin generates a single Web server controller configurer bean aggregating all route definitions and context types specified in Web configurers or Web controllers beans in the module. When a module composes the <em>web</em> module, this bean is then wired to the <em>web</em> module to configure the Web server controller.</p>
                    <p>Now when a module doesn't compose the <em>web</em> module, the Web router configurer bean is simply exposed by the module waiting for the module to be composed within other modules until a top module eventually composes the <em>web</em> module.</p>
                    <p>This raises two issues:</p>
                    <ul>
                        <li>First if multiple Web modules are composed together with the <em>web</em> module, dependency injection conflicts will be reported since multiple Web server controller configurer beans can be wired to the <em>web</em> module.</li>
                        <li>Then if such module is composed in another module defining other Web controllers, we still need to expose one Web router configurer providing all route definitions to a top module composing the <em>web</em> module.</li>
                    </ul>
                    <p>Hopefully, the <code>WebServerControllerConfigurer</code> interface extends <code>WebRouterConfigurer</code> and <code>ErrorWebRouterConfigurer</code> which are automatically aggregated in a generated Web server controller configurer bean by the Inverno Web compiler plugin. Then all we have to do to compose Web modules is to explicitly wire the top <code>WebServerControllerConfigurer</code> bean to the <em>web</em> module.</p>
                    <p>A generated Web server controller configurer is always annotated with a <code>@WebRoutes</code> annotation specifying the Web routes it configures. For instance, the configurer generated for the module defining the book Web controller looks like:</p>
                    <pre><code class="language-java">@WebRoutes({
	@WebRoute(path = { "/book/{id}" }, method = { Method.GET }, produces = { "application/json" }),
	@WebRoute(path = { "/book" }, method = { Method.POST }, consumes = { "application/json" }),
	@WebRoute(path = { "/book/{id}" }, method = { Method.PUT }, consumes = { "application/json" }),
	@WebRoute(path = { "/book" }, method = { Method.GET }, produces = { "application/json" }),
	@WebRoute(path = { "/book/{id}" }, method = { Method.DELETE })
})
@Bean( name = "webServerContollerConfigurer" )
@Generated(value="io.inverno.mod.web.compiler.internal.WebServerControllerConfigurerCompilerPlugin", date = "2022-07-20T14:10:14.100988902+02:00[Europe/Paris]")
public final class App_web_WebServerContollerConfigurer implements WebServerControllerConfigurer&lt;App_web_WebServerContollerConfigurer.Context&gt; {
    ...
}
</code></pre>
                    <p>These information are used by the compiler plugin to statically check that there is no conflicting routes when generating the Web server controller configurer. It is a good practice to explicitly define the <code>@WebRoutes</code> annotation when defining routes programmatically in a Web configurer, otherwise the compiler can not determine conflict as it does not know the actual routes configured.</p>
                    <p>Now let's imagine we have created a modular Web application with a <em>book</em> module defining the book Web controller, an <em>admin</em> module defining some admin Web controllers and a top <em>app</em> module composing these modules together with the <em>web</em> module.</p>
                    <p>The module descriptors for each of these modules should look like:</p>
                    <pre><code class="language-java">@io.inverno.core.annotation.Module( excludes = { "io.inverno.mod.web" } )
module io.inverno.example.web_modular.admin {
    requires io.inverno.core;
    requires io.inverno.mod.web;

    exports io.inverno.example.web_modular.admin to io.inverno.example.web_modular.app;
}
</code></pre>
                    <pre><code class="language-java">@io.inverno.core.annotation.Module( excludes = { "io.inverno.mod.web" } )
module io.inverno.example.web_modular.book {
    requires io.inverno.core;
    requires io.inverno.mod.web;
    
    exports io.inverno.example.web_modular.book to io.inverno.example.web_modular.app;
    exports io.inverno.example.web_modular.book.dto to com.fasterxml.jackson.databind;
}
</code></pre>
                    <pre><code class="language-java">@io.inverno.core.annotation.Module
module io.inverno.example.web_modular.app {
    requires io.inverno.mod.boot;
    requires io.inverno.mod.web;
    
    requires io.inverno.example.web_modular.admin;
    requires io.inverno.example.web_modular.book;
}
</code></pre>
                    <p>The first thing to notice is that the <em>web</em> module is excluded from <em>admin</em> and <em>book</em> modules since we don't want to start a Web server in these modules, we only need the Web routing API to define Web controllers and generate Web server controller configurer beans. As a consequence, the <em>boot</em> module which provides converters and net service required to create and start the <em>web</em> module is also not required but the <code>io.inverno.core</code> module is still required. Finally we must export packages containing the generated module classes to the <em>app</em> module so it can compose them.</p>
                    <p>The <em>admin</em> and <em>book</em> modules should compile just fine resulting in two Web server controller configurer beans being generated and exposed in each module. But the compilation of <em>app</em> module should raise some dependency injection errors since multiple Web server controller configurer beans exist whereas only one can be wired to the <em>web</em> module. There are actually three Web server controller configurer beans, how so? There are those exposed by the <em>admin</em> and <em>book</em> modules and one generated in the <em>app</em> module and aggregating the previous two. In order to solve the conflict, we should then define the following explicit wire in the <em>app</em> module:</p>
                    <pre><code class="language-java">@io.inverno.core.annotation.Module
@io.inverno.core.annotation.Wire(beans="io.inverno.example.web_modular.app:webServerContollerConfigurer", into="io.inverno.mod.web:controllerConfigurer")
module io.inverno.example.web_modular.app {
    ...
}
</code></pre>
                    <blockquote>
                        <p>One could rightfully argue that this explicit wiring is useless and cumbersome, but it is consistent with the IoC/DI core framework principles. Keeping things simple and explicit limits possible side effects induced by the fact that what's happening with <em>automatic</em> conflict resolution is often specific and might not be obvious. This is all the more true when such behavior is manually overridden.</p>
                    </blockquote>
                    <p>The same principles applies if multiple modules like <em>admin</em> or <em>book</em> are cascaded into one another: Web server controller configurer beans at a given level are aggregated in the Web server controller configurer bean in the next level.</p>
                    <h5 id="automatic-openapi-specifications">Automatic OpenAPI specifications</h5>
                    <p>Besides facilitating the development of REST and Web resources in general, Web controllers also simplify documentation. The Web Inverno compiler plugin can be setup to generate <a href="https://www.openapis.org/">Open API</a> specifications from the Web controller classes defined in a module and their JavaDoc comments.</p>
                    <blockquote>
                        <p>Writing JavaDoc comments is something natural when developing in the Java language, with this approach, a REST API can be documented just as you document a Java class or method, documentation is written once and can be used in both Java and other languages and technologies using the generated Open API specification.</p>
                    </blockquote>
                    <p>In order to activate this feature the <code>inverno.web.generateOpenApiDefinition</code> annotation processor option must be enabled when compiling a Web module. This can be done on the command line: <code>java -Ainverno.web.generateOpenApiDefinition=true ...</code> or in the Maven compiler plugin configuration in the build descriptor:</p>
                    <pre><code class="language-java">&lt;project&gt;
    &lt;build&gt;
        &lt;pluginManagement&gt;
            &lt;plugins&gt;
                &lt;plugin&gt;
                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                    &lt;configuration&gt;
                        &lt;compilerArgs combine.children="append"&gt;
                            &lt;arg&gt;-Ainverno.web.generateOpenApiDefinition=true&lt;/arg&gt;
                        &lt;/compilerArgs&gt;
                    &lt;/configuration&gt;
                &lt;/plugin&gt;
            &lt;/plugins&gt;
        &lt;/pluginManagement&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
                    <p>The compiler then generates an Open API specification in <code>META-INF/inverno/web/openapi.yml</code> for any module defining one or more Web controllers.</p>
                    <p>The previous <a href="#web-controller">book resource</a> could then be documented as follows:</p>
                    <pre><code class="language-java">/**
 * The book resource.
 */
@Bean
@WebController(path = "/book")
public class BookResource {
    
    /**
     * Creates a book resource.
     * 
     * @param book a book
     * @param exchange the web exchange
     * 
     * @return the book resource has been successfully created
     * @throws BadRequestException A book with the same ISBN reference already exist
     */
    @WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_JSON)
    public Mono&lt;Void&gt; create(@Body Mono&lt;Book&gt; book, WebExchange exchange) throws BadRequestException { ... }
    
    /**
     * Updates a book resource.
     * 
     * @param isbn the reference of the book resource to update
     * @param book the updated book resource
     * 
     * @return the book resource has been successfully updated
     * @throws NotFoundException if the specified reference does not exist
     */
    @WebRoute(path = "/{isbn}", method = Method.PUT, consumes = MediaTypes.APPLICATION_JSON)
    public Mono&lt;Void&gt; update(@PathParam String isbn, @Body Mono&lt;Book&gt; book) throws NotFoundException { ... }
    
    /**
     * Returns the list of book resources.
     * 
     * @return a list of book resources
     */
    @WebRoute(method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
    public Flux&lt;Book&gt; list();
    
    /**
     * Returns the book resource identified by the specified ISBN.
     * 
     * @param isbn an ISBN
     * 
     * @return the requested book resource
     * @throws NotFoundException if the specified reference does not exist
     */
    @WebRoute(path = "/{isbn}", method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
    public Mono&lt;Book&gt; get(@PathParam String isbn) throws NotFoundException { ... }
    
    /**
     * Deletes the book resource identified by the specified ISBN.
     * 
     * @param isbn an ISBN
     * 
     * @return the book resource has been successfully deleted
     * @throws NotFoundException if the specified reference does not exist
     */
    @WebRoute(path = "/{isbn}", method = Method.DELETE)
    public Mono&lt;Void&gt; delete(@PathParam String isbn) { ... }
}
</code></pre>
                    <p>Note that just like the <code>javadoc</code> tool, the Web compiler plugin takes inheritance into account when resolving JavaDoc comments and as a result, it is possible to define JavaDoc comments in an interface and enrich or override them in the implementation classes.</p>
                    <p>By default, the normal HTTP status code responded by a route is assumed to be <code>200</code> but it is possible to specify a custom status code using the <code>@inverno.web.status</code> tag. For instance the book creation route which actually responds with a <code>201</code> status should be documented as follows:</p>
                    <pre><code class="language-java">public class BookResource {

    /**
     * Creates a book resource.
     * 
     * @param book a book
     * @param exchange the web exchange
     * 
     * @return {@inverno.web.status 201} the book resource has been successfully created
     * @throws BadRequestException A book with the same ISBN reference already exist
     */
    @WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_JSON)
    public Mono&lt;Void&gt; create(@Body Mono&lt;Book&gt; book, WebExchange exchange) throws BadRequestException { ... }
    
    ...
}
</code></pre>
                    <blockquote>
                        <p>Multiple <code>@return</code> statements can be specified if multiple response statuses are expected, however this might raise issues during the generation of the JavaDoc, you can bypass this by disabling the linter with <code>-Xdoclint:none</code> option.</p>
                    </blockquote>
                    <p>This tag can also be used to specify error status code in <code>@throws</code> statements, but this is usually not necessary since the Web compiler plugin automatically detects status code for regular <code>HTTPException</code> such as <code>BadRequestException</code> (400) or <code>NotFoundException</code> (404).</p>
                    <p>The Web compiler plugin generates, per module, one Open API specification and one Web server controller configurer bean aggregating all routes from all Web controllers and Web configurers. As a result the general API documentation corresponds to the general documentation of the module which is defined in the module descriptor JavaDoc comment.</p>
                    <p>For instance, we can describe the API exposed by the <em>book</em> module in the module descriptor including the API version which should normally match the module version:</p>
                    <pre><code class="language-java">/**
 * This is a sample Book API which demonstrates Inverno Web module capabilities.
 * 
 * @author &lt;a href="mailto:jeremy.kuhn@inverno.io"&gt;Jeremy Kuhn&lt;/a&gt;
 * 
 * @version 1.2.3
 */
@io.inverno.core.annotation.Module( excludes = { "io.inverno.mod.web" } )
module io.inverno.example.web_modular.book {
    requires io.inverno.core;
    requires io.inverno.mod.web;
    
    exports io.inverno.example.web_modular.book to io.inverno.example.web_modular.app;
    exports io.inverno.example.web_modular.book.dto to com.fasterxml.jackson.databind;
}
</code></pre>
                    <p>These specifications can also be exposed in the Web server using the <code>OpenApiRoutesConfigurer</code> as described in the <a href="#openapi-specification">Web server documentation</a>.</p>
                    <p>If we build and run the <a href="#composite-web-module">modular book application</a> and access <code>http://locahost:8080/open-api</code> in a Web browser we should see a Swagger UI loaded with the Open API specifications of the <em>admin</em> and <em>book</em> modules:</p> <img class="img-fluid shadow mb-4" src="doc/img/swaggerUI_root.png" alt="General Swagger UI" />
                    <p>It is also possible to target a single specification by specifying the module name in the URI, for instance <code>http://locahost:8080/open-api/io.inverno.example.web_modular.book</code>:</p> <img class="img-fluid shadow mb-4" src="doc/img/swaggerUI_module.png" alt="Module Swagger UI" />
                    <p>Finally, Open API specifications formatted in <a href="https://en.wikipedia.org/wiki/YAML">YAML</a> can be retrieved as follows:</p>
                    <pre><code class="language-plaintext">$ curl http://locahost:8080/open-api/io.inverno.example.web_modular.admin

openapi: 3.0.3
info:
    title: 'io.inverno.example.web_modular.admin'
    version: ''
...
</code></pre>
                    <h3 id="reactive-template">Reactive Template</h3>
                    <p>The Inverno <em>irt</em> module provides a template engine for efficient reactive data rendering.</p>
                    <p>Data are basically rendered by templates which are regrouped in template sets and applied based on the type of data to render. A template set is statically typed and generated by an Inverno compiler plugin which compiles <code>.irt</code> template set source files along with the Java sources of a module.</p>
                    <p>The template sets classes thus obtained support reactive rendering, data are rendered as a flow of events for efficient usage of resources. For instance, the complete set of data doesn't have to be available or loaded into memory, the rendering being reactive the output can be generated incrementally by processing each piece of data individually one after the other when they become available. Since the rendering process never blocks it is also possible to lazily load data when/if they need to be rendered.</p>
                    <p>The syntax of <code>.irt</code> template set is inspired from functional language such as <a href="https://en.wikipedia.org/wiki/XSLT">XSLT</a> and <a href="https://en.wikipedia.org/wiki/Erlang_(programming_language)">Erlang</a> which are particularly suited for reactive rendering. Since a template is a generated Java class, the Java language is also widely used in a template source file, especially for the dynamic parts of a template.</p>
                    <p>In terms of raw performance, Inverno templates processing is faster than most Java template engines by an order of magnitude and with lower memory usage. The following <a href="https://github.com/jkuhn1/template-benchmark">benchmark project</a> compares performances of various template engines rendering a list of stock items into an HTML document as a String.</p> <img class="img-fluid shadow mb-4 mx-auto d-block" src="doc/img/template_benchmarks.png" alt="Template Benchmarks" />
                    <blockquote>
                        <p>Please keep in mind that outcomes might be different considering different scenarios, especially reactive rendering which might appear slower but addresses different concerns such as stream processing and optimized usage of resources.</p>
                    </blockquote>
                    <p>In order to use the Inverno <em>irt</em> module, we need to declare a dependency in the module descriptor:</p>
                    <pre><code class="language-java">module io.inverno.example.app {
    ...
    requires io.inverno.mod.irt;
    ...
}
</code></pre>
                    <p>And also declare that dependency in the build descriptor:</p>
                    <p>Using Maven:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-irt&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <p>Using Gradle:</p>
                    <pre><code class="language-java">...
compile 'io.inverno.mod:inverno-irt:1.5.2'
...
</code></pre>
                    <p>Dependencies to <code>io.netty.common</code> and <code>io.netty.buffer</code> are also required when using <code>BYTEBUF</code> or <code>PUBLISHER_BYTEBUF</code> <a href="#modes">modes</a> which require Netty's <code>ByteBuf</code>. They are defined as optional in the <em>irt</em> module and won't be included by default. In order to use <code>ByteBuf</code> based generation modes, the following dependencies must be declared as well in the module descriptor:</p>
                    <pre><code class="language-java">module io.inverno.example.app {
    ...
    requires io.netty.common;
	requires transitive io.netty.buffer;
    ...
}
</code></pre>
                    <p>And the corresponding dependency to <code>io.netty:netty-buffer</code> must be declared in the the build descriptor:</p>
                    <p>Using Maven:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.netty&lt;/groupId&gt;
            &lt;artifactId&gt;netty-buffer&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <p>Using Gradle:</p>
                    <pre><code class="language-java">...
compile 'io.netty:netty-buffer:4.1.79.Final'
...
</code></pre>
                    <h4 id="creates-an-irt-template">Creates an .irt template</h4>
                    <p>A template can be created along with other Java source files in the source directory of an Inverno module. At compile time, the Inverno reactive template compiler plugin will scan the module source folder for <code>.irt</code> files and compiles them to generate template set classes that can be used in your module to render data.</p>
                    <p>The following <code>Simple.irt</code> template set is a simple example containing one template that renders a <code>Message</code> object as String:</p>
                    <pre><code class="language-plaintext">package io.inverno.example.app_irt.templates;

import io.inverno.example.app_irt.model.Message;

option modes = {"STRING"};
option charset = "utf-8";

(Message message) -&gt; {The message is: {@message.message}}
</code></pre>
                    <pre><code class="language-java">package io.inverno.example.app_irt.model;

public class Message {

    private final String message;

    private final boolean important;

    public Message(String message, boolean important) {
        this.message = message;
        this.important = important;
    }

    public String getMessage() {
        return message;
    }

    public boolean isImportant() {
        return important;
    }
}
</code></pre>
                    <p>As for any Java source file, the preceding template source must be created in the same package as the one it declares in a module source folder. The name of the template corresponds to the name of the file.</p>
                    <p>After compiling the module, a new Java class <code>Simple.java</code> should have been created in the generated source folder in package <code>io.inverno.example.app_irt.templates</code>.</p>
                    <p>A <code>Message</code> object can then be rendered as follows:</p>
                    <pre><code class="language-java">CompletableFuture&lt;String&gt; rendered = Simple.string().render(new Message("Hello, world!"));
System.out.println(rendered.get()); // The message is: Hello, world!
</code></pre>
                    <h4 id="irt-syntax">.irt syntax</h4>
                    <h5 id="package-and-imports">Package and imports</h5>
                    <p>An <code>.irt</code> template always starts with the declaration of the Java package containing the template, followed by the list of imported Java types or static methods used within the template. This is exactly the same as any Java source file.</p>
                    <pre><code class="language-plaintext">package io.inverno.example.app_irt.templates;

import io.inverno.example.app_irt.model.Message;
...
</code></pre>
                    <h5 id="includes">Includes</h5>
                    <p>Then you can specify external template sets to include in the template set using the <code>include</code> keyword. This allows to include templates from an external template set in a template set using the same precedence. For instance, in the following example, template set <code>io.inverno.example.app_irt.templates.Misc</code> is included in the template set which means that its templates can be applied in the including template.</p>
                    <pre><code class="language-plaintext">include io.inverno.example.app_irt.templates.Misc;
</code></pre>
                    <blockquote>
                        <p>Note that this can lead to conflicts when two included templates defines a template using the same signature (same name and same input parameters), such conflict can be resolved by explicitly overriding the conflicting template in the including template set.</p>
                    </blockquote>
                    <h5 id="options">Options</h5>
                    <p>Rendering options are specified after that using the <code>option</code> keyword. You can for instance declare the charset to use for rendering which defaults to <code>utf-8</code> if not specified:</p>
                    <pre><code class="language-plaintext">option charset = "utf-8";
</code></pre>
                    <p>or the template rendering modes supported by the generated template set. There are five template rendering modes, you can choose to specify one or more modes depending on your needs:</p>
                    <ul>
                        <li><strong>STRING</strong> to expose methods to render data in a <code>String</code>, this is the default behavior</li>
                        <li><strong>BYTEBUF</strong> to expose methods to render data in a <code>ByteBuf</code></li>
                        <li><strong>STREAM</strong> to expose methods to render data in an <code>OutputStream</code></li>
                        <li><strong>PUBLISHER_STRING</strong> to expose methods to render data in a <code>Publisher&lt;String&gt;</code></li>
                        <li><strong>PUBLISHER_BYTEBUF</strong> to expose methods to render data in a <code>Publisher&lt;ByteBuf&gt;</code></li>
                    </ul>
                    <p>The last two modes are particularly suitable for reactive rendering.</p>
                    <pre><code class="language-plaintext">option modes = {"STRING", "STREAM", "PUBLISHER_STRING"};
</code></pre>
                    <h5 id="templates">Templates</h5>
                    <p>Templates are specified last. A template is a function that defines how a particular input must be rendered, a template can have a name in which case it is referred as a named template. In a template set, there can't be two templates with the same signature (ie. defining the same input parameters) unless they have different names.</p>
                    <p>A template is declared as follows:</p>
                    <pre><code class="language-plaintext">(Message message) -&gt; {...}
</code></pre>
                    <p>A named template is declared as follows:</p>
                    <pre><code class="language-plaintext">name(Message message) -&gt; {...}
</code></pre>
                    <p>A template can be defined with zero or more parameters. No parameter templates can be useful to create static templates such as headers or footers, they are usually named:</p>
                    <pre><code class="language-plaintext">header() -&gt; {...}
</code></pre>
                    <p>The body of a template is a combination of static content and statements which define how the template input should be rendered. Template statements are specified within braces <code>{...}</code> which must be escaped within static content using <code>\</code>.</p>
                    <p>A template can also be specified without a body in order to create aliases or resolve conflicts.</p>
                    <p>For instance the following template defines alias <code>apple</code> for template <code>fruit</code> (assuming <code>Apple</code> is an instance of <code>Fruit</code>):</p>
                    <pre><code class="language-plaintext">apple(Apple fruit) -&gt; this::fruit

fruit(Fruit fruit) -&gt; {...}
</code></pre>
                    <p>And the following template resolves a conflict induced by the inclusion of template set <code>Include1</code> and <code>Include2</code> which both defines template <code>conflicting</code> with the same input parameters:</p>
                    <pre><code class="language-plaintext">...
include io.inverno.example.app_irt.templates.Include1;
include io.inverno.example.app_irt.templates.Include2;
...

conflicting(String input) -&gt; Include1
</code></pre>
                    <h5 id="static-content">Static content</h5>
                    <p>Static contents are specified directly in the template body and are rendered as is:</p>
                    <pre><code class="language-plaintext">(...) -&gt; {
This is a static content, braces: \{ and \} must be escaped.
}
</code></pre>
                    <h5 id="comment">Comment</h5>
                    <p>The syntax supports two kinds of comments which can be either outside or inside the body of a template.</p>
                    <p>Outside the body of a template, comments are regular Java comments:</p>
                    <pre><code class="language-plaintext">/*
 * This a comment to explain that the following import is commented
 */
// import java.util.List; 
</code></pre>
                    <p>Inside the body of a template, comments are statements starting with <code>{%</code> and ending with <code>}</code>:</p>
                    <pre><code class="language-plaintext">(Message message) -&gt; {
Hello {% this is a comment} World.
}
</code></pre>
                    <h5 id="value-of">Value of</h5>
                    <p>A value can be rendered directly in a synchronous way within a statement starting with <code>{@</code> and ending with <code>}</code> as follows:</p>
                    <pre><code class="language-plaintext">(Message message) -&gt; {
The message is: {@message.message}
}
</code></pre>
                    <p>In the preceding example, we used a syntactic sugar to navigate into the message object hierarchy and access the <code>message</code> properties but it is also possible to evaluate a raw Java expression specified between <code>(</code> and <code>)</code> to get the same result:</p>
                    <pre><code class="language-plaintext">(Message message) -&gt; {
The message is: {@(message.getMessage())}
}
</code></pre>
                    <p>It is then possible to evaluate any Java expression:</p>
                    <pre><code class="language-plaintext">(Message message) -&gt; {
The message is: {@(5+8)}
}
</code></pre>
                    <blockquote>
                        <p>Note that this can be dangerous when you the origin of a template set can't be trusted.</p>
                    </blockquote>
                    <h5 id="if">If</h5>
                    <p>An if statement can be used to render different contents based on one or more conditions. An if statement starts with <code>{@if</code> and ends with <code>}</code>, it contains one or more branches separated by <code>;</code> defining a condition and a corresponding body, a default branch with an empty condition can be specified last. Each condition is specified as a raw Java if expression between <code>(</code> and <code>)</code>:</p>
                    <pre><code class="language-plaintext">(Message message, String lang) -&gt; {
    {@if
        (lang.equals("fr")) -&gt; {
            Le message est: {@message.message}
        };
        (lang.equals("de")) -&gt; {
            Die Nachricht ist: {@message.message}
        };
        () -&gt; {
            The message is: {@message.message}
        }
    }
}
</code></pre>
                    <h5 id="apply-template">Apply template</h5>
                    <p>Templates can be applied on data using an apply template statement starting with <code>{</code> and ending with <code>}</code>. The template to apply is selected among the ones available in the template set based on the type of data to render following Java's rules for function overloading.</p>
                    <p>As for the value of statement, it is possible to use a syntactic sugar notation or a raw Java expression between <code>(</code> and <code>)</code> to select the data on which a template should be applied. A template set provides a default template for object which simply renders the <code>toString()</code> representation of the input. Considering previous examples, the content of a message object can then also be rendered as follows:</p>
                    <pre><code class="language-plaintext">(Message message) -&gt; {
The message is: {message.message}
}
</code></pre>
                    <p>Unlike the value of statement which renders data synchronously, applying a template can be an asynchronous operation depending on the type of data to render. Indeed when the data to render is an an array, an <code>Iterable</code>, a <code>Stream</code> or a <code>Publisher</code>, the template is applied on each element and in the case of a <code>Publisher</code> the operation is reactive, non-blocking and therefore asynchronous.</p>
                    <p>For instance, a list of messages can be rendered synchronously as follows:</p>
                    <pre><code class="language-plaintext">(List&lt;Message&gt; messages) -&gt; {
Messages are: 
{messages}
}

(Message message) -&gt; {{@message.message}
}
</code></pre>
                    <p>resulting in:</p>
                    <pre><code class="language-plaintext">Messages are:
message 1
message 2
message 3
message 4
message 5
...
</code></pre>
                    <p>Now if we consider a <code>Publisher</code>, a message is rendered to the output when it is emitted by the publisher following reactive principles.</p>
                    <p>As you can see the apply template statement is extremely powerful, it is used to render data based on their types which facilitates composition but it can also be used as a for loop statement to render a list of elements.</p>
                    <p>By default, an apply template statement will select the unnamed template within the template set matching the type of data to render, but it is also possible to select a named templates as follows:</p>
                    <pre><code class="language-plaintext">(List&lt;Message&gt; messages) -&gt; {
Messages are: 
{messages;bullet}
}

(Message message) -&gt; {{@message.message}
}

bullet(Message message) -&gt; {* {@message.message}
}
</code></pre>
                    <p>resulting in:</p>
                    <pre><code class="language-plaintext">Messages are:
* message 1
* message 2
* message 3
* message 4
* message 5
...
</code></pre>
                    <p>Extra parameters can also be passed to a template in which case we have to explicitly specify the inputs:</p>
                    <pre><code class="language-plaintext">(List&lt;Message&gt; messages) -&gt; {
Messages are: 
{messages; message -&gt; bullet(message, "-")}
}

bullet(Message message, String marker) -&gt; {{@marker} {@message.message}
}
</code></pre>
                    <p>resulting in:</p>
                    <pre><code class="language-plaintext">Messages are:
- message 1
- message 2
- message 3
- message 4
- message 5
...
</code></pre>
                    <p>It is also possible to specify guard expressions as raw Java expressions and choose to apply different templates based on certain conditions. For instance, let's say we want to render important messages in a specific way, we can do as follows:</p>
                    <pre><code class="language-plaintext">(List&lt;Message&gt; messages) -&gt; {
Messages are: 
{messages;(message) -&gt; important(message) when (message.isImportant());(message)}
}

(Message message) -&gt; {{@message.message}
}

important(Message message) -&gt; {**{@message.message}**
}

</code></pre>
                    <p>In the previous example, the <code>important</code> template is applied when a message is important and the unnamed template is applied otherwise. Assuming message 3 is important, this will result in:</p>
                    <pre><code class="language-plaintext">Messages are:
- message 1
- message 2
- **message 3**
- message 4
- message 5
...
</code></pre>
                    <p>The index of an item in a list is made available when selecting the target template. For instance, a numbered list of messages can be rendered as follows:</p>
                    <pre><code class="language-plaintext">(List&lt;Message&gt; messages) -&gt; {
Messages are: 
{messages;(index, message) -&gt; (index, message)}
}

(long index, Message message) -&gt; {{@index}. {@message.message}
}
</code></pre>
                    <p>resulting in:</p>
                    <pre><code class="language-plaintext">Messages are:
0. message 1
1. message 2
2. message 3
3. message 4
4. message 5
...
</code></pre>
                    <p>A no-arg named template can be applied by omitting the data part in the statement:</p>
                    <pre><code class="language-plaintext">(Message message) -&gt; {
    {;header}
    The message is: {@message.message}
    {;footer}
}

header() -&gt; {==== HEADER ====
}

footer() -&gt; {==== FOOTER ====
}
</code></pre>
                    <p>resulting in:</p>
                    <pre><code class="language-plaintext">==== HEADER ====
The message is: {@message.message}
==== FOOTER ====
</code></pre>
                    <h4 id="pipes">Pipes</h4>
                    <p>A pipe can be used to transform data before they are rendered or before a template is applied, as a result they can be specified in value of and apply template statements. In practice, a pipe is a simple function that accepts a data and transform it into another data. Pipes can be chained to sequentially apply multiple transformations.</p>
                    <p>A pipe can be specified as a lambda expression and applied using a <code>|</code> in a value of or apply template statement as follows:</p>
                    <pre><code class="language-plaintext">(Message message) -&gt; {
The message is: {@message.message|((String content) -&gt; content.toUpperCase())}
}
</code></pre>
                    <p>Lambdas are handy when there's a need for very specific pipes, however the recommended way to create pipes is to define them in Java as static methods returning the <code>Pipe</code> implementation in order to keep the template readable. Above pipe can be defined in a Java class as follows:</p>
                    <pre><code class="language-java">package io.inverno.example.app_irt.pipes; 

import io.inverno.mod.irt.Pipe;

public final class SamplePipes {

    public static Pipe&lt;String, String&gt; uppercase() {
        return String::toUpperCase;
    }
}
</code></pre>
                    <p>We can then statically import that class in the template set and simplify above example:</p>
                    <pre><code class="language-plaintext">import static io.inverno.example.app_irt.pipes.SamplePipes.*;

(Message message) -&gt; {
The message is: {@message.message|uppercase}
}
</code></pre>
                    <p>Several built-in pipes are provided in the module in the <code>Pipes</code>, <code>StreamPipes</code> and <code>PublisherPipes</code> classes. The <code>Pipes</code> class provides pipes used to tranform simple data object before rendering such as strings, dates and numbers. The <code>StreamPipes</code> and <code>PublisherPipes</code> provide pipes used to transformed streams and publishers typically in an apply template statement.</p>
                    <p>For instance the following example sort a list of items and map them to their datetime before applying templates:</p>
                    <pre><code class="language-plaintext">import static io.inverno.mod.irt.Pipes.*;
import static io.inverno.mod.irt.PublisherPipes.*;

import java.time.format.DateTimeFormatter;

(Publisher&lt;Item&gt; items) -&gt; {
    {items|sort|map(Item::getDateTime)}
}

(ZonedDateTime datetime) -&gt; {
    {@datetime|dateTime(DateTimeFormatter.ISO_DATE_TIME)}
}
</code></pre>
                    <h4 id="modes">Modes</h4>
                    <p>Template set classes are generated by the Inverno reactive template compiler plugin. Depending on the modes specified in the template set options, the resulting class will expose different <code>render()</code> methods with different outputs.</p>
                    <h5 id="string-2">STRING</h5>
                    <p>The <strong>STRING</strong> mode is the default resulting in the generation of <code>render()</code> methods that return a <code>CompletableFuture&lt;String&gt;</code> which completes once the input data has been fully rendered into the resulting String. For instance, assuming we have created a <code>Simple.irt</code> template set containing a template to render <code>Message</code> object, we can render a <code>Message</code> to a String as follows:</p>
                    <pre><code class="language-java">String result = Simple.string().render(new Message("some important message", true)).get();
</code></pre>
                    <p>The rendering process start as soon as the <code>render()</code> method is invoked, the <code>get()</code> operation on the resulting <code>CompletableFuture</code> waits until the message has been fully rendered. In this particular example, the whole process is synchronous since the input data is available from the start but keep in mind that this might not always be the case especially when <code>Publisher</code> objects are rendered in the process.</p>
                    <h5 id="bytebuf">BYTEBUF</h5>
                    <p>The <strong>BYTEBUF</strong> has a similar behavior except that data are rendered in a <strong>ByteBuf</strong>:</p>
                    <pre><code class="language-java">ByteBuf result = Simple.bytebuf().render(new Message("some important message", true)).get();
</code></pre>
                    <p>It is possible to provide the <code>ByteBuf</code> instance into which data should be rendered by defining a factory:</p>
                    <pre><code class="language-java">ByteBuf result = Simple.bytebuf(() -&gt; Unpooled.unreleasableBuffer(Unpooled.buffer())).render(new Message("some important message", true)).get();
</code></pre>
                    <p>This can be useful to optimize memory as it allows to reuse <code>ByteBuf</code> instances or specify direct or pooled <code>ByteBuf</code>.</p>
                    <blockquote>
                        <p>Note that the <code>BYTEBUF</code> requires <code>io.netty.common</code> and <code>io.netty.buffer</code> modules which must be declared explicitly in the module descriptor.</p>
                    </blockquote>
                    <h5 id="stream">STREAM</h5>
                    <p>The <strong>STREAM</strong> mode is used to render data in an <code>OutputStream</code>:</p>
                    <pre><code class="language-java">ByteArrayOutputStream result = Simple.stream(() -&gt; new ByteArrayOutputStream()).render(new Message("some important message", true)).get();
</code></pre>
                    <h5 id="publisher_">PUBLISHER_*</h5>
                    <p>Finally the <strong>PUBLISHER_STRING</strong> and <strong>PUBLISHER_BYTEBUF</strong> modes are used to generate fully reactive rendering methods which return <code>Publisher&lt;String&gt;</code> and <code>Publisher&lt;ByteBuf&gt;</code> respectively. Unlike previous modes, the rendering process starts when a subscription is made on the returned <code>Publisher</code> which can emits partial rendering result whenever a partial data is rendered.</p>
                    <pre><code class="language-java">String result = Flux.from(Simple.publisherString().render(new Message("some important message", true))).collect(Collectors.joining()).block();
</code></pre>
                    <p>If you consider small data set and require very high performance, you should prefer non-reactive modes. If your concern is more about resources, considering a large amount of data that you do not want to load into memory at once or progressive rendering you should prefer reactive modes which might have a slight decrease in performance.</p>
                    <blockquote>
                        <p>Note that the <code>BYTEBUF</code> requires <code>io.netty.common</code> and <code>io.netty.buffer</code> modules which must be declared explicitly in the module descriptor.</p>
                    </blockquote>
                    <h3 id="sql-client">SQL Client</h3>
                    <p>The Inverno SQL client module specifies a reactive API for executing SQL statement on a RDBMS.</p>
                    <p>This module only exposes the API and a proper implementation module must be considered to obtain <code>SqlClient</code> instances.</p>
                    <p>In order to use the Inverno <em>SQL client</em> module, we need to declare a dependency to the API and at least one implementation in the module descriptor:</p>
                    <pre><code class="language-java">module io.inverno.example.app {
    ...
    requires io.inverno.mod.sql; // this is actually optional since implementations should already define a transitive dependency
    requires io.inverno.mod.sql.vertx; // Vert.x implementation
    ...
}
</code></pre>
                    <p>And also declare these dependencies in the build descriptor:</p>
                    <p>Using Maven:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-sql&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-sql-vertx&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <p>Using Gradle:</p>
                    <pre><code class="language-java">...
compile 'io.inverno.mod:inverno-sql:1.5.2'
compile 'io.inverno.mod:inverno-sql-vertx:1.5.2'
...
</code></pre>
                    <h4 id="sql-client-api">SQL client API</h4>
                    <p>The Sql client API defines the <code>SqlClient</code> interface which provides reactive methods to execute SQL statements on a RDBMS.</p>
                    <h5 id="query-and-update">Query and update</h5>
                    <p>The <code>SqlClient</code> extends the <code>SqlOperations</code> interface which defines methods for common RDBMS operations such as query or update in addition to the more general statements and prepared statements.</p>
                    <p>We can query a database as follows:</p>
                    <pre><code class="language-java">SqlClient client = ...

Flux&lt;Person&gt; persons = Flux.from(
    client.query("SELECT * FROM person")
)
.map(row -&gt; new Person(row.getString("firstname"), row.getString("name"), row.getLocalDate("birthdate"))); // Map the resulting rows

persons.subscribe(...); // The query is executed on subscribe following reactive principles
</code></pre>
                    <p>Prepared queries are also supported:</p>
                    <pre><code class="language-java">Publisher&lt;Row&gt; results = client.query("SELECT * FROM person WHERE name = $1", "John");
</code></pre>
                    <p>A row mapping function can be specified directly in the query as well</p>
                    <pre><code class="language-java">Publisher&lt;Person&gt; results = client.query(
    "SELECT * FROM person WHERE name = $1", 
    row -&gt; new Person(row.getString("firstname"), row.getString("name"), row.getLocalDate("birthdate")), 
    "Smith"
);
</code></pre>
                    <p>A single result can also be queried as follows:</p>
                    <pre><code class="language-java">Mono&lt;Person&gt; person = client.queryForObject( // only consider the first row in the results
    "SELECT * FROM person WHERE name = $1", 
    row -&gt; new Person(row.getString("firstname"), row.getString("name"), row.getLocalDate("birthdate")),
    "Smith"
);
</code></pre>
                    <blockquote>
                        <p>The two previous examples are actually optimizations of the first one which enable implementations to optimize the query, resulting in faster execution.</p>
                    </blockquote>
                    <p>The database can be updated as follows:</p>
                    <pre><code class="language-java">client.update(
    "UPDATE person SET birthdate = $1 WHERE id = $2", 
    LocalDate.of(1970, 1, 1), 123
);
</code></pre>
                    <p>It can also be updated in a batch as follows:</p>
                    <pre><code class="language-java">client.batchUpdate(
    "UPDATE person SET birthdate = $1 WHERE id = $2", 
    List.of(
        new Object[]{ LocalDate.of(1970, 1, 1), 123 },
        new Object[]{ LocalDate.of(1980, 1, 1), 456 },
        new Object[]{ LocalDate.of(1990, 1, 1), 789 }
    )
);
</code></pre>
                    <blockquote>
                        <p>Note that all these operations use prepared statements which protect against SQL injection attacks.</p>
                    </blockquote>
                    <h5 id="statements">Statements</h5>
                    <p>The <code>SqlClient</code> also defines methods to create more general statements and prepared statements.</p>
                    <p>A static statement can be created and executed as follows:</p>
                    <pre><code class="language-java">SqlClient client = ...

Publisher&lt;SqlResult&gt; results = client.statement("SELECT * FROM person").execute();

// The statement is executed on subscribe following reactive principles
results.subscribe(...);
</code></pre>
                    <p>The execution of a statement returns <code>SqlResult</code> for each SQL operations in the statement in a publisher.</p>
                    <p>The <code>SqlResult</code> exposes row metadata and depending on the operation type either the number of rows affected by the operation (<code>UPDATE</code> or <code>DELETE</code>) or the resulting rows (<code>SELECT</code>).</p>
                    <p>Following preceding example:</p>
                    <pre><code class="language-java">Flux&lt;Person&gt; persons = Flux.from(client.statement("SELECT * FROM person").execute())
    .single() // Make sure we have only one result
    .flatMapMany(SqlResult::rows)
    .map(row -&gt; new Person(row.getString("firstname"), row.getString("name"), row.getLocalDate("birthdate")))

persons.subscribe(...);
</code></pre>
                    <p>Queries can also be fluently appended to a statement as follows:</p>
                    <pre><code class="language-java">Publisher&lt;SqlResult&gt; results = client
    .statement("SELECT * FROM person")
    .and("SELECT * FROM city")
    .and("SELECT * FROM country")
    .execute();
</code></pre>
                    <p>Unlike prepared statements, static statements are not pre-compiled and do not protect against SQL injection attacks which is why prepared statements should be preferred when there is a need for performance, dynamic or user provided queries.</p>
                    <p>A prepared statement can be created and executed as follows:</p>
                    <pre><code class="language-java">SqlClient client = ...

Publisher&lt;SqlResult&gt; results = client.preparedStatement("SELECT * FROM person WHERE name = $1")
    .bind("Smith") // bind the query argument
    .execute();

// The statement is executed on subscribe following reactive principles
results.subscribe(...);
</code></pre>
                    <p>As for a static statement, a prepared statement returns <code>SqlResult</code> for each SQL operations in the statement, however it is not possible to specify multiple operation in a prepared statement. But it is possible to transform it into a batch which will result in multiple operations and therefore multiple <code>SqlResult</code>.</p>
                    <p>In order to create a batch statement, we must bind multiple query arguments as follows:</p>
                    <pre><code class="language-java">Publisher&lt;SqlResult&gt; results = client.preparedStatement("SELECT * FROM person WHERE name = $1")
    .bind("Smith")         // first query
    .and().bind("Cooper")  // second query
    .and().bind("Johnson") // third query
    .execute();

// Returns 3 since we have created a batch statement with three queries
long resultCount = Flux.from(results).count().block();
</code></pre>
                    <h5 id="transactions">Transactions</h5>
                    <p>The API provides two ways to execute statement in a transaction which can be managed explicitly or implicitly.</p>
                    <p>We can choose to manage transaction explicitly by obtaining a <code>TransactionalSqlOperations</code> which exposes <code>commit()</code> and <code>rollback()</code> methods that we must invoke explicitly to close the transaction:</p>
                    <p>In the following example we perform a common <code>SELECT/UPDATE</code> operation within a transaction:</p>
                    <pre><code class="language-java">SqlClient client = ...

final float debit = 42.00f;
final int accountId = 1;

Mono&lt;Integer&gt; affectedRows = Mono.usingWhen(
    client.transaction(), 
    tops -&gt; tops
        .queryForObject("SELECT balance FROM account WHERE id = $1", row -&gt; row.getFloat(0), accountId)
        .flatMap(balance -&gt; ops
            .update("UPDATE account SET balance = $1 WHERE id = $2", balance - debit, accountId)
            .doOnNext(rowCount -&gt; {
                if(balance - debit &lt; 0) {
                    throw new IllegalStateException();
                }
            })
        )
    ,
    tops -&gt; {                                // Complete
        // extra processing before commit
        // ...
        
        return tops.commit();
    },
    (tops, ex) -&gt; {                          // Error
        // extra processing before roll back
        // ...
        
        return tops.rollback();
    }, 
    tops -&gt; {                                // Cancel
        // extra processing before commit
        // ...
        
        return tops.rollback();
    }
);

// On subscribe, a transaction is created, the closure method is invoked and the transaction is explicitly committed or rolled back when the publisher terminates.
affectedRows.subscribe(...);
</code></pre>
                    <p>The following example does the same but with implicit transaction management:</p>
                    <pre><code class="language-java">SqlClient client = ...

final float debit = 42.00f;
final int accountId = 1;

Publisher&lt;Integer&gt; affectedRows = client.transaction(ops -&gt; ops
    .queryForObject("SELECT balance FROM account WHERE id = $1", row -&gt; row.getFloat(0), accountId)
    .flatMap(balance -&gt; ops
        .update("UPDATE account SET balance = $1 WHERE id = $2", balance - debit, accountId)
        .doOnNext(rowCount -&gt; {
            if(balance - debit &lt; 0) {
                throw new IllegalStateException();
            }
        })
    )
);

// Same as before but the transaction is implicitly committed or rolled back
affectedRows.subscribe(...);
</code></pre>
                    <blockquote>
                        <p>Note that transactions might not be supported by all implementations, for instance the Vert.x pooled client implementation does not support transactions and an <code>UnsupportedOperationException</code> will be thrown if you try to create a transaction.</p>
                    </blockquote>
                    <h5 id="connections">Connections</h5>
                    <p>Some <code>SqlClient</code> implementations backed by a connection pool for instance can be used to execute multiple SQL statements on a single connection released once the resulting publisher terminates (either closed or returned to the pool).</p>
                    <p>For instance we can execute multiple statements on a single connection as follows:</p>
                    <pre><code class="language-java">SqlClient client = ...

final int postId = 1;

client.connection(ops -&gt; ops
    .queryForObject("SELECT likes FROM posts WHERE id = $1", row -&gt; row.getInteger(0), postId)
    .flatMap(likes -&gt; ops.update("UPDATE posts SET likes = $1 WHERE id = $2", likes + 1, postId))
);
</code></pre>
                    <h4 id="vertx-sql-client-implementation">Vert.x SQL Client implementation</h4>
                    <p>The Inverno Vert.x SQL client module is an implementation of the SQL client API on top of the <a href="https://github.com/eclipse-vertx/vertx-sql-client">Vert.x Reactive SQL client</a>.</p>
                    <p>It provides multiple <code>SqlClient</code> implementations that wrap Vert.x SQL pooled client, pool or connection and exposes a <code>SqlCLient</code> bean created from the module's configuration and backed by a Vert.x pool. It can be used to execute SQL statements in an application.</p>
                    <p>In order to use the Inverno <em>Vert.x SQL client</em> module, we need to declare a dependency in the module descriptor:</p>
                    <pre><code class="language-java">module io.inverno.example.app {
    ...
    requires io.inverno.mod.sql.vertx;
    ...
}
</code></pre>
                    <p>And also declare this dependency as well as a dependency to the Vert.x implementation corresponding to the RDBMS we are targeting in the build descriptor:</p>
                    <p>Using Maven:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-sql-vertx&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.vertx&lt;/groupId&gt;
            &lt;artifactId&gt;vertx-pg-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <p>Using Gradle:</p>
                    <pre><code class="language-java">...
compile 'io.inverno.mod:inverno-sql-vertx:1.5.2'
compile 'io.vertx:vertx-pg-client:4.1.2'
...
</code></pre>
                    <h5 id="configuration-4">Configuration</h5>
                    <p>The <code>VertxSqlClientConfiguration</code> is used to create and configure the SQL client bean exposed by the module.</p>
                    <p>Please refer to the <a href="https://inverno.io/docs/release/api/index.html">API documentation</a> to have an exhaustive description of the different configuration properties.</p>
                    <h5 id="sql-client-bean">Sql Client bean</h5>
                    <p>The module exposes a <code>SqlClient</code> bean which is backed by a Vert.x pool. It is created using the configuration and especially the <code>db_uri</code> property whose scheme indicates the RDBMS system and therefore the Vert.x pool implementation to use.</p>
                    <p>For instance, the following configuration can be used to connect to a PostgreSQL database:</p>
                    <pre><code class="language-plaintext">db_uri="postgres://user:password@localhost:5432/sample_db"
</code></pre>
                    <blockquote>
                        <p>If you want to connect to a particular RDBMS, don't forget to add a dependency to the corresponding Vert.x SQL client implementation. Vert.x currently supports DB2, MSSQL, MySQL, PostgreSQL and Oracle.</p>
                    </blockquote>
                    <p>The connection pool can be configured as well:</p>
                    <pre><code class="language-plaintext">pool_maxSize=20
</code></pre>
                    <p>Please refer to the <a href="https://vertx.io/docs/#databases">Vert.x database documentation</a> to get the options supported for each RDBMS implementations.</p>
                    <p>The Vert.x SQL client requires a <code>Vertx</code> instance which is provided in the Inverno application reactor when using a <code>VertxReactor</code>, otherwise a dedicated <code>Vertx</code> instance is created. In any case, this instance can be overridden by providing a custom one to the module.</p>
                    <h5 id="vertx-wrappers">Vert.x wrappers</h5>
                    <p>Depending on our needs, we can also choose to create a custom <code>SqlClient</code> using one the Vert.x SQL client wrappers provided by the module.</p>
                    <p>The <code>ConnectionSqlClient</code> wraps a Vert.x SQL connection, you can use to transform a single connection obtained via a Vert.x connection factory into a reactive <code>SqlClient</code>.</p>
                    <p>The <code>PooledClientSqlClient</code> wraps a Vert.x pooled SQL client that supports pipelining of queries on a single configuration for optimized performances. This implementation doesn't support transactions.</p>
                    <pre><code class="language-java">SqlClient client = new PooledClientSqlClient(PgPool.client(...));
</code></pre>
                    <p>Finally, the <code>PoolSqlClient</code> wraps a Vert.x SQL pool. This is a common implementation supporting transactions and result streaming, it is used to create the module's SQL client bean.</p>
                    <pre><code class="language-java">SqlClient client = new PoolSqlClient(PgPool.pool(...));
</code></pre>
                    <h3 id="redis-client">Redis Client</h3>
                    <p>The Inverno Redis client module specifies a reactive API for executing commands on a <a href="https://redis.io/">Redis</a> data store.</p>
                    <p>This module only exposes the API and a proper implementation module must be considered to obtain <code>RedisClient</code> instances.</p>
                    <p>In order to use the Inverno <em>Redis client</em> module, we need to declare a dependency to the API and at least one implementation in the module descriptor:</p>
                    <pre><code class="language-java">module io.inverno.example.app {
    ...
    requires io.inverno.mod.redis; // this is actually optional since implementations should already define a transitive dependency
    requires io.inverno.mod.redis.lettuce; // Lettuce implementation
    ...
}
</code></pre>
                    <p>And also declare these dependencies in the build descriptor:</p>
                    <p>Using Maven:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-redis-lettuce&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <p>Using Gradle:</p>
                    <pre><code class="language-java">...
compile 'io.inverno.mod:inverno-redis:1.5.2'
compile 'io.inverno.mod:inverno-redis-vertx:1.5.2'
...
</code></pre>
                    <h4 id="redis-client-api">Redis Client API</h4>
                    <p>The Redis client API defines the <code>RedisClient</code> and <code>RedisTransactionalClient</code> interfaces which provide reactive methods to create and execute <a href="https://redis.io/commands">Redis commands</a>.</p>
                    <p>The <code>RedisTransactionalClient</code> interface extends the <code>RedisClient</code> interface with Redis transactional support (ie. <code>MULTI</code>, <code>DISCARD</code>, <code>EXEC</code>...).</p>
                    <h5 id="redis-operations">Redis Operations</h5>
                    <p>The API exposes mutiple <code>*Operations</code> interfaces which are all extended by the <code>RedisCLient</code> and which allows to fluently send commands to a Redis data store.</p>
                    <p>There are currently ten such interfaces that exposes the &gt;200 commands supported in Redis:</p>
                    <ul>
                        <li><code>RedisHashReactiveOperations</code></li>
                        <li><code>RedisKeyReactiveOperations</code></li>
                        <li><code>RedisScriptingReactiveOperations</code></li>
                        <li><code>RedisSortedSetReactiveOperations</code></li>
                        <li><code>RedisStringReactiveOperations</code></li>
                        <li><code>RedisGeoReactiveOperations</code></li>
                        <li><code>RedisHLLReactiveOperations</code></li>
                        <li><code>RedisListReactiveOperations</code></li>
                        <li><code>RedisSetReactiveOperations</code></li>
                        <li><code>RedisStreamReactiveOperations</code></li>
                    </ul>
                    <p>The API is pretty straighfoward and provides guidance on how to create and send commands to the Redis data store. For instance a simple string value can be queried as follows:</p>
                    <pre><code class="language-java">RedisClient&lt;String, String&gt; client = ...

Mono&lt;String&gt; getSomeKey = client.get("someKey");

// The command is sent on subscribe following reactive principles
getSomeKey.subscribe(...);
</code></pre>
                    <p>Complex commands are created using builders, for instance command <code>ZRANGE mySortedSet 0 +inf BYSCORE REV LIMIT 0 1 WITHSCORES</code> can be created and executed as follows:</p>
                    <pre><code class="language-java">RedisClient&lt;String, String&gt; client = ...

Flux&lt;SortedSetScoredMember&lt;String&gt;&gt; zrangeWithScores = client.zrangeWithScores()
    .reverse()
    .byScore()
    .limit(0, 1)
    .build("mySortedSet", Bound.inclusive(0), Bound.unbounded());

// The command is sent on subscribe following reactive principles
zrangeWithScores.subscribe(...);
</code></pre>
                    <h5 id="keys-and-values-codecs">Keys and Values codecs</h5>
                    <p>The <code>RedisClient</code> supports encoding and decoding of Redis keys and values, as a result the <code>RedisClient</code> client is a generic type which allows to specified the types of key and values.</p>
                    <p>The actual encoding/decoding logic is implementation specific.</p>
                    <h5 id="connections-1">Connections</h5>
                    <p>Commands can be executed directly on the client instance in which case a connection is obtained each time an operation method is invoked on the client and released once the resulting publisher terminates. This might not be an issue when a single command is issued or when using an implementation based on a single connection, However if there's a need to exectute multiuple commands or when using an implementation backed by a connection pool, it is often better to execute multiple SQL statements on a single connection released once the resulting publisher terminates (the connection can be either closed or returned to the pool).</p>
                    <p>Multiple commands can be executed on a single connection as follows:</p>
                    <pre><code class="language-java">RedisClient&lt;String, String&gt; client = ...

Flux&lt;String&gt; results = Flux.from(client.connection(operations -&gt; 
    Flux.concat(
        operations.get("key1"),
        operations.get("key2"),
        operations.get("key3")
    )
));

// Commands are sent sent on subscribe following reactive principles
results.subscribe(...);
</code></pre>
                    <h5 id="batch">Batch</h5>
                    <p>Commands can also be executed in batch, delaying the network flush so that multiple commands are sent to the server in one shot. This can have a significant positive impact on performances as the client doesn't have to wait for a response to send the next command.</p>
                    <p>A batch of commands can be executed as follows:</p>
                    <pre><code class="language-java">RedisClient&lt;String, String&gt; client = ...

Flux&lt;String&gt; results = Flux.from(client.batch(operations -&gt; 
    Flux.just(
        operations.get("key1"),
        operations.get("key2"),
        operations.get("key3")
    )
));

// Commands are sent on subscribe following reactive principles
results.subscribe(...);
</code></pre>
                    <h5 id="transactions-1">Transactions</h5>
                    <p>Redis supports transactions through <code>MULTI</code>, <code>EXEC</code> and <code>DISCARD</code> commands which is a bit different than traditional begin/commit/rollback we can find in RDBMS. Please have a look at <a href="https://redis.io/topics/transactions">Redis trasnactions documentation</a> to have a proper understanding on how transactions work in Redis.</p>
                    <p>Commands can be executed within a transaction using a <code>RedisTransactionalClient</code>, a transaction can be managed implicitly or explicitly by obtaining a <code>RedisTransactionalOperations</code> and explicitly invoke <code>exec()</code> or <code>rollback()</code>.</p>
                    <p>In the following example, two <code>SET</code> commands are executed within a transaction, when subscribing to the returned <code>Mono&lt;RedisTransactionResult&gt;</code>, the two set publishers are subscribed on and the transaction is executed implicitly and a <code>RedisTransactionResult</code> is eventually emitted and holds transaction results:</p>
                    <pre><code class="language-java">RedisClient&lt;String, String&gt; client = ...

Mono&lt;RedisTransactionResult&gt; transaction = client
    .multi(operations -&gt; 
        Flux.just(
            operations.set("key_1", "value_1"), 
            operations.set("key_2", "value_2")
        )
    );

// Commands are sent on subscribe following reactive principles
RedisTransactionResult result = transaction.block();

if(!result.wasDiscarded()) {
    Assertions.assertEquals("OK", result.get(0));
    Assertions.assertEquals("OK", result.get(1));
}
else {
    // Report error
}
</code></pre>
                    <p>If any error is raised during the processing, typically when the client subscribes to the returned command publishers, the transaction is discarded.</p>
                    <p>The same transaction can be explicitly managed as follows:</p>
                    <pre><code class="language-java">RedisClient&lt;String, String&gt; client = ...

Mono&lt;RedisTransactionResult&gt; transaction = client
    .multi()
    .flatMap(operations -&gt; {
        operations.set("key_1", "value_1").subscribe();
        operations.set("key_2", "value_2").subscribe();

        return operations.exec();
    });

// Commands are sent on subscribe following reactive principles
RedisTransactionResult result = transaction.block();
</code></pre>
                    <p>In above example, it is important to subscribe to command publishers explicitly otherwise they won't be part of the transaction.</p>
                    <p>Redis uses optimistic locking using check-and-set through the <code>WATCH</code> command which is used to indicate which keys should be monitored for changes during a transaction. When creating a transaction, it is possible to specified watches that would discard the transaction if any change is detected.</p>
                    <p>For instance, the following transaction will be discarded if the value of key <code>key_3</code> is changed after the transaction begin:</p>
                    <pre><code class="language-java">RedisClient&lt;String, String&gt; client = ...

Mono&lt;RedisTransactionResult&gt; transaction = client
    .multi("key_3") // watch 'key_3'
    // let's change the value of 'key_3' using another connection to get the transaction discarded
    .doOnNext(ign -&gt; client.set("key_3", "value_3").block()) 
    .flatMap(operations -&gt; {
        operations.set("key_3", "value_3").subscribe();
        
        return operations.exec();
    });

RedisTransactionResult result = transaction.block();

// Transaction was discarded since 'key_3' changed before the transaction after the start of the transaction and before it ended
Assertions.assertTrue(result.wasDiscarded());
</code></pre>
                    <h4 id="lettuce-redis-client-implementation">Lettuce Redis Client implementation</h4>
                    <p>The Inverno Lettuce Redis client module is an implementation of the Redis client API on top of the <a href="https://lettuce.io">Lettuce client</a>.</p>
                    <p>It provides <code>PoolRedisClient</code> and <code>PoolRedisClusterClient</code> implementations that wrap a Lettuce <code>AsyncPool</code> used to acquire <code>StatefulRedisConnection</code> and <code>StatefulRedisClusterConnection</code> respectively. The <code>PoolRedisClusterClient</code> doesn't implement <code>RedisTransactionalClient</code> since transactions are not supported by Redis in a clustered environment.</p>
                    <p>The module also exposes a <code>RedisClient&lt;String, String&gt;</code> bean created from the module's configuration and backed by a Lettuce <code>BoundedAsyncPool&lt;StatefulRedisConnection&lt;String, String&gt;&gt;</code> instance.</p>
                    <p>SQL pooled client, pool or connection and exposes a <code>RedisCLient</code> bean created from the module's configuration and backed by a Vert.x pool. It can be used to execute SQL statements in an application.</p>
                    <p>In order to use the Inverno <em>Lettuce Redis client</em> module, we need to declare a dependency in the module descriptor:</p>
                    <pre><code class="language-java">module io.inverno.example.app {
    ...
    requires io.inverno.mod.redis.lettuce;
    ...
}
</code></pre>
                    <p>And also declare this dependencies in the build descriptor:</p>
                    <p>Using Maven:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-redis-lettuce&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <p>Using Gradle:</p>
                    <pre><code class="language-java">...
compile 'io.inverno.mod:inverno-redis-lettuce:1.5.2'
...
</code></pre>
                    <h5 id="configuration-5">Configuration</h5>
                    <p>The <code>LettuceRedisClientConfiguration</code> is used to create and configure the Redis client bean exposed by the module.</p>
                    <p>Please refer to the [API documentation][inverno-javadoc] to have an exhaustive description of the different configuration properties.</p>
                    <h5 id="redis-client-bean">Redis Client bean</h5>
                    <p>The module exposes a <code>RedisClient&lt;String, String&gt;</code> bean which is backed by a Lettuce <code>BoundedAsyncPool&lt;StatefulRedisConnection&lt;String, String&gt;&gt;</code> instance. It is created using the configuration and especially the <code>uri</code> property which specified the Redis server to connect to which is <code>redis://localhost:6379</code> by default</p>
                    <p>For instance, the following configuration can be used to connect to a remote Redis server:</p>
                    <pre><code class="language-plaintext">uri="redis://remoteRedis"
</code></pre>
                    <p>The connection pool can be configured as well:</p>
                    <pre><code class="language-plaintext">pool_max_active=8
pool_min_idle=0
pool_max_idle=8
</code></pre>
                    <p>Secured connection using TLS and/or authentication can also be configured as follows:</p>
                    <pre><code class="language-plaintext">tls=true
username=user
password=password
</code></pre>
                    <p>By default, this Redis client relies on a dedicated event loop group but it can also rely on Inverno's reactor when a <code>Reactor</code> instance is available. This is transparent when assembling an application with the <em>boot</em> module which exposes Inverno's reactor.</p>
                    <h5 id="lettuce-wrappers">Lettuce wrappers</h5>
                    <p>Depending on our needs, we can also choose to create a custom <code>RedisClient</code> using one the Lettuce Redis client wrappers provided by the module.</p>
                    <p>The <code>PoolRedisClient</code> implementation wraps a Lettuce <code>AsyncPool&lt;StatefulRedisConnection&lt;K, V&gt;&gt;</code>, it is then possible to create a <code>RedisClient</code> client instance using specific key/value codecs:</p>
                    <pre><code class="language-java">BoundedAsyncPool&lt;StatefulRedisConnection&lt;byte[], byte[]&gt;&gt; pool = AsyncConnectionPoolSupport.createBoundedObjectPool(
        () -&gt; this.client.connectAsync(ByteArrayCodec.INSTANCE, RedisURI.create("redis://localhost"), 
        BoundedPoolConfig.create()
    );
	RedisClient&lt;byte[], byte[]&gt; byteArrayClient = new PoolRedisClient&lt;&gt;(pool, byte[].class, byte[].class);
</code></pre>
                    <p>The <code>PoolRedisClusterClient</code> implementation should be used to connect to a Redis cluster, it wraps a Lettuce <code>AsyncPool&lt;StatefulRedisClusterConnection&lt;K, V&gt;&gt;</code></p>
                    <h3 id="ldap">LDAP</h3>
                    <p>The Inverno LDAP client module specifies a basic reactive API for interacting with an LDAP or Active Directory server.</p>
                    <p>It also provides a default JDK based implementation of the <code>LDAPClient</code> exposed in the module.</p>
                    <p>This module requires an <code>ExecutorService</code> used to execute JDK blocking operations in separate thread. The <em>boot</em> module provides a global worker pool which is ideal in such situations, so in order to use the Inverno <em>ldap</em> module, we should declare the following dependencies in the module descriptor:</p>
                    <pre><code class="language-java">@io.inverno.core.annotation.Module
module io.inverno.example.app {
    ...
    requires io.inverno.mod.boot;
    requires io.inverno.mod.ldap;
    ...
}
</code></pre>
                    <p>And also declare these dependencies in the build descriptor:</p>
                    <p>Using Maven:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-boot&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-ldap&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <p>Using Gradle:</p>
                    <pre><code class="language-java">...
compile 'io.inverno.mod:inverno-boot:1.5.2'
compile 'io.inverno.mod:inverno-ldap:1.5.2'
...
</code></pre>
                    <h4 id="configuration-6">Configuration</h4>
                    <p>The <code>LDAPClientConfiguration</code> is used to create and configure the JDK based LDAP client bean exposed by the module.</p>
                    <p>Please refer to the <a href="https://inverno.io/docs/release/api/index.html">API documentation</a> to have an exhaustive description of the different configuration properties.</p>
                    <h4 id="ldap-client-api">LDAP Client API</h4>
                    <p>The LDAP client API defines the <code>LDAPClient</code> interface which provides reactive methods to bind, search and get LDAP entries in an LDAP server.</p>
                    <h5 id="ldap-operations">LDAP Operations</h5>
                    <p>The API exposes <code>LDAPOperations</code> interface which is extended by the <code>LDAPCLient</code> and which allows to fluently send commands to the LDAP server.</p>
                    <h6 id="bind">Bind</h6>
                    <p>The <code>bind()</code> method exposed on the <code>LDAPClient</code> allows to authenticate a user and obtain an <code>LDAPOperations</code> instance bound to that user.</p>
                    <p>The following is a complete example where user <code>jsmith</code> is authenticated and multiple operations are executed on the bound <code>LDAPOperations</code> instance.</p>
                    <pre><code class="language-java">String uid = "jsmith";
String userDN = "cn=jsmith,ou=users,dc=inverno,dc=io";
User user = Mono.from(client.bind(
        "cn={0},ou=users,dc=inverno,dc=io",
        new Object[] {uid},
        "password", 
        ops -&gt; ops.search(userDN, new String[] {"uid"}, "(&amp;(objectClass=inetOrgPerson)(uid={0}))", uid)
            .flatMap(userEntry -&gt; ops.search("dc=inverno,dc=io", new String[]{ "cn" }, "(&amp;(objectClass=groupOfNames)(member={0}))", userEntry.getDN())
                .map(groupEntry -&gt; groupEntry.getAttribute("cn").map(LDAPAttribute::asString).get())
                .collectList()
                .map(groups -&gt; new User(userEntry.getDN(), userEntry.getAttribute("uid").map(LDAPAttribute::asString).get(), groups)))
            )
    )
    .block();
</code></pre>
                    <p>As stated before, the <code>LDAPClient</code> extends <code>LDAPOperations</code> and any operations can then be directly invoked on the client instance. Whether an LDAP client instance is authenticated or not on the LDAP server is implementation specific.</p>
                    <h6 id="get-a-single-entry">Get a single entry</h6>
                    <p>A single entry identified by a specific <code>DN</code> can be retrieved as follows:</p>
                    <pre><code class="language-java">LDAPOperations operations = ...

LDAPEntry jsmithEntry = operations.get("cn=jsmith,ou=users,dc=inverno,dc=io").block();
</code></pre>
                    <p>The <code>DN</code> can also be specified as a templatized expression using <code>{i}</code> notation and a list or arguments:</p>
                    <pre><code class="language-java">LDAPOperations operations = ...

LDAPEntry jsmithEntry = operations.get("cn={0},ou=users,dc=inverno,dc=io", "jsmith").block();
</code></pre>
                    <p>It is also possible to specify which attributes must be retrieved:</p>
                    <pre><code class="language-java">LDAPOperations operations = ...

LDAPEntry jsmithEntry = operations.get("cn={0},ou=users,dc=inverno,dc=io", new String[] {"cn", "uid", "mail", "userPassword"}, "jsmith").block();
</code></pre>
                    <p>LDAP Attributes are exposed on the resulting <code>LDAPEntry</code>, raw attribute values can be obtained as follows:</p>
                    <pre><code class="language-java">// Gets the value of attribute 'mail' or null
// if multiple 'mail' attributes are defined, one of them is returned in a non-deterministic way
Object mail = jsmithEntry.get("mail").orElse(null);

// Gets all values for attribute 'mail' or an empty list
List&lt;Object&gt; allMail = jsmithEntry.getAll("mail");

// Get all attributes 
List&lt;Map.Entry&lt;String, Object&gt;&gt; all = jsmithEntry.getAll();
</code></pre>
                    <p>It is also possible to get attributes as convertible <code>LDAPAttribute</code> as follows:</p>
                    <pre><code class="language-java">// Gets the value of attribute 'birthDate' as a local date or null
// if multiple 'birthDate' attributes are defined, one of them is returned in a non-deterministic way
LocalDate birthDate = jsmithEntry.getAttribute("birthDate").map(LDAPAttribute::asLocalDate).orElse(null);

// Gets all values for attribute 'address' as strings or an empty list
List&lt;String&gt; addresses = jsmithEntry.getAllAttribute("address").stream().map(LDAPAttribute::asString).collect(Collectors.toList());

// Get all attributes
List&lt;LDAPAttribute&gt; allAttribute = jsmithEntry.getAllAttribute();
</code></pre>
                    <h6 id="search">Search</h6>
                    <p>We can search for entries using a base context and a filter expression. In the following example we search for <code>inetOrgPerson</code> class entries with <code>CN</code> and <code>UID</code> attributes in the <code>users</code> organizational unit:</p>
                    <pre><code class="language-java">List&lt;LDAPEntry&gt; result = client.search("ou=users,dc=inverno,dc=io", new String[] {"cn", "uid"}, "(objectClass=inetOrgPerson)")
    .collectList()
    .block();
</code></pre>
                    <p>The filter can be templatized using the <code>{i}</code> notation. In the following we search for the groups user <code>jsmith</code> belongs to:</p>
                    <pre><code class="language-java">List&lt;LDAPEntry&gt; result = client.search("dc=inverno,dc=io", new String[]{ "cn" }, "(&amp;(objectClass=groupOfNames)(member={0}))", "cn=jsmith,ou=users,dc=inverno,dc=io")
    .collectList()
    .block();
</code></pre>
                    <p>Complex queries can be created using a <code>SearchBuilder</code> which allows specifying a search scope among other things:</p>
                    <pre><code class="language-java">List&lt;LDAPEntry&gt; result = client.search()
    .scope(LDAPOperations.SearchScope.WHOLE_SUBTREE)
    .build("ou=users,dc=inverno,dc=io", new String[] {"cn", "uid"}, "(objectClass=inetOrgPerson)")
    .collectList()
    .block();
</code></pre>
                    <h4 id="ldap-client-bean">LDAP Client bean</h4>
                    <p>The module exposes an <code>LDAPClient</code> bean implemented using JDK <code>DirContext</code> to access the LDAP server. The client is created using the module's configuration which specifies:</p>
                    <ul>
                        <li>the LDAP server URI (e.g. <code>ldap://remoteLDAP:1389</code>)</li>
                        <li>the authentication choice (<code>simple</code> by default)</li>
                        <li>the referral policy (follow referrals by default)</li>
                        <li>the admin user <code>DN</code> which shall be used by default to connect to the server</li>
                        <li>the admin user credentials, typically a password</li>
                    </ul>
                    <p>If no admin user <code>DN</code> and credentials are specified the client connects to the server anonymously unless operations are executed inside a <code>bind()</code> invocation.</p>
                    <p>For instance, the following configuration can be used to connect to a remote LDAP server using an admin <code>DN</code>:</p>
                    <pre><code class="language-plaintext">uri="ldap://remoteLDAP:1389"
admin_dn="cn=admin,ou=users,dc=inverno,dc=io"
admin_credentials="admin_password"
</code></pre>
                    <blockquote>
                        <p>Since the JDK directory service interface uses blocking operations, the client also requires an <code>ExecutorService</code> to make it reactive by executing blocking operations in separate threads and make sure no blocking operation is ever run in a reactor I/O thread. The <em>boot</em> module typically provides a global worker pool that must be used in such situations but it is also possible to use a specific <code>ExecutorService</code> as well when this makes sense.</p>
                    </blockquote>
                    <h3 id="security">Security</h3>
                    <p>The Inverno <em>security</em> module defines an API for securing access to protected services or resources in an application.</p>
                    <p>Securing an application is a complex topic which involves multiple concerns such as authentication, identification, access control, cryptography... Over the years, many techniques and specifications were created to address these concerns and protect against always more complex attacks. Defining a generic security API that is consistent with all these aspects is therefore a tedious task.</p>
                    <p>The Inverno security API has been designed to follow a clear security model with the aim of simplifying security setup inside an application by relying on simple concepts in order to keep things manageable and understandable.</p>
                    <p>The Inverno security model, which basically defines application security, is based on three main concepts:</p>
                    <ul>
                        <li><strong>Authentication</strong> which relates to the authentification of a request made to the application.</li>
                        <li><strong>Identification</strong> which relates to the identification of the entity accessing the application.</li>
                        <li><strong>Access Control</strong> which relates to the control of access to protected services or resources in the application.</li>
                    </ul>
                    <p>The authentication process is about authenticating credentials (e.g. user/password, token...) provided in a request in order to assess whether access to the application is granted to a requesting entity. It is very important to understand that authentication is not about authenticating the entity but really the credentials. The entity represents the originator of a request to the application, it can be external or internal, it can be an application, a device, a proxy or an actual person but as far as the application is concerned, access can only be granted when valid credentials have been authenticated which is more related to the request than the actual entity behind that request. When refering to the <em>authenticated entity</em>, we simply refer to that entity behind a request which provided credentials that has been authenticated during the authentication process.</p>
                    <blockquote>
                        <p>This is actually an important point so let's take a concrete example to better understand what it means. Let's consider a prepaid card which allows for ten entries to a roller coaster, you can buy one and at the entrance pass it to your friends one after the other so you can all enjoy the ride. When passing the gates, it is the pass that is being authenticated not the person holding that pass.</p>
                    </blockquote>
                    <p>The identification process is about identifying the authenticated entity accessing the application. This goes beyond authentication whose role is, and we insisted on that, to validate that provided credentials are valid and which does not necessarily give any information about who or what is actually accessing the application.</p>
                    <p>The access control process is about controlling whether an authenticated entity has the proper clearance (e.g. roles, permissions...) to access specific services or resources within the application.</p>
                    <p>From these definitions, it is important to notice that although authentication, identification and access control are all related to an entity accessing the application, they are not necessarily related to each others. For instance <a href="https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-05">OAuth2</a> is a perfect example of authentication without identification. Then we can surely conceive multiple cases where we have authentication without access control, for example an opaque token can be authenticated which gives us no information about the roles or permissions of the authenticated entity. To sum up, a requesting entity can be authenticated, then maybe identified and we may be able to control the access to protected services or resources based on other information (e.g. roles, permissions...)</p>
                    <p>Let's consider a more practical example to illustrate the theory. Let's assume our secured application is actually a secured facility:</p>
                    <ul>
                        <li>a person can only enter the facility if he authenticates at the entrance by showing proper credentials: 
                            <ul>
                              <li>it can be a blank badge that gives him access to the facility but does not strongly identify him.</li>
                              <li>it can a badge with identification information which is actually useless to properly identify the person unless he can prove he is the actual owner of the badge (e.g. using biometric information).</li>
                              <li>it can be some kind of ID registered in the facility security system like a driver's license or an ID card. From there he can receive a temporary badge to access the rest of the facility (e.g. a visitor badge). In this case we might have some identification information but not necessarily what is needed to fully use the services offered inside the facility. Let's say the facility is a bank and the person is here to make a withdrawal, once inside the bank the ID card authenticated at the entrance does not give any information about the person's bank account and whether he is actually the owner of that bank account. These might be considered as identification information which require additional identification process.</li>
                              <li>it can be a registered fingerprint or any kind of biometric information which might also provide identification information assuming they are securely stored inside the facility security system.</li>
                            </ul></li>
                        <li>the person can then enter the facility and access areas or use services inside: 
                            <ul>
                              <li>there can be unsecured services, like a coffee machine in the lobby which anybody within the facility can use.</li>
                              <li>there can be restricted areas or services that require proper clearance to access. The person must then re-authenticate using the same credentials he used to enter the facility or using temporary credentials received at the entrance (e.g. visitor badge). Access control must then be performed and requires to have the person's clearances securely stored in the facility security system or inside the temporary credentials in which case they should ideally be signed and encrypted to guarantee both integrity (we don't want to let him forge his own clearances) and privacy (we don't want to let him know how access control works in the system).</li>
                              <li>there can be services that require further identification information which can be already available following the person's authentication or which require some additional verification. For instance, the facility can be a casino, anybody can access the restaurant area but the casino area is restricted to adults over 18.</li>
                            </ul></li>
                        <li>finally when leaving the facility, the person must return any temporary credentials he receveived (e.g. visitor badge in exchange from his ID card) or we can just let him go if those credentials have an expiration time and/or can be revoked anytime when we don't want him to use the facility anymore.</li>
                    </ul>
                    <p>An Inverno application is secured by composing authentication with identity and access controller inside a <strong>Security Context</strong> that implements application security requirements.</p>
                    <p>The <em>security</em> module defines the core security API and several extensions modules provide specific security features:</p>
                    <ul>
                        <li>the <em>security-http</em> module provides exchange interceptors and handlers to secure Web applications.</li>
                        <li>the <em>security-jose</em> module provides services to manipulate JSON Object Signing and Encryption token as specified by <a href="https://datatracker.ietf.org/doc/html/rfc7515">RFC 7515</a>, <a href="https://datatracker.ietf.org/doc/html/rfc7516">RFC 7516</a>, <a href="https://datatracker.ietf.org/doc/html/rfc7517">RFC 7517</a>, <a href="https://datatracker.ietf.org/doc/html/rfc7518">RFC 7518</a> and <a href="https://datatracker.ietf.org/doc/html/rfc7519">RFC 7519</a>.</li>
                        <li>the <em>security-ldap</em> module provides authenticators and identity resolvers to authenticate and identify an entity against an <a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol">LDAP</a> server or an <a href="https://en.wikipedia.org/wiki/Active_Directory">Active Directory</a> server.</li>
                    </ul>
                    <p>The complete security API including extension modules currently supports:</p>
                    <ul>
                        <li>User/password authentication against a user repository (in-memory, Redis...).</li>
                        <li>Token based authentication.</li>
                        <li>Strong user identification against a user repository (in-memory, Redis...).</li>
                        <li>Secured password encoding using message digest, <a href="https://en.wikipedia.org/wiki/Argon2">Argon2</a>, <a href="https://en.wikipedia.org/wiki/PBKDF2">Password-Based Key Derivation Function</a>, <a href="https://en.wikipedia.org/wiki/Bcrypt">BCrypt</a>, <a href="https://en.wikipedia.org/wiki/Scrypt">SCrypt</a>...</li>
                        <li><a href="https://en.wikipedia.org/wiki/Role-based_access_control">Role-based access control</a>.</li>
                        <li>Permission-based access control.</li>
                        <li>JSON Object Signing and Encryption (provided in the <em>security-jose</em> module).</li>
                        <li>LDAP/Active Directory authentication and identification (provided in the <em>security-ldap</em> module).</li>
                        <li>HTTP <a href="https://datatracker.ietf.org/doc/html/rfc7617">basic</a> authentication scheme (provided in the <em>security-http</em> module).</li>
                        <li>HTTP <a href="https://datatracker.ietf.org/doc/html/rfc7616">digest</a> authentication scheme (provided in the <em>security-http</em> module).</li>
                        <li>Form based authentication (provided in the <em>security-http</em> module).</li>
                        <li>Cross-origin resource sharing support (<a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a>) (provided in the <em>security-http</em> module).</li>
                        <li>Protection against Cross-site request forgery attack (<a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">CSRF</a>) (provided in the <em>security-http</em> module).</li>
                    </ul>
                    <p>In order to use the Inverno <em>security</em> module, we need to declare a dependency in the module descriptor:</p>
                    <pre><code class="language-java">module io.inverno.example.app {
    ...
    requires io.inverno.mod.security;
    ...
}
</code></pre>
                    <p>And also declare that dependency in the build descriptor:</p>
                    <p>Using Maven:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-security&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <p>Using Gradle:</p>
                    <pre><code class="language-java">...
compile 'io.inverno.mod:inverno-security:1.5.2'
...
</code></pre>
                    <p>Before looking into details of the security API, let's see how to secure a simple standalone application composed of a single <code>HelloService</code> bean exposing <code>sayHello()</code> method. Initially the application might look like:</p>
                    <pre><code class="language-java">package io.inverno.example.app_hello_security;

import io.inverno.core.annotation.Bean;

@Bean
public class HelloService {
    
    public void sayHello() {
        StringBuilder message = new StringBuilder();
        message.append("Hello world!");
        System.out.println(message.toString());
    }
}
</code></pre>
                    <pre><code class="language-java">package io.inverno.example.app_hello_security;

import io.inverno.core.v1.Application;

public class Main {
    
    public static void main(String[] args) {
        Application.run(new App_hello_security.Builder()).helloService().sayHello();
    }
}
</code></pre>
                    <p>Running the application would return the following output:</p>
                    <pre><code class="language-plaintext">$ mvn inverno:run
...
[INFO] Running project: io.inverno.example.app_hello_security@1.0.0-SNAPSHOT...
 [═══════════════════════════════════════════════ 100&nbsp;% ══════════════════════════════════════════════] 
15:59:29.395 [main] INFO  io.inverno.core.v1.Application - Inverno is starting...


     ╔════════════════════════════════════════════════════════════════════════════════════════════╗
     ║                      , ~~ ,                                                                ║
     ║                  , '   /\   ' ,                                                            ║
     ║                 , __   \/   __ ,      _                                                    ║
     ║                ,  \_\_\/\/_/_/  ,    | |  ___  _    _  ___   __  ___   ___                 ║
     ║                ,    _\_\/_/_    ,    | | / _ \\ \  / // _ \ / _|/ _ \ / _ \                ║
     ║                ,   __\_/\_\__   ,    | || | | |\ \/ /|  __/| | | | | | |_| |               ║
     ║                 , /_/ /\/\ \_\ ,     |_||_| |_| \__/  \___||_| |_| |_|\___/                ║
     ║                  ,     /\     ,                                                            ║
     ║                    ,   \/   ,                                  -- 1.5.1 --                 ║
     ║                      ' -- '                                                                ║
     ╠════════════════════════════════════════════════════════════════════════════════════════════╣
     ║ Java runtime        : OpenJDK Runtime Environment                                          ║
     ║ Java version        : 17.0.2+8-86                                                          ║
     ║ Java home           : /home/jkuhn/Devel/jdk/jdk-17.0.2                                     ║
     ║                                                                                            ║
     ║ Application module  : io.inverno.example.app_hello_security                                ║
     ║ Application class   : io.inverno.example.app_hello_security.Main                           ║
     ║                                                                                            ║
     ║ Modules             :                                                                      ║
     ║  ...                                                                                       ║
     ╚════════════════════════════════════════════════════════════════════════════════════════════╝


15:59:29.400 [main] INFO  io.inverno.example.app_hello_security.App_hello_security - Starting Module io.inverno.example.app_hello_security...
15:59:29.402 [main] INFO  io.inverno.example.app_hello_security.App_hello_security - Module io.inverno.example.app_hello_security started in 3ms
15:59:29.405 [main] INFO  io.inverno.core.v1.Application - Application io.inverno.example.app_hello_security started in 23ms
Hello world!
15:59:29.411 [Thread-0] INFO  io.inverno.example.app_hello_security.App_hello_security - Stopping Module io.inverno.example.app_hello_security...
</code></pre>
                    <p>We want to protect the whole application so basically exit the application if the user could not be authenticated using login/password credentials specified on the command line.</p>
                    <p>In order to authenticate a user against an in-memory repository, we must create a <strong>security manager</strong> as follows:</p>
                    <pre><code class="language-java">package io.inverno.example.app_hello_security;

import io.inverno.core.annotation.Bean;
import io.inverno.core.v1.Application;
import io.inverno.mod.security.SecurityManager;
import io.inverno.mod.security.accesscontrol.AccessController;
import io.inverno.mod.security.authentication.LoginCredentials;
import io.inverno.mod.security.authentication.LoginCredentialsMatcher;
import io.inverno.mod.security.authentication.password.RawPassword;
import io.inverno.mod.security.authentication.user.InMemoryUserRepository;
import io.inverno.mod.security.authentication.user.User;
import io.inverno.mod.security.authentication.user.UserAuthenticator;
import io.inverno.mod.security.context.SecurityContext;
import io.inverno.mod.security.identity.Identity;
import java.util.List;
import java.util.function.Supplier;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class Main {
    
    private static final Logger LOGGER = LogManager.getLogger(Main.class);
        
    public static void main(String[] args) {
        if(args.length != 2) {
            System.out.println("Usage: hello &lt;user&gt; &lt;password&gt;");
            return;
        }
        
        // The security manager uses a user authenticator with an in-memory user repository and a Login credentials (i.e. login/pasword) matcher
        SecurityManager&lt;LoginCredentials, Identity, AccessController&gt; securityManager = SecurityManager.of(
            new UserAuthenticator&lt;&gt;(
                InMemoryUserRepository
                    .of(List.of(
                        User.of("jsmith")
                            .password(new RawPassword("password"))
                            .build()
                    ))
                    .build(), 
                new LoginCredentialsMatcher&lt;&gt;()
            )
        );
        
        securityManager.authenticate(LoginCredentials.of(args[0], new RawPassword(args[1])))
            .subscribe(securityContext -&gt; {
                if(securityContext.isAuthenticated()) {
                    LOGGER.info("User has been authenticated");
                    Application.run(new App_hello_security.Builder()).helloService().sayHello();
                }
                else {
                    securityContext.getAuthentication().getCause().ifPresentOrElse(
                        error -&gt; LOGGER.error("Failed to authenticate user", error),
                        () -&gt; LOGGER.error("Unauthorized anonymous access")
                    );
                }
            });
    }
}
</code></pre>
                    <p>Now if we run the application with valid or invalid credentials we should get the following outputs:</p>
                    <pre><code class="language-plaintext">$ mvn inverno:run -Dinverno.run.arguments="jsmith password"
16:08:24.078 [main] INFO  io.inverno.example.app_hello_security.Main - User has been authenticated
16:08:24.090 [main] INFO  io.inverno.core.v1.Application - Inverno is starting...
...
16:08:24.108 [main] INFO  io.inverno.example.app_hello_security.App_hello_security - Starting Module io.inverno.example.app_hello_security...
16:08:24.111 [main] INFO  io.inverno.example.app_hello_security.App_hello_security - Module io.inverno.example.app_hello_security started in 4ms
16:08:24.115 [main] INFO  io.inverno.core.v1.Application - Application io.inverno.example.app_hello_security started in 21ms
Hello world!
16:08:24.116 [Thread-0] INFO  io.inverno.example.app_hello_security.App_hello_security - Stopping Module io.inverno.example.app_hello_security...
</code></pre>
                    <pre><code class="language-plaintext">$ mvn inverno:run -Dinverno.run.arguments="jsmith invalid"
...
16:08:49.442 [main] ERROR io.inverno.example.app_hello_security.Main - Failed to authenticate user
io.inverno.mod.security.authentication.InvalidCredentialsException: Invalid credentials
	at io.inverno.mod.security.authentication.AbstractPrincipalAuthenticator.lambda$authenticate$1(AbstractPrincipalAuthenticator.java:74) ~[io.inverno.mod.security-1.5.0-SNAPSHOT.jar:?]
	at reactor.core.publisher.MonoErrorSupplied.subscribe(MonoErrorSupplied.java:55) [reactor.core-3.4.14.jar:?]
	at reactor.core.publisher.Mono.subscribe(Mono.java:4400) [reactor.core-3.4.14.jar:?]
	at reactor.core.publisher.FluxSwitchIfEmpty$SwitchIfEmptySubscriber.onComplete(FluxSwitchIfEmpty.java:82) [reactor.core-3.4.14.jar:?]
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:150) [reactor.core-3.4.14.jar:?]
	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableSubscriber.onComplete(FluxFilterFuseable.java:171) [reactor.core-3.4.14.jar:?]
	at reactor.core.publisher.Operators$MonoSubscriber.complete(Operators.java:1817) [reactor.core-3.4.14.jar:?]
	at reactor.core.publisher.MonoSupplier.subscribe(MonoSupplier.java:62) [reactor.core-3.4.14.jar:?]
	at reactor.core.publisher.Mono.subscribe(Mono.java:4400) [reactor.core-3.4.14.jar:?]
	at reactor.core.publisher.Mono.subscribeWith(Mono.java:4515) [reactor.core-3.4.14.jar:?]
	at reactor.core.publisher.Mono.subscribe(Mono.java:4371) [reactor.core-3.4.14.jar:?]
	at reactor.core.publisher.Mono.subscribe(Mono.java:4307) [reactor.core-3.4.14.jar:?]
	at reactor.core.publisher.Mono.subscribe(Mono.java:4279) [reactor.core-3.4.14.jar:?]
	at io.inverno.example.app_hello_security.Main.main(Main.java:71) [classes/:?]
...
</code></pre>
                    <p>We can change the <code>HelloService</code> in order to display a personalized greeting message to the authenticated user. This requires to resolve the identity of the user and inject the security context into the <code>HelloService</code>.</p>
                    <p>The identity of the user can be stored in the user repository and resolved using a <code>UserIdentityResolver</code> in the security manager as follows:</p>
                    <pre><code class="language-java">package io.inverno.example.app_hello_security;

import io.inverno.core.annotation.Bean;
import io.inverno.core.v1.Application;
import io.inverno.mod.security.SecurityManager;
import io.inverno.mod.security.accesscontrol.AccessController;
import io.inverno.mod.security.authentication.LoginCredentials;
import io.inverno.mod.security.authentication.LoginCredentialsMatcher;
import io.inverno.mod.security.authentication.password.RawPassword;
import io.inverno.mod.security.authentication.user.InMemoryUserRepository;
import io.inverno.mod.security.authentication.user.User;
import io.inverno.mod.security.authentication.user.UserAuthenticator;
import io.inverno.mod.security.context.SecurityContext;
import io.inverno.mod.security.identity.PersonIdentity;
import io.inverno.mod.security.identity.UserIdentityResolver;
import java.util.List;
import java.util.function.Supplier;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class Main {
    
    private static final Logger LOGGER = LogManager.getLogger(Main.class);
    
    @Bean
    public static interface App_hello_securitySecurityContext extends Supplier&lt;SecurityContext&lt;PersonIdentity, AccessController&gt;&gt; {}
    
    public static void main(String[] args) {
        ...
        // The security manager now uses a user identity resolver to resolve the identity of the authenticated user
        SecurityManager&lt;LoginCredentials, PersonIdentity, AccessController&gt; securityManager = SecurityManager.of(
            new UserAuthenticator&lt;&gt;(
                InMemoryUserRepository
                    .of(List.of(
                        User.of("jsmith")
                            .password(new RawPassword("password"))
                            .identity(new PersonIdentity("jsmith", "John", "Smith", "jsmith@inverno.io"))
                            .build()
                    ))
                    .build(),
                new LoginCredentialsMatcher&lt;&gt;()
            ),
            new UserIdentityResolver&lt;&gt;()
        );
        
        // The security context is now injected in the App_hello_security module
        securityManager.authenticate(LoginCredentials.of(args[0], new RawPassword(args[1])))
            .subscribe(securityContext -&gt; {
                if(securityContext.isAuthenticated()) {
                    LOGGER.info("User has been authenticated");
                    Application.run(new App_hello_security.Builder(securityContext)).helloService().sayHello();
                }
                else {
                    securityContext.getAuthentication().getCause().ifPresentOrElse(
                        error -&gt; LOGGER.error("Failed to authenticate user", error),
                        () -&gt; LOGGER.error("Unauthorized anonymous access")
                    );
                }
            });
    }
}
</code></pre>
                    <p>In above code, we also declared a socket bean in order to inject the <code>SecurityContext</code> in the module and eventually in the <code>HelloService</code> bean:</p>
                    <pre><code class="language-java">package io.inverno.example.app_hello_security;

import io.inverno.core.annotation.Bean;
import io.inverno.mod.security.accesscontrol.AccessController;
import io.inverno.mod.security.context.SecurityContext;
import io.inverno.mod.security.identity.PersonIdentity;

@Bean
public class HelloService {
    
    private final SecurityContext&lt;PersonIdentity, AccessController&gt; securityContext;
    
    public HelloService(SecurityContext&lt;PersonIdentity, AccessController&gt; securityContext) {
        this.securityContext = securityContext;
    }
    
    public void sayHello() {
        StringBuilder message = new StringBuilder();
        message.append("Hello ").append(this.securityContext.getIdentity().map(PersonIdentity::getFirstName).orElse("whoever you are")).append("!");
        System.out.println(message.toString());
    }
}
</code></pre>
                    <p>If we run the application, we should now get a personalized greeting message using the user identity:</p>
                    <pre><code class="language-plaintext">$ mvn inverno:run -Dinverno.run.arguments="jsmith password"
...
Hello John!
</code></pre>
                    <blockquote>
                        <p>A <code>PersonIdentity</code> has been attached to the user in the repository but the repository may also contain users with no defined identity which is why <code>SecurityContext#identity()</code> returns an <code>Optional</code>.</p>
                    </blockquote>
                    <p>Now let's say we want some priviledged users to be greeted with an extra polite message. We can assign roles to users in the repository and resolve a <code>RoleBasedAccessContoller</code> to check priviledges in the <code>HelloService</code>:</p>
                    <pre><code class="language-java">package io.inverno.example.app_hello_security;

import io.inverno.core.annotation.Bean;
import io.inverno.core.v1.Application;
import io.inverno.mod.security.SecurityManager;
import io.inverno.mod.security.accesscontrol.GroupsRoleBasedAccessControllerResolver;
import io.inverno.mod.security.accesscontrol.RoleBasedAccessController;
import io.inverno.mod.security.authentication.LoginCredentials;
import io.inverno.mod.security.authentication.LoginCredentialsMatcher;
import io.inverno.mod.security.authentication.password.RawPassword;
import io.inverno.mod.security.authentication.user.InMemoryUserRepository;
import io.inverno.mod.security.authentication.user.User;
import io.inverno.mod.security.authentication.user.UserAuthenticator;
import io.inverno.mod.security.context.SecurityContext;
import io.inverno.mod.security.identity.PersonIdentity;
import io.inverno.mod.security.identity.UserIdentityResolver;
import java.util.List;
import java.util.function.Supplier;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class Main {
    
    private static final Logger LOGGER = LogManager.getLogger(Main.class);
    
    @Bean
    public static interface App_hello_securitySecurityContext extends Supplier&lt;SecurityContext&lt;PersonIdentity, RoleBasedAccessController&gt;&gt; {}
    
    public static void main(String[] args) {
        ...
        // The security manager now uses a groups RBAC Resolver to resolve the RBAC access controler of the authenticated user
        SecurityManager&lt;LoginCredentials, PersonIdentity, RoleBasedAccessController&gt; securityManager = SecurityManager.of(
            new UserAuthenticator&lt;&gt;(
                InMemoryUserRepository
                    .of(List.of(
                        User.of("jsmith")
                            .password(new RawPassword("password"))
                            .identity(new PersonIdentity("jsmith", "John", "Smith", "jsmith@inverno.io"))
                            .groups("vip")
                            .build(),
                        User.of("adoe")
                            .password(new RawPassword("password"))
                            .identity(new PersonIdentity("adoe", "Alice", "Doe", "adoe@inverno.io"))
                            .build()
                    ))
                    .build(),
                new LoginCredentialsMatcher&lt;&gt;()
            ),
            new UserIdentityResolver&lt;&gt;(),
            new GroupsRoleBasedAccessControllerResolver()
        );
        ...
    }
}
</code></pre>
                    <pre><code class="language-java">package io.inverno.example.app_hello_security;

import io.inverno.core.annotation.Bean;
import io.inverno.mod.security.accesscontrol.RoleBasedAccessController;
import io.inverno.mod.security.context.SecurityContext;
import io.inverno.mod.security.identity.PersonIdentity;
import reactor.core.publisher.Mono;

@Bean
public class HelloService {
    
    private final SecurityContext&lt;PersonIdentity, RoleBasedAccessController&gt; securityContext;
    
    public HelloService(SecurityContext&lt;PersonIdentity, RoleBasedAccessController&gt; securityContext) {
        this.securityContext = securityContext;
    }
    
    public void sayHello() {
        this.securityContext.getAccessController()
            .map(rbac -&gt; rbac.hasRole("vip"))
            .orElse(Mono.just(false))
            .subscribe(isVip -&gt; {
                StringBuilder message = new StringBuilder();
                if(isVip) {
                    message.append("Hello my dear friend ").append(this.securityContext.getIdentity().map(PersonIdentity::getFirstName).orElse("whoever you are")).append("!");
                }
                else {
                    message.append("Hello ").append(this.securityContext.getIdentity().map(PersonIdentity::getFirstName).orElse("whoever you are")).append("!");
                }
                System.out.println(message.toString());
            });
    }
}
</code></pre>
                    <p>We can now run the application using <code>jsmith</code> and <code>adoe</code> credentials and see the results:</p>
                    <pre><code class="language-plaintext">$ mvn clean inverno:run -Dinverno.run.arguments="jsmith password"
...
Hello my dear friend John!
</code></pre>
                    <pre><code class="language-plaintext">$ mvn clean inverno:run -Dinverno.run.arguments="adoe password"
...
Hello Alice!
</code></pre>
                    <blockquote>
                        <p>As for the identity, we can not assume that an access controller is present in the security context which only proves that an entity has been authenticated.</p>
                    </blockquote>
                    <h4 id="security-manager">Security Manager</h4>
                    <p>Now let's take a closer look at the API starting by the <code>SecurityManager</code> which is the main entry point to secure an application.</p>
                    <blockquote>
                        <p>Note that when securing a Web application, the role of the <code>SecurityManager</code> is actually handled by a <code>SecurityInterceptor</code> intercepting secured Web route and populating the exchange context with the security context to make it accessible to route handlers and interceptors. Please refere to the <em>security-http</em> module documentation for detailed information.</p>
                    </blockquote>
                    <p>The security manager is used to authenticate credentials and create a security context exposing the actual authentication result and the authenticated entity's identity and access controller if any. A <code>SecurityManager</code> instance is created by composing an <code>Authenticator</code> with optional <code>IdentityResolver</code> and <code>AccessControllerResolver</code> which are respectively used to resolve the <code>Identity</code> and the <code>AccessController</code> of the authenticated entity based on the <code>Authentication</code> object resulting from the authentication of input <code>Credentials</code> by the <code>Authenticator</code>.</p>
                    <p>The <code>SecurityManager</code> interface bascially chains the authentication, the identity resolution and the access controller resolution in a single method <code>authenticate()</code> returning the resulting <code>SecurityContext</code>.</p>
                    <pre><code class="language-java">Authenticator&lt;Credentials, Authentication&gt; authenticator = ...
IdentityResolver&lt;Authentication, Identity&gt; identityResolver = ...
AccessControllerResolver&lt;Authentication, AccessController&gt; accessControllerResolver = ...

// Create a security manager with authentication only
SecurityManager&lt;Credentials, Identity, AccessController&gt; securityManager = SecurityManager.of(authenticator);

// Create a security manager with identity resolution
SecurityManager&lt;Credentials, Identity, AccessController&gt; securityManager = SecurityManager.of(authenticator, identityResolver);

// Create a security manager with access control resolution
SecurityManager&lt;Credentials, Identity, AccessController&gt; securityManager = SecurityManager.of(authenticator, accessControllerResolver);

// Create a security manager with both identification and access control resolution
SecurityManager&lt;Credentials, Identity, AccessController&gt; securityManager = SecurityManager.of(authenticator, identityResolver, accessControllerResolver);
</code></pre>
                    <blockquote>
                        <p>Note how generics are used to specify what <code>Credentials</code> can be authenticated, what <code>Authentication</code> object are returned by the authenticator and used by identity and access controller resolvers to resolve specific <code>Identity</code> and <code>AccessController</code> objects. This basically allows the compiler to check that the security manager is created with consistent <code>Authenticator</code>, <code>IdentityResolver</code> and <code>AccessControllerResolver</code>.</p>
                    </blockquote>
                    <p>A security context can then be obtained by authenticating appropriate credentials as defined by the selected authenticator.</p>
                    <pre><code class="language-java">SecurityManager&lt;LoginCredentials, PersonIdentity, RoleBasedAccessController&gt; securityManager = ...

SecurityContext&lt;PersonIdentity, RoleBasedAccessController&gt; securityContext = securityManager.authenticate(LoginCredentials.of("user", new RawPassword("password"))).block();
</code></pre>
                    <p>A security manager shall always return a security context even in case of security errors. For instance it returns:</p>
                    <ul>
                        <li>an <strong>anonymous</strong> security context when authenticating <code>null</code> credentials. An anonymous security context only expose an unauthenticated <code>Authentication</code> object with no cause.</li>
                        <li>an <strong>denied</strong> security context when authentication or identity or access controller resolutions failed with error.</li>
                        <li>an <strong>granted</strong> security context when authentication and identity and access controller resolutions were successful.</li>
                    </ul>
                    <p>The following shows a proper way to handle a security context:</p>
                    <pre><code class="language-java">if(securityContext.isAuthenticated()) {
    // Sucessful authentication
    ...
}
else if(securityContext.isAnonymous()) {
    // Anonymous access
    ...
}
else {
    // Failed authentication
    ...
}
</code></pre>
                    <h5 id="credentials">Credentials</h5>
                    <p>Credentials must be provided to the application to get access to protected services or resources inside the application. In practice, <code>Credentials</code> must be authenticated by the <code>Authenticator</code> of a <code>SecurityManager</code> which eventually creates the application's <code>SecurityContext</code> used accross the application to determine whether the authenticated entity can invoke services or access resources.</p>
                    <p>There are many forms of credentials which depend on the actual authentication process. The most common is a username/password pair, but we can also think about tokens, an X.509 certificates... The security API exposes several basic type of credentials.</p>
                    <h6 id="tokencredentials">TokenCredentials</h6>
                    <p>Token credentials are composed of a single token usually easy to authenticate, temporary, revocable or renewable. They are typically obtained by an entity following other stronger authentication processes using sensitive credentials (e.g. username/password with or without multi-factor authentication...) in order to avoid exposing these sensitive data or to use a cheaper authentication process each time the application is accessed by the authenticated entity.</p>
                    <p>The <code>TokenCredentials</code> class is a basic token credentials implementation exposing an opaque token.</p>
                    <h6 id="principalcredentials">PrincipalCredentials</h6>
                    <p>Principal credentials represents generic credentials for a principal entity identified using a username. The <code>PrincipalCredentials</code> interface is actually a base type which is simply exposing the username, it does not presume of any particular authentication method (e.g. password, multi-factor, biometric...).</p>
                    <h6 id="logincredentials">LoginCredentials</h6>
                    <p>Login credentials are specific principal credentials with a password which is used to authenticate a principal entity identified by a username.</p>
                    <p>The <code>LoginCredentials</code> interface extends <code>PrincipalCredentials</code> and simply exposes a <code>Password</code> in addition to the username. Login credentials can be created with a username and a password as follows:</p>
                    <pre><code class="language-java">LoginCredentials loginCredentials = LoginCredentials.of("jsmith", new RawPassword("password"));
</code></pre>
                    <blockquote>
                        <p>Login credentials provided by a user in a login form for instance usually contain a raw password in clear text, however it is completely possible to define them using an encoded password and therefore secure the password all the way to the authenticator.</p>
                    </blockquote>
                    <h5 id="password">Password</h5>
                    <p>Password can be used in an authentication based on a shared secret, namely the password. The API defines the <code>Password</code> interface which is used to represent a password and allows it to be stored in a secured encoded form, for instance in a user repository. It can also be used to match a password provided in a password based credentials, for instance when authenticating <code>LoginCredentials</code> against other password based credentials resolved from a secured repository.</p>
                    <p>The <code>Password</code> interface exposes an encoded password value, the actual <code>Password.Encoder</code> that was used to encode the password and <code>matches()</code> methods used to match a raw password or another <code>Password</code> instance.</p>
                    <p>A simple message digest password can be created from a raw password value as follows:</p>
                    <pre><code class="language-java">// password -&gt; bta60AntIvI9YWRfsFFSRBocTW-4xSzmI...
MessageDigestPassword password = new MessageDigestPassword.Encoder().encode("password");
</code></pre>
                    <p>or from an encoded value as follows:</p>
                    <pre><code class="language-java">MessageDigestPassword password = new MessageDigestPassword("bta60AntIvI9YWRfsFFSRBocTW-4xSzmI...", new MessageDigestPassword.Encoder());
</code></pre>
                    <p>Using the password instance, it is then possible to match a provided raw password value:</p>
                    <pre><code class="language-java">if(password.matches("password")) {
    // passwords match
    ...
}
</code></pre>
                    <p>In order to properly match passwords, it is important to use the same encoder as the one that was used to encode the password. Password encoders can be configured in various ways to reach a proper level of protection. As a result, when encoding password, it is important to always use constant encoder's settings to be able to recover the exact same password instance from a given encoded password. On way to do that is to hardcode these settings in the application but then they shall never be changed or all passwords must be renewed. Another more reliable way would be to store encoder's settings next the encoded password. This can be done by serializing the password as JSON.</p>
                    <pre><code class="language-java">ObjectMapper mapper = new ObjectMapper();

MessageDigestPassword password = new MessageDigestPassword.Encoder("SHA-512", "secret".getBytes(), 16).encode("password");

// {"@c":".MessageDigestPassword","value":"R3IF7VY7Trxh4slRRVF4Yk0_JNIcaAtUZ...","encoder":{"@c":".MessageDigestPassword$Encoder","algorithm":"SHA-512","secret":"c2VjcmV0","saltLength":16}}
String serializedPassword = mapper.writeValueAsString(password);

// Returns a MessageDigestPassword instance
Password&lt;?, ?&gt; readPassword = mapper.readValue(jsonPassword, Password.class);
</code></pre>
                    <p>The API currently provides the following <code>Password</code> implementations:</p>
                    <ul>
                        <li><code>Argon2Password</code> which uses <a href="https://en.wikipedia.org/wiki/Argon2">Argon2</a> key derivation function.</li>
                        <li><code>BCryptPassword</code> which uses <a href="https://en.wikipedia.org/wiki/Bcrypt">Bcrypt</a> hashing function.</li>
                        <li><code>MessageDigestPassword</code> which uses a <code>MessageDigest</code> with salt.</li>
                        <li><code>PBKDF2Password</code> which uses <a href="https://en.wikipedia.org/wiki/PBKDF2">Password-Based Key Derivation Function 2</a>.</li>
                        <li><code>SCryptPassword</code> which uses <a href="https://en.wikipedia.org/wiki/Scrypt">Scrypt</a> hashing function.</li>
                        <li>The <code>RawPassword</code> implementation does not encode passwords, it is typically used to represent in-memory and volatile passwords submitted to a running application for authentication. They are usually matched against stored and secured password credentials. A <code>RawPassword</code> instance can't be serialized as JSON as other password implementations, it shall not be stored or communicated under any circumstances.</li>
                    </ul>
                    <h5 id="authenticator">Authenticator</h5>
                    <p>In a security manager, an authenticator is responsible for authenticating <code>Credentials</code> and returning a resulting <code>Authentication</code> which represents a proof that credentials have been authenticated.</p>
                    <p>The <code>Authenticator</code> interface is a functional interface defining one <code>authenticate()</code> method. It is then easy to create <em>inline</em> authenticator implementations for testing purposes or else. A simplistic authenticator for authenticating login credentials (i.e. username/password) can be created as follows:</p>
                    <pre><code class="language-java">Authenticator&lt;LoginCredentials, Authentication&gt; authenticator = credentials -&gt; Mono.fromSupplier(() -&gt; {
    if(credentials.getUsername().equals("user") &amp;&amp; credentials.getPassword().equals("password")) {
        return Authentication.authenticated();
    }
    return Authentication.denied();
});
</code></pre>
                    <p>An authenticator might not always be able to authenticate provided credentials, this basically means that the authenticator is unable to determine whether specified credentials are valid because it does not manage or understand them. For instance, we can imagine defining different authenticators targeting different user realms or authentication systems, credentials could only be authenticated by the authenticator targeting the same realm or authentication system.</p>
                    <p>In such situations, an authenticator can decide to return an empty <code>Mono</code> instead of returning a denied authentication or throwing an <code>AuthenticationException</code> which would terminate the authentication process. This would allow other authenticators to try to authenticate the credentials.</p>
                    <p>Multiple authenticators can be chained using the <code>or()</code> operator. In the following example, <code>authenticator1</code> is implemented in such a way that it only tries to authenticate users it knows, returning an empty <code>Mono</code> for those it doesn't know in order to delegate authentication to <code>authenticator2</code> which is terminal and always returns an <code>Authentication</code> instance:</p>
                    <pre><code class="language-java">Authenticator&lt;LoginCredentials, Authentication&gt; authenticator1 = credentials -&gt; Mono.fromSupplier(() -&gt; {
    if(credentials.getUsername().equals("user1")) {
        if(credentials.getPassword().matches("password")) {
            return Authentication.granted();
        }
        // Claim the credentials and terminate the chain
        return Authentication.denied();
    }
    // Delegate to next authenticator in the chain
    return null;
});

Authenticator&lt;LoginCredentials, Authentication&gt; authenticator2 = credentials -&gt; Mono.fromSupplier(() -&gt; {
    if (credentials.getUsername().equals("user2") &amp;&amp; credentials.getPassword().matches("password")) {
        return Authentication.granted();
    }
    return Authentication.denied();
});

Authenticator&lt;LoginCredentials, Authentication&gt; compositeAuthenticator = authenticator1.or(authenticator2);

// A granted authentication is returned by authenticator1
compositeAuthenticator.authenticate(LoginCredentials.of("user1", new RawPassword("password")));

// A denied authentication is returned by authenticator2 which claimed the credentials
compositeAuthenticator.authenticate(LoginCredentials.of("user1", new RawPassword("invalid")));

// A granted authentication is returned by authenticator2
compositeAuthenticator.authenticate(LoginCredentials.of("user2", new RawPassword("password")));

// A denied authentication is returned by authenticator2 which is terminal
compositeAuthenticator.authenticate(LoginCredentials.of("user2", new RawPassword("invalid")));

// A denied authentication is returned by authenticator2 which is terminal
compositeAuthenticator.authenticate(LoginCredentials.of("unknown", new RawPassword("password")));
</code></pre>
                    <blockquote>
                        <p>This approach might be very usefull when there is a need to authenticate credentials against multiple authentication systems. However you must be aware that some authenticator might not be <em>chainable</em> since, as <code>authenticator2</code> they can be implemented to claim all credentials peventing further authenticator to be invoked. Let's consider a <code>LoginCredentials</code> authenticator, it could rightfully consider that any username/password pair that it is unable to validate should be denied.</p>
                    </blockquote>
                    <p>It is also possible to transform the resulting authentication which can be useful to adapt it for further processing (e.g. identity resolver, access controller resolver, login forms...). In the following example, we transform the authentication returned by a login credentials authenticator into a <code>TokenAuthentication</code>:</p>
                    <pre><code class="language-java">Authenticator&lt;LoginCredentials, Authentication&gt; authenticator = ...

authenticator.map(authentication -&gt; {
    final String token = UUID.randomUUID().toString();
    return new TokenAuthentication() {
        @Override
        public String getToken() {
            return token;
        }

        @Override
        public boolean isAuthenticated() {
            return authentication.isAuthenticated();
        }

        @Override
        public Optional&lt;SecurityException&gt; getCause() {
            return authentication.getCause();
        }
    };
});
</code></pre>
                    <p>A proper authentication implementation shall always return an authentication whether authentication succeeds or fails, however there might be use cases where we simply want to fail and propagate the authentication error. This can be desirable when handling denied authentications is not required and must be delegated to a higher level typically the security manager.</p>
                    <p>Considering previous example, we can make sure only authenticated authentication will be transformed by using the <code>failOnDenied()</code> operator which can be invoked to avoid having to handle denied authentications when transforming the authentication output:</p>
                    <pre><code class="language-java">Authenticator&lt;LoginCredentials, Authentication&gt; authenticator = ...

authenticator
    // Fail when an denied authentication is returned and propagate the underlying SecurityException
    .failOnDenied()
    // Only transform successful authentication
    .map(authentication -&gt; {
        final String token = UUID.randomUUID().toString();
        return new TokenAuthentication() {
            @Override
            public String getToken() {
                return token;
            }

            @Override
            public boolean isAuthenticated() {
                return authentication.isAuthenticated();
            }

            @Override
            public Optional&lt;SecurityException&gt; getCause() {
                return authentication.getCause();
            }
        };
    });
</code></pre>
                    <p>It is also possible to fail on both denied or anonymous authentications using the <code>failOnDeniedAndAnonymous()</code> operator.</p>
                    <blockquote>
                        <p>The API was designed to provide the most flexibility to the application which can decide how denied or anonymous authentications should be handled, unauthenticated authentications actually exist to still be able to create a security context and do things inside the application from an unauthenticated authentication. You should however takes particular care when transforming authentication instances using <code>map()</code> or <code>flatMap()</code> operators, remember that an authentication represents proof that credentials were authenticated and as a result always make sure the authentication state is taken into account all the way. In previous example, we could have quite easily ignored the authentication in the mapper and always returned an authenticated authentication. Using <code>failOnDenied()</code> or <code>failOnDeniedAndAnonymous()</code> can prevent you form doing such mistakes.</p>
                    </blockquote>
                    <p>The API provides several base implementations that facilitate the authentication setup in an application.</p>
                    <blockquote>
                        <p>Please refer to <em>security-jose</em> and <em>security-ldap</em> modules documentations for JOSE tokens authenticators (i.e. JWS, JWE, JWT), LDAP and Active Directory authenticators.</p>
                    </blockquote>
                    <h6 id="principalauthenticator">PrincipalAuthenticator</h6>
                    <p>The principal authenticator is a generic authenticator for <code>PrincipalCredential</code> which returns <code>PrincipalAuthentication</code>. Authentication is done by matching provided credentials against trusted credentials using a <code>CredentialsMatcher</code>. Trusted credentials are resolved by username using a <code>CredentialsResolver</code>. A <code>PrincipalAuthenticator</code> is then created with a <code>CredentialsResolver</code> and a <code>CredentialsMatcher</code> as follows:</p>
                    <pre><code class="language-java">// Resolves trusted credentials by username (e.g. from a trusted store...)
CredentialsResolver&lt;LoginCredentials&gt; credentialsResolver = ...

// Matches provided credentials against trusted credentials
CredentialsMatcher&lt;LoginCredentials, LoginCredentials&gt; credentialsMatcher = ...

PrincipalAuthenticator&lt;LoginCredentials, LoginCredentials&gt; authenticator = new PrincipalAuthenticator&lt;&gt;(credentialsResolver, credentialsMatcher);

authenticator.authenticate(LoginCredentials.of("user", new RawPassword("password")));
</code></pre>
                    <p>A principal authenticator is terminal by default and terminates the authentication by returning a denied authentication on <code>AuthenticationException</code> due to unresolvable credentials (<code>CredentialsNotFoundException</code>) or unmatched credentials (<code>InvalidCredentialsException</code>). A principal authenticator can be made non-terminal in order to chain other authenticators:</p>
                    <pre><code class="language-java">PrincipalAuthenticator&lt;LoginCredentials, LoginCredentials&gt; authenticator = new PrincipalAuthenticator&lt;&gt;(credentialsResolver, credentialsMatcher);

LoginCredentials invalidCredentials = LoginCredentials.of("user", new RawPassword("invalid"));

// Returns a denied authentication
PrincipalAuthentication authentication = authenticator.authenticate(invalidCredentials).block();

// Returns null
PrincipalAuthentication authentication = authenticator.authenticate(invalidCredentials).block();
</code></pre>
                    <h6 id="userauthenticator">UserAuthenticator</h6>
                    <p>The user authenticator extends the principal authenticator, it is used to authenticate actual users. As for the <code>PrincipalAuthenticator</code>, the <code>UserAuthenticator</code> authenticates <code>PrincipalCredentials</code>, but it matches them against trusted <code>User</code> credentials instead of generic credentials. A user is a specific kind of credentials to represent actual users with <code>Identity</code> and groups. The resulting authentication is a <code>UserAuthentication</code> which exposes the <code>Identity</code> and the set of groups of the authenticated entity. A user is typically used to represent credentials for a physical person accessing the application.</p>
                    <p>Since the <code>User</code> interface exposes both identity and groups, the <code>UserAuthenticator</code> can actually authenticate and resolve data required to resolve the user's <code>Identity</code> and <code>AccessController</code> at once. In a security manager, it can be associated with a <code>UserIdentityResolver</code> which extracts the identity from the authentication and a <code>GroupsRoleBasedAccessControllerResolver</code> which uses the groups from the authentication as roles to create a <code>RoleBasedAccessController</code>.</p>
                    <pre><code class="language-java">// Resolves system users by username (e.g. from a user repository...)
CredentialsResolver&lt;User&lt;PersonIdentity&gt;&gt; credentialsResolver = ...

// Matches provided credentials against trusted users which are also LoginCredentials
CredentialsMatcher&lt;LoginCredentials, LoginCredentials&gt; credentialsMatcher = ...

UserAuthenticator&lt;LoginCredentials, PersonIdentity, User&lt;PersonIdentity&gt;&gt; authenticator = new UserAuthenticator&lt;&gt;(credentialsResolver, credentialsMatcher);

UserAuthentication&lt;PersonIdentity&gt; authentication = authenticator.authenticate(LoginCredentials.of("user", new RawPassword("password"))).block();

// first name, last name, email...
PersonIdentity identity = authentication.getIdentity();

// user belongs to groups sales, admin...
Set&lt;String&gt; groups = authentication.getGroups();
</code></pre>
                    <p>As for the <a href="#principalauthenticator">principal authenticator</a>, a user authenticator is terminal by default but can be made non-terminal by setting the <code>terminal</code> flag to <code>false</code>.</p>
                    <h5 id="credentials-resolver">Credentials resolver</h5>
                    <p>A credentials resolver is usually used within <code>Authenticator</code> implementations for resolving trusted credentials based on some id provided with the credentials in order to match them against trusted credentials. Both <code>PrincipalAuthenticator</code> and <code>UserAuthenticator</code> uses this technique to authenticate <code>LoginCredentials</code> identified by the username.</p>
                    <p>The <code>CredentialsResolver</code> interface is a functional interface defining one <code>resolveCredentials()</code> method. A simplistic implementation can then be created as follows:</p>
                    <pre><code class="language-java">CredentialsResolver&lt;LoginCredentials&gt; credentialsResolver = username -&gt; Mono.fromSupplier(() -&gt; {
    switch(username) {
        case "user1": return LoginCredentials.of("user1", new BCryptPassword.Encoder().encode("password1"));
        case "user2": return LoginCredentials.of("user2", new BCryptPassword.Encoder().encode("password2"));
        default: return null;
    }
});

// Returns user1's trusted credentials
LoginCredentials user1Credentials = credentialsResolver.resolveCredentials("user1").block();

// Returns null
LoginCredentials user3Credentials = credentialsResolver.resolveCredentials("user3").block();
</code></pre>
                    <p>The API provides several implementations that facilitate the authentication setup in an application.</p>
                    <h6 id="inmemorylogincredentialsresolver">InMemoryLoginCredentialsResolver</h6>
                    <p>An in-memory login credentials resolver can be used to create dynamic and volatile <code>LoginCredentials</code> resolvers which are particularly suited for testing and prototyping. The <code>InMemoryLoginCredentialsResolver</code> basically looks for <code>LoginCredentials</code> stored in a <code>ConcurrentHashMap</code> and allows to add or remove credentials as needed.</p>
                    <pre><code class="language-java">InMemoryLoginCredentialsResolver inMemoryLoginCredentialsResolver = new InMemoryLoginCredentialsResolver(List.of(LoginCredentials.of("user1", new RawPassword("password"))));
inMemoryLoginCredentialsResolver.put("user2", new RawPassword("password"));
inMemoryLoginCredentialsResolver.remove("user1");
</code></pre>
                    <h6 id="userrepository">UserRepository</h6>
                    <p>A user repository is a user credentials resolver that provides CRUD operations to a data store in order to securely store and manage application users.</p>
                    <pre><code class="language-java">UserRepository&lt;PersonIdentity, User&lt;PersonIdentity&gt;&gt; userRepository = null;
		
// Create a user with identity and groups
userRepository.createUser(new User&lt;&gt;("jsmith", new PersonIdentity("jsmith", "John", "Smith", "jsmith@inverno.io"), new RawPassword("password"), "group1", "group2"));

// Update user email
userRepository.getUser("jsmith")
    .doOnNext(user -&gt; user.getIdentity().setEmail("jsmith1@inverno.io"))
    .map(userRepository::updateUser)
    .block();

// Password change requires current credentials
userRepository.changePassword(LoginCredentials.of("jsmith", new RawPassword("password")), "newPassword");

// Delete user
userRepository.deleteUser("jsmith").block();
</code></pre>
                    <p>A proper <code>UserRepository</code> implementation shall rely on a <code>PasswordPolicy</code> and a <code>PasswordEncoder</code> to respectively control the level of protection offered by passwords and securely store them in the datastore.</p>
                    <p>The <code>PasswordPolicy</code> interface defines the <code>verify()</code> method which evaluates the strength of a password in a login credentials against some rules. A <code>PasswordPolicy.PasswordStrength</code> provides qualitative and quantitative marks used to evaluate the password strength, it is returned when the password follows the policy and included in a <code>PasswordPolicyException</code> thrown when the password does not follow the policy.</p>
                    <p>The <code>SimplePasswordPolicy</code> is a simple implementation that allows to control password's minimum and maximum length:</p>
                    <pre><code class="language-java">PasswordPolicy&lt;LoginCredentials, SimplePasswordPolicy.SimplePasswordStrength&gt; passwordPolicy = new SimplePasswordPolicy&lt;&gt;(4, 8);
		
// Throws a PasswordPolicyException since 'newPassword' is too long (&gt; 8)
SimplePasswordPolicy.SimplePasswordStrength passwordStrength = passwordPolicy.verify(LoginCredentials.of("jsmith", new RawPassword("password")), "newPassword");

// Returns the strength of the password
SimplePasswordPolicy.SimplePasswordStrength passwordStrength = passwordPolicy.verify(LoginCredentials.of("jsmith", new RawPassword("password")), "newPassword");

// WEAK, MEDIUM, STRONG...
passwordStrength.getQualifier();

// 10, 42, 100... The higher the better
passwordStrength.getScore();
</code></pre>
                    <blockquote>
                        <p>Please consider <a href="https://pages.nist.gov/800-63-3/sp800-63b.html">NIST Digital Identity Guidelines Section 5.1.1.2</a> if you need to create more elaborate implementations.</p>
                    </blockquote>
                    <p>The <code>PasswordEncoder</code> was covered previously in this documentation, it is used to evenly encode passwords before they are stored in the repository.</p>
                    <p>The API currently provides two <code>UserRepository</code> implementations:</p>
                    <ul>
                        <li>the <code>InMemoryUserRepository</code> which stores users in a <code>ConcurrentHashMap</code>.</li>
                        <li>the <code>RedisUserRepository</code> which stores users in a <a href="http://redis.io/">Redis</a> datastore.</li>
                    </ul>
                    <p>By default, they both use a default <code>SimplePasswordPolicy</code> as password policy and a <code>PBKDF2Password.Encoder</code> as password encoder. Custom password policy and encoder can be specified as follows:</p>
                    <pre><code class="language-java">// Required to access Redis datastore
RedisClient&lt;String, String&gt; redisClient = null;

// Required to serialize/deserialize users to/from JSON strings
ObjectMapper mapper = null;

// Use BCrypt hashing function and enforce passwords between 10 and 20 characters
UserRepository&lt;PersonIdentity, User&lt;PersonIdentity&gt;&gt; redisUserRepository = new RedisUserRepository&lt;&gt;(redisClient, mapper, new BCryptPassword.Encoder(8, 32), new SimplePasswordPolicy&lt;&gt;(10,20) );
</code></pre>
                    <blockquote>
                        <p>A <code>UserRepository</code> can be typically exposed in a REST interface consumed by an admin UI in order to manage application's users.</p>
                    </blockquote>
                    <h5 id="credentials-matcher">Credentials matcher</h5>
                    <p>A credentials matcher is usually used in conjunction with a credentials resolver within <code>Authenticator</code> implementations to match credentials against trusted credentials resolved using the credentials resolver. Both <code>PrincipalAuthenticator</code> and <code>UserAuthenticator</code> uses this technique to authenticate <code>LoginCredentials</code> identified by the username.</p>
                    <p>The <code>CredentialsMatcher</code> interface is a functional interface defining one <code>matches()</code> method which must be reflexive, symetric and transitive. A simplistic implementation can then be created as follows:</p>
                    <pre><code class="language-java">CredentialsMatcher&lt;LoginCredentials, LoginCredentials&gt; credentialsMatcher = (credentials, trustedCredentials) -&gt; {
    return credentials.getPassword().matches(trustedCredentials.getPassword());
};
</code></pre>
                    <h6 id="logincredentialsmatcher">LoginCredentialsMatcher</h6>
                    <p>The API provides <code>LoginCredentialsMatcher</code> implementation which basically check that usernames are equal and that passwords are matching.</p>
                    <pre><code class="language-java">// Match user provided login credentials against trusted user credentials
CredentialsMatcher&lt;LoginCredentials, User&lt;PersonIdentity&gt;&gt; credentialsMatcher = new LoginCredentialsMatcher();
</code></pre>
                    <h5 id="identity-resolver">Identity resolver</h5>
                    <p>In a security manager, an identity resolver is responsible for resolving the <code>Identity</code> of an authenticated entity based on the <code>Authentication</code> returned by an <code>Authenticator</code>.</p>
                    <p>The <code>IdentityResolver</code> interface is a functional interface defining one <code>resolveIdentity()</code> method which makes it easy to create inline implementations:</p>
                    <pre><code class="language-java">IdentityResolver&lt;PrincipalAuthentication, PersonIdentity&gt; identityResolver = authentication -&gt; {
    // The authentication is a proof of authentication, we can assume valid credentials have been provided
    String authenticatedUsername = authentication.getUsername();
    
    // Retrieve user identity from a reactive data source using the authenticated username
    Mono&lt;PersonIdentity&gt; identity = ...
    
    return identity;
};
</code></pre>
                    <p>A security manager may or may not use an identity manager depending on what is needed by the application. Identity resolution is also not exclusive to the identity resolver, there might be cases where identity information can actually be resolved during the authentication process, these information can then be exposed in an specific authentication and used in an identity resolver to create the actual identity exposed in the security context.</p>
                    <blockquote>
                        <p>We can also think of various use cases where the identity can not or should not be resolved during the authentication process. For instance, in token based authentication, a token can be authenticated using cryptographic techniques (e.g. signature) without requiring to communicate with an external system which might have provided identity information, identity can then be resolved next by the identity resolver if the application needs it. Again, it is important to understand that authentication and identity are not necessarily correlated, the <code>LDAPIdentityResolver</code> provided in the <em>security-ldap</em> module is a good example that can be used after another authenticator than the <code>LDAPAuthenticator</code>.</p>
                    </blockquote>
                    <h6 id="useridentityresolver">UserIdentityResolver</h6>
                    <p>The <code>UserAuthenticator</code> is a good example of identity information resolved during authentication. The identity is resolved with trusted credentials used for authentication in order to save resources. However a security manager still requires an identity resolver in order to expose the identity in the security context. In this particular case, the <code>UserIdentityResolver</code> can be used to simply extract the identity from the <code>UserAuthentication</code> and returns it to the security manager.</p>
                    <pre><code class="language-java">// Simply returns the identity resolved during authentication
IdentityResolver&lt;UserAuthentication&lt;PersonIdentity&gt;, PersonIdentity&gt; identityResolver = new UserIdentityResolver&lt;UserAuthentication&lt;PersonIdentity&gt;, PersonIdentity&gt;();
</code></pre>
                    <h5 id="accesscontroller-resolver">AccessController resolver</h5>
                    <p>In a security manager, an access controller resolver is responsible for resolving the authorizations granted to the authenticated entity based on the <code>Authentication</code> returned by an <code>Authenticator</code> in order to control its access to protected services and resources using an <code>AccessController</code>.</p>
                    <p>The <code>AccessControllerResolver</code> interface is a functional interface defining method <code>resolveAccessController()</code>, a simple inline implementation can be created as follows:</p>
                    <pre><code class="language-java">AccessControllerResolver&lt;PrincipalAuthentication, RoleBasedAccessController&gt; accessControllerResolver = authentication -&gt; {
    // The authentication is a proof of authentication, we can assume valid credentials have been provided
    String authenticatedUsername = authentication.getUsername();
    
    // Retrieve the role of the authenticated entity from a reactive data source using the authenticated username
    Mono&lt;Set&lt;String&gt;&gt; roles = ...
    
    return roles.map(RoleBasedAccessController::of);
};
</code></pre>
                    <p>As for the <a href="#identity-resolver">identity resolver</a>, a security manager may or may not use an access controller resolver depending on application's needs. As for identity resolution, access control information (e.g. roles, permissions...) can be resolved during authentication. For instance, the <code>UserAuthenticator</code> resolves user's groups along with trusted credentials used for authentication. These information can then be passed in the authentication and used within the access controller resolver to create the <code>AccessController</code> used to control the access to protected service and resources for the authenticated entity.</p>
                    <h6 id="groupsrolebasedaccesscontrollerresolver">GroupsRoleBasedAccessControllerResolver</h6>
                    <p>The <code>GroupsRoleBasedAccessControllerResolver</code> uses the set of groups exposed in a <code>GroupAwareAuthentication</code> (e.g. <code>UserAuthentication</code>) to create a <a href="#rolebasedaccesscontroller">role-based access controller</a>.</p>
                    <pre><code class="language-java">AccessControllerResolver&lt;GroupAwareAuthentication, RoleBasedAccessController&gt; accessControllerResolver = new GroupsRoleBasedAccessControllerResolver();
</code></pre>
                    <h6 id="configurationsourcepermissionbasedaccesscontrollerresolver">ConfigurationSourcePermissionBasedAccessControllerResolver</h6>
                    <p>The <code>ConfigurationSourcePermissionBasedAccessControllerResolver</code> creates a <a href="#permissionbasedaccesscontroller">permission-based access controller</a> for the authenticated entity identified by a username. The resulting access controller is backed by a <a href="#configuration-source">configuration source</a> which defines permissions by username.</p>
                    <pre><code class="language-java">// The configuration source defining permissions by user
ConfigurationSource&lt;?,?,?&gt; configurationSource = null;

ConfigurationSourcePermissionBasedAccessControllerResolver accessControllerResolver = new ConfigurationSourcePermissionBasedAccessControllerResolver(configurationSource);
</code></pre>
                    <h4 id="security-context">Security Context</h4>
                    <p>The security context is the central component used to secure an application. It is obtained from a <a href="#security-manager">security manager</a> after credentials authentication. It is composed of the following sub-components:</p>
                    <ul>
                        <li>an <code>Authentication</code> which results from the authentication of credentials and proves that there was an authentication.</li>
                        <li>an <code>Identity</code> which provides information about the identity of the authenticated entity.</li>
                        <li>an <code>AccessController</code> which provides services to determine whether the authenticated entity has the right to access protected services or resources within the application.</li>
                    </ul>
                    <p>These basically correspond to the three main concepts composing the Inverno security model as decribed in the <a href="#security">introduction</a> of the <em>security</em> module.</p>
                    <p>A <code>SecurityContext</code> instance should be distributed in the application anywhere there is a need to protect services and resources (i.e. authentication and access control) or a need for information about the authenticated entity (i.e. identification). It is usually obtained from a security manager but it is also possible to create a security context from previous components as follows:</p>
                    <pre><code class="language-java">Authentication authentication = Authentication.granted();
PersonIdentity identity = new PersonIdentity("jsmith", "John", "Smith", "jsmith@inverno.io");
RoleBasedAccessController accessController = RoleBasedAccessController.of("reader", "writer");

SecurityContext&lt;PersonIdentity, RoleBasedAccessController&gt; securityContext = SecurityContext.of(authentication, identity, accessController);
</code></pre>
                    <p>This construct can be useful for testing but it is important to remember that the API specifies that an authentication must represent the proof that credentials were authenticated which basically guarantees that the security context can be trusted. As a result, the security manager should always be prefered to create the security context.</p>
                    <h5 id="authentication">Authentication</h5>
                    <p>An authentication results from an authentication process and represents the proof that <a href="#credentials">credentials</a> were authenticated, typically by an <a href="#authenticator">authenticator</a>. In other words, it guarantees that the entity accessing the application has provided credentials and that they have been authenticated successfully or not.</p>
                    <p>An <code>Authentication</code> is always present in a security context but this does not means credential have been successfully authenticated, it simply means that there was an authentication. It can then takes three forms:</p>
                    <ul>
                        <li><strong>anonymous</strong> which corresponds to an authentication which is not authenticated with no cause of error and indicates that authentication was bypassed and application is accessed anonymously.</li>
                        <li><strong>denied</strong> which corresponds to an authentication which is not authenticated with a cause of error (e.g invalid credentials...) and indicates a failed authentication.</li>
                        <li><strong>granted</strong> which corresponds to an authenticated authentication and indicates a successful authentication.</li>
                    </ul>
                    <p>From there, it is up to the application to authorize anonymous access and decide what to do in case of denied access. The following example shows how to fully handle authentication in a security context:</p>
                    <pre><code class="language-java">SecurityContext&lt;PersonIdentity, RoleBasedAccessController&gt; securityContext = ...

if(securityContext.getAuthentication().isAuthenticated()) {
    // Application is accessed by an authenticated entity: 
    // - use access controller to secure services and resources
    // - use identity to get information about the authenticated entity
    ...
}
else if(securityContext.getAuthentication().isAnonymous()) {
    // Application is accessed anonymously: we can grant partial access or deny access
    ...
}
else {
    // Authentication failed: we should deny access and report the error
    LOGGER.error(securityContext.getAuthentication().getCause().get());
    ...
}
</code></pre>
                    <p>By extension, a security context can be anonymous, denied or granted as described in the <a href="#security-manager">security manager</a>. A denied or anonymous security context always returns empty identity and access controller. Previous code can then be rewritten as follows:</p>
                    <pre><code class="language-java">SecurityContext&lt;PersonIdentity, RoleBasedAccessController&gt; securityContext = ...

if(securityContext.isAuthenticated()) {
    // Application is accessed by an authenticated entity: 
    // - use access controller to secure services and resources
    // - use identity to get information about the authenticated entity
    ...
}
else if(securityContext.isAnonymous()) {
    // Application is accessed anonymously: we can grant partial access or deny access
    ...
}
else {
    // Authentication failed: we should deny access and report the error
    LOGGER.error(securityContext.getAuthentication().getCause().get());
    ...
}
</code></pre>
                    <blockquote>
                        <p>You might have notice that, unlike identity and access controller types, the authentication type is not defined as formal parameter in the <code>SecurityContext</code> interface. The authentication type is important in the security manager which uses specific identity and access controller resolvers for which the actual authentication type is important, however it is no longer useful in the security context which only needs to determine whether authentication is anonymous, denied or granted.</p>
                    </blockquote>
                    <h5 id="identity">Identity</h5>
                    <p>The identity exposes information that identifies that authenticated entity, it is resolved by the security manager using an <a href="#identity-resolver">identity resolver</a>.</p>
                    <p>A security context may or may not expose an identity depending on several elements such as whether identity is required by the application or whether an identity can be resolved based on the credentials provided to the security manager. In any case, the application must be prepared to handle security context with no identity.</p>
                    <pre><code class="language-java">SecurityContext&lt;PersonIdentity, RoleBasedAccessController&gt; securityContext = ...

securityContext.getIdentity().ifPresentOrElse(
    identity -&gt; {
        // Send an email to the authenticated user
        String email = identity.getEmail();
        ...
    }, 
    () -&gt; {
        LOGGER.warn("Unable to send email: missing identity");
        ...
    }
);
</code></pre>
                    <h5 id="access-controller">Access Controller</h5>
                    <p>The access controller provides services used to determine whether access to protected service or resource should be granted to the authenticated entity, it is resolved by the security manager using an <a href="#accesscontroller-resolver">access controller resolver</a>.</p>
                    <p>As for the identity, the application should not assume that a security context exposes an access controller for an authenticated entity and it must be prepared to deal with a missing access controller.</p>
                    <pre><code class="language-java">SecurityContext&lt;PersonIdentity, RoleBasedAccessController&gt; securityContext = ...

Mono&lt;String&gt; protectedReactiveService = securityContext.getAccessController()
    .map(accessController2 -&gt; accessController2
        .hasRole("reader")
        .map(hasRole -&gt; {
            if(!hasRole) {
                throw new ForbiddenException();
            }
            // User is authorized: do something useful
            return "User is a reader";
        })
    )
    .orElseThrow(() -&gt; new InternalServerErrorException("Missing access controller"));
</code></pre>
                    <p>The API provides <code>AccessController</code> implementations to get <a href="https://en.wikipedia.org/wiki/Role-based_access_control">role-based access control</a> or permission-based access control.</p>
                    <h6 id="rolebasedaccesscontroller">RoleBasedAccessController</h6>
                    <p>A role-based access controller defines services used to determine whether an authenticated entity has a particular set of roles. <a href="https://en.wikipedia.org/wiki/Role-based_access_control">Role-based access control</a> is used to protect access to services or resources based on the roles that were assigned to the authenticated user.</p>
                    <p>A <code>RoleBasedAccessController</code> is ideally obtained from an authentication by a security manager using a specific access controller resolver, but a simple instance can also be created from a collection of roles as follows:</p>
                    <pre><code class="language-java">RoleBasedAccessController accessController = RoleBasedAccessController.of("reader", "writer");
</code></pre>
                    <p>This construct can be useful for <code>AccessControllerResolver</code> implementations and testing purposes.</p>
                    <p>The <code>RoleBasedAccessController</code> interface basically defines three methods: <code>hasRole()</code> used to determine whether the autheticated entity has a specific role, <code>hasAnyRole()</code> used to determine whether the authenticated entity has any of the roles in a set of roles and <code>hasAllRole()</code> used to determine whether the authenticated entity has all the roles in a set of roles.</p>
                    <pre><code class="language-java">SecurityContext&lt;PersonIdentity, RoleBasedAccessController&gt; securityContext = ...

securityContext.getAccessController()
    .ifPresent(accessController2 -&gt; {
        // Returns true if the authenticated user has role 'reader'
        Mono&lt;Boolean&gt; canRead = accessController2.hasRole("reader");
        
        // Returns true if the authenticated user has any of the roles: 'writer', 'admin'
        Mono&lt;Boolean&gt; canWrite = accessController2.hasAnyRole("writer", "admin");
        
        // Returns true if the authenticated user has all of the roles: 'reader', 'writer'
        Mono&lt;Boolean&gt; canReadAndWrite = accessController2.hasAllRoles("reader", "writer");
    });
</code></pre>
                    <blockquote>
                        <p>These methods are reactive to support implementations using non-blocking operations.</p>
                    </blockquote>
                    <h6 id="permissionbasedaccesscontroller">PermissionBasedAccessController</h6>
                    <p>A permission-based access controller defines services used to determine whether an authenticated has the required permissions to access a protected service or resource. Access to services or resources is then controlled based on the permissions granted to the authenticated user for a particular context. Permissions are evaluated in a context defined by a set of parameters, such permissions are referred as <strong>parameterized permissions</strong>.</p>
                    <p>The <code>PermissionBasedAccessController</code> interface basically defines three kind of methods: <code>hasPermission()</code> used to determine whether the authenticated user has a particular permission in a particular context, <code>hasAnyPermission()</code> used to determine whether the authenticated entity has any of the permissions in a set of permissions in a particular context and <code>hasAllPermissions()</code> used to determine whether the authenticated entity has all the permissions in a set of permissions in a particular context.</p>
                    <pre><code class="language-java">SecurityContext&lt;PersonIdentity, PermissionBasedAccessController&gt; securityContext = null;

securityContext.getAccessController()
    .ifPresent(accessController -&gt; {
        // Returns true if the authenticated user has permission read
        Mono&lt;Boolean&gt; canRead = accessController.hasPermission("read");
    
        // Returns true if the authenticated user has permission read on 'contract' documents
        Mono&lt;Boolean&gt; canReadContracts = accessController.hasPermission("read", PermissionBasedAccessController.Parameter.of("documentType", "contract"));
        
        // Returns true if the authenticated user has permission 'manage' or 'admin'
        Mono&lt;Boolean&gt; canManagePrinter = accessController.hasAnyPermission(Set.of("manage", "admin"));
        
        // Returns true if the authenticated user has permission can manage printer 'lp1200'
        Mono&lt;Boolean&gt; canManagePrinterLP1200 = accessController.hasAnyPermission(Set.of("manage", "admin"), PermissionBasedAccessController.Parameter.of("printer", "lp1200"));
        
        // Returns true if the authenticated user can book and modify 'AF' flights from 'Orly' airport
        Mono&lt;Boolean&gt; canBookAndModify = accessController.hasAllPermissions(Set.of("book", "modify"), PermissionBasedAccessController.Parameter.of("company", "AF"), PermissionBasedAccessController.Parameter.of("origin", "ORY"));
    });
</code></pre>
                    <p>Parameterized permissions are very powerful and offer the most flexibility to control access to protected services and resources by taking the operational context into account. They are very similar to parameterized configuration properties as described in the <em>configuration</em> module. It is then no surprise than the API provides the <code>ConfigurationSourcePermissionBasedAccessController</code> implementation which is backed by a <code>ConfigurationSource</code> to resolve permissions as configuration properties defined as follows:</p>
                    <ul>
                        <li>the property name can be either a username or a role name prefixed with a role prefix to differentiate them from users (defaults is <code>ROLE_</code>)</li>
                        <li>the property parameters are the permissions parameters defining the context into which permissions are defined</li>
                        <li>the property value is a comma separated list of permissions defined using the following rules: 
                            <ul>
                              <li><code>permission</code> to indicates a granted permission</li>
                              <li><code>!permission</code> to indicates that a permission must not be granted</li>
                              <li><code>*</code> to indicate that all permissions are granted</li>
                            </ul></li>
                    </ul>
                    <p>The configuration source can be configured to use various defaulting strategies depending on the needs, it is however common to use a <code>DefaultingStrategy.wildcard()</code> strategy as it is more adapt than the <code>DefaultingStrategy.lookup()</code> strategy in that particular context.</p>
                    <p>Considering the following permissions defined in a <code>CPropsFileConfigurationSource</code>:</p>
                    <pre><code class="language-plaintext">[ domain = "printer" ] {
	# jsmith has role 'user' and therefore permission to query to any printer in the printer domain
	ROLE_user="query"
	ROLE_admin="*"
}

[ domain = "printer", printer = "lp1200" ] {
	# jsmith has permission to query and print to printer lp1200
	jsmith="query,print"
}

[ printer="epsoncolor" ] {
	# jsmith has permission to manage printer epsoncolor across all domains
	# when querying with (domain=printer,printer=epsoncolor) the permission is actually 'query' because domain parameter has the highest priority
	jsmith="manage"
	ROLE_user="query,print"
}

[ domain = "printer", printer = "XP-4100" ] {
	# jsmith has all permission on printer XP-4100
	jsmith="*"
}

[ domain = "printer", printer = "HL-L6400DW" ] {
	ROLE_user="query,print"
}

[ domain = "printer", printer = "C400V_DN" ] {
	jsmith="*,!manage"
}
</code></pre>
                    <p>We can then control permissions for user <code>jsmith</code> as follows:</p>
                    <pre><code class="language-java">CPropsFileConfigurationSource src = new CPropsFileConfigurationSource(new ClasspathResource(URI.create("classpath:/permissions.cprops")))
    .withDefaultingStrategy(DefaultingStrategy.wildcard());

PermissionBasedAccessController pbac = new ConfigurationSourcePermissionBasedAccessController(src, "jsmith", Set.of("user"));

// true: 'jsmith' has role 'user' for which permission query is granted in domain 'printer'
pbac.hasPermission("query", "domain", "printer").block();

// true: 'jsmith' has role 'user' for which permission query is granted in domain 'printer'
pbac.hasPermission("query", "domain", "printer", "printer", "TM-C3500").block();

// false: 'jsmith' only have permission query in domain 'printer'
pbac.hasPermission("query").block();

// true: 'jsmith' has all permissions on printer 'XP-4100' in domain 'printer'
pbac.hasPermission("manage", "domain", "printer", "printer", "XP-4100").block();

// true: 'jsmith' has all permissions but 'manage' permission on printer 'C400V-DN' in domain 'printer'
pbac.hasPermission("print", "domain", "printer", "printer", "C400V-DN").block();

// false: 'jsmith' has all permissions but 'manage' permission on printer 'C400V-DN' in domain 'printer'
pbac.hasPermission("manage", "domain", "printer", "printer", "C400V-DN").block();
</code></pre>
                    <p>It is important to remember that when using a defaulting strategy, the order into which parameters are specified in the query can impact results. For instance, the wildcard strategy gives priority to the permission defined with the most parameters and in case of conflict to parameters defined from left to right in the query.</p>
                    <blockquote>
                        <p><em>With great power comes great responsability.</em> As you can imagine, this particular permission-based access controller implementation is quite complex and requires rigor to be used properly. The more parameters are considered, the more difficult it is to define permissions. This might also have an impact on performances, especially when a defaulting strategy is used (wildcard defaulting may require <code>2^n</code> queries on the configuration source where <code>n</code> is the number of parameter). As a guideline, you should try to consider limited number of parameters (ideally two and not more than three) and consider caching permissions.</p>
                    </blockquote>
                    <blockquote>
                        <p>As of now, the impact on performances that might be introduced by the <code>ConfigurationSourcePermissionBasedAccessController</code> is still unclear due to limited real-life feedbacks which is why no big decision was taken yet to provide caching solutions. Possible solutions include using multiple dedicated Redis replicas when using a <code>RedisConfigurationSource</code> or caching the complete list of permissions by user in an in-memory configuration source.</p>
                    </blockquote>
                    <h3 id="security-http">Security HTTP</h3>
                    <p>The Inverno <em>security-http</em> module extends the security API and the HTTP server API respectively defined in the <em>security</em> module and the <em>http-server</em> module in order to secure access to an HTTP server or a Web application.</p>
                    <p>It defines a complete API for authenticating HTTP requests and exposing the resulting security context in the exchange context which can then be used in exchange interceptors and handlers to secure the application.</p>
                    <p>Base implementations for various HTTP and Web security standards are also provided. The module currently supports the following features:</p>
                    <ul>
                        <li>HTTP <a href="https://datatracker.ietf.org/doc/html/rfc7617">basic</a> authentication scheme.</li>
                        <li>HTTP <a href="https://datatracker.ietf.org/doc/html/rfc7616">digest</a> authentication scheme.</li>
                        <li>Form based authentication.</li>
                        <li>Token based authentication.</li>
                        <li>Cross-origin resource sharing support (<a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a>).</li>
                        <li>Protection against Cross-site request forgery attack (<a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">CSRF</a>).</li>
                    </ul>
                    <p>In order to use the Inverno <em>security-http</em> module, we need to declare a dependency in the module descriptor:</p>
                    <pre><code class="language-java">module io.inverno.example.app {
    ...
    requires io.inverno.mod.security.http;
    ...
}
</code></pre>
                    <p>And also declare that dependency in the build descriptor:</p>
                    <p>Using Maven:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-security-http&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <p>Using Gradle:</p>
                    <pre><code class="language-java">...
compile 'io.inverno.mod:inverno-security-http:1.5.2'
...
</code></pre>
                    <p>Let's quickly see how to secure a simple Web application exposing a single hello world service using basic authentication. The application might initially look like:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

import io.inverno.core.annotation.Bean;
import io.inverno.core.v1.Application;
import io.inverno.mod.http.base.Method;
import io.inverno.mod.web.annotation.WebController;
import io.inverno.mod.web.annotation.WebRoute;

@Bean
@WebController
public class Main {
    
    @WebRoute( path = "/hello", method = Method.GET)
    public String hello() {
        return "Hello world!";
    }

    public static void main(String[] args) {
        Application.run(new App_web_security.Builder());
    }
}
</code></pre>
                    <p>We can run and test the application which should respond with <code>Hello world!</code> when requesting http://localhost:8080/hello:</p>
                    <pre><code class="language-java">$ mvn inverno:run
...
[INFO] Running project: io.inverno.example.app_hello_security@1.0.0-SNAPSHOT...
 [═══════════════════════════════════════════════ 100&nbsp;% ══════════════════════════════════════════════] 
10:19:32.797 [main] INFO  io.inverno.core.v1.Application - Inverno is starting...


     ╔════════════════════════════════════════════════════════════════════════════════════════════╗
     ║                      , ~~ ,                                                                ║
     ║                  , '   /\   ' ,                                                            ║
     ║                 , __   \/   __ ,      _                                                    ║
     ║                ,  \_\_\/\/_/_/  ,    | |  ___  _    _  ___   __  ___   ___                 ║
     ║                ,    _\_\/_/_    ,    | | / _ \\ \  / // _ \ / _|/ _ \ / _ \                ║
     ║                ,   __\_/\_\__   ,    | || | | |\ \/ /|  __/| | | | | | |_| |               ║
     ║                 , /_/ /\/\ \_\ ,     |_||_| |_| \__/  \___||_| |_| |_|\___/                ║
     ║                  ,     /\     ,                                                            ║
     ║                    ,   \/   ,                                  -- 1.5.1 --                 ║
     ║                      ' -- '                                                                ║
     ╠════════════════════════════════════════════════════════════════════════════════════════════╣
     ║ Java runtime        : OpenJDK Runtime Environment                                          ║
     ║ Java version        : 18+36-2087                                                           ║
     ║ Java home           : /home/jkuhn/Devel/jdk/jdk-18                                         ║
     ║                                                                                            ║
     ║ Application module  : io.inverno.example.app_web_security                                  ║
     ║ Application class   : io.inverno.example.app_web_security.Main                             ║
     ║                                                                                            ║
     ║ Modules             :                                                                      ║
     ║  ...                                                                                       ║
     ╚════════════════════════════════════════════════════════════════════════════════════════════╝


10:19:32.801 [main] INFO  io.inverno.example.app_web_security.App_web_security - Starting Module io.inverno.example.app_web_security...
10:19:32.801 [main] INFO  io.inverno.mod.boot.Boot - Starting Module io.inverno.mod.boot...
10:19:33.002 [main] INFO  io.inverno.mod.boot.Boot - Module io.inverno.mod.boot started in 200ms
10:19:33.002 [main] INFO  io.inverno.mod.web.Web - Starting Module io.inverno.mod.web...
10:19:33.002 [main] INFO  io.inverno.mod.http.server.Server - Starting Module io.inverno.mod.http.server...
10:19:33.002 [main] INFO  io.inverno.mod.http.base.Base - Starting Module io.inverno.mod.http.base...
10:19:33.009 [main] INFO  io.inverno.mod.http.base.Base - Module io.inverno.mod.http.base started in 6ms
10:19:33.110 [main] INFO  io.inverno.mod.http.server.internal.HttpServer - HTTP Server (nio) listening on http://0.0.0.0:8080
10:19:33.111 [main] INFO  io.inverno.mod.http.server.Server - Module io.inverno.mod.http.server started in 109ms
10:19:33.111 [main] INFO  io.inverno.mod.web.Web - Module io.inverno.mod.web started in 109ms
10:19:33.112 [main] INFO  io.inverno.example.app_web_security.App_web_security - Module io.inverno.example.app_web_security started in 312ms
10:19:33.115 [main] INFO  io.inverno.core.v1.Application - Application io.inverno.example.app_web_security started in 375ms
</code></pre>
                    <pre><code class="language-plaintext">$ curl -i http://localhost:8080/hello
HTTP/1.1 200 OK
content-length: 12

Hello world!
</code></pre>
                    <p>From there, let's say we want to protect the access to all routes requiring <a href="https://datatracker.ietf.org/doc/html/rfc7617">HTTP basic authentication</a>. In order to do this we must authenticate basic credentials provided within requests and reject requests (401) on denied authentication in which case a basic authentication challenge must also be sent to the client.</p>
                    <p>A Web configurer must be created to define a <strong>security interceptor</strong> that will authenticate requests and use a <code>BasicAuthenticationErrorInterceptor</code> to intercept unauthorized (401) errors and return the basic authentication challenge to the client.</p>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

import io.inverno.core.annotation.Bean;
import io.inverno.mod.http.base.UnauthorizedException;
import io.inverno.mod.http.server.ExchangeContext;
import io.inverno.mod.security.accesscontrol.AccessController;
import io.inverno.mod.security.authentication.LoginCredentialsMatcher;
import io.inverno.mod.security.authentication.password.RawPassword;
import io.inverno.mod.security.authentication.user.InMemoryUserRepository;
import io.inverno.mod.security.authentication.user.User;
import io.inverno.mod.security.authentication.user.UserAuthenticator;
import io.inverno.mod.security.http.AccessControlInterceptor;
import io.inverno.mod.security.http.SecurityInterceptor;
import io.inverno.mod.security.http.basic.BasicAuthenticationErrorInterceptor;
import io.inverno.mod.security.http.basic.BasicCredentialsExtractor;
import io.inverno.mod.security.http.context.InterceptingSecurityContext;
import io.inverno.mod.security.identity.Identity;
import io.inverno.mod.web.ErrorWebRouter;
import io.inverno.mod.web.ErrorWebRouterConfigurer;
import io.inverno.mod.web.WebInterceptable;
import io.inverno.mod.web.WebInterceptorsConfigurer;
import java.util.List;

@Bean( visibility = Bean.Visibility.PRIVATE )
public class SecurityConfigurer implements WebInterceptorsConfigurer&lt;InterceptingSecurityContext&lt;Identity, AccessController&gt;&gt;, ErrorWebRouterConfigurer&lt;ExchangeContext&gt; {

    @Override
    public void configure(WebInterceptable&lt;InterceptingSecurityContext&lt;Identity, AccessController&gt;, ?&gt; interceptors) {
        interceptors
            .intercept()
                .interceptors(List.of(SecurityInterceptor.of(                            // 1 
                        new BasicCredentialsExtractor(),                                 // 2 
                        new UserAuthenticator&lt;&gt;(                                         // 3 
                            InMemoryUserRepository
                                .of(List.of(
                                    User.of("jsmith")
                                        .password(new RawPassword("password"))
                                        .build()
                                ))
                                .build(), 
                            new LoginCredentialsMatcher&lt;&gt;()
                        )
                    ),
                    AccessControlInterceptor.authenticated()                             // 4 
                ));
    }
    
    @Override
    public void configure(ErrorWebRouter&lt;ExchangeContext&gt; errorRouter) {
        errorRouter
            .intercept()
                .error(UnauthorizedException.class)
                .interceptor(new BasicAuthenticationErrorInterceptor&lt;&gt;("inverno-basic")) // 5 
            // We must apply interceptors to intercept white labels error routes
            .applyInterceptors();                                                        // 6 
    }
}
</code></pre>
                    <p>The Web configurer implements <code>WebInterceptorsConfigurer</code> in order to configure route interceptors and <code>ErrorWebRouterConfigurer</code> in order to configure error route interceptors and apply them to all error routes (including default ones). It declares the <code>InterceptingSecurityContext</code> exchange context type which is required by the <code>SecurityInterceptor</code> to set the security context. Interceptors are defined to intercept all routes.</p>
                    <p>In above code, there are several things that deserve further explanation:</p>
                    <ol>
                        <li>The <code>SecurityInterceptor</code> is the Web counterpart of the <code>SecurityManager</code>, it is used to authenticate credentials provided in HTTP requests and create the security context which is then exposed in the exchange context and accessible to exchange interceptors and handlers.</li>
                        <li>In addition to the authenticator and optional identity and access controller resolvers, it requires a credentials extractor used to extract <code>Credentials</code> from the request. The <code>BasicCredentialsExtractor</code> basically extracts <code>LoginCredentials</code> (username/password) from the <code>authorization</code> HTTP header of the request.</li>
                        <li>The security interceptor can then use any authenticator that is able to authenticate login credentials such as the <code>UserAuthenticator</code>.</li>
                        <li>An access control interceptor is added next in order to limit the access to authenticated users. Just like the security manager, the security interceptor authenticates credentials and creates the security context. But that does not mean authentication was successful, the resulting security context can be anonymous, denied or authenticated.</li>
                        <li>The <code>BasicAuthenticationErrorInterceptor</code> intercepts unauthorized (401) errors and set the basic authentication scheme challenge in the <code>www-authenticate</code> HTTP header of the response with the <code>inverno-basic</code> realm.</li>
                        <li>The Web server provides white labels error routes by default which must be explicitly intercepted since they have been created before on an unintercepted router.</li>
                    </ol>
                    <blockquote>
                        <p>Having to explicitly apply interceptors on default routes can be a source of errors and misunderstanding but there is unfortunately no other way if we want to make them overridable. A systematic and safe approach to this issue would be to always override default error routes.</p>
                    </blockquote>
                    <p>We should now receive an unauthorized (401) error with a basic authentication challenge when requesting http://localhost:8080/hello (or any other endpoint) without credentials:</p>
                    <pre><code class="language-plaintext">$ curl -i http://127.0.0.1:8080/hello
HTTP/1.1 401 Unauthorized
www-authenticate: basic realm="inverno-basic"
content-length: 0

</code></pre>
                    <p>In order to access the service, we must provide valid credentials in the <code>authorization</code> HTTP header. Basic authentication scheme specifies that credentials are obtained by encoding in base64 the concatenation of the username, a single colon and the password. In our example credentials for user <code>jsmith</code> are then <code>anNtaXRoOnBhc3N3b3Jk</code>:</p>
                    <pre><code class="language-plaintext">$ curl -i -H 'authorization: basic anNtaXRoOnBhc3N3b3Jk' http://127.0.0.1:8080/hello
HTTP/1.1 200 OK
content-length: 12

Hello world!
</code></pre>
                    <p>We can change the <code>/hello</code> route handler to respond with a personalized message. This requires to resolve the identity of the user and use it in the handler.</p>
                    <p>We use a user repository which can provide user's identity, a <code>UserIdentityResolver</code> can then be used in the security interceptor to resolve it and make it available in the security context:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

import io.inverno.core.annotation.Bean;
import io.inverno.mod.http.base.UnauthorizedException;
import io.inverno.mod.http.server.ExchangeContext;
import io.inverno.mod.security.accesscontrol.AccessController;
import io.inverno.mod.security.authentication.LoginCredentialsMatcher;
import io.inverno.mod.security.authentication.password.RawPassword;
import io.inverno.mod.security.authentication.user.InMemoryUserRepository;
import io.inverno.mod.security.authentication.user.User;
import io.inverno.mod.security.authentication.user.UserAuthenticator;
import io.inverno.mod.security.http.AccessControlInterceptor;
import io.inverno.mod.security.http.SecurityInterceptor;
import io.inverno.mod.security.http.basic.BasicAuthenticationErrorInterceptor;
import io.inverno.mod.security.http.basic.BasicCredentialsExtractor;
import io.inverno.mod.security.http.context.InterceptingSecurityContext;
import io.inverno.mod.security.identity.PersonIdentity;
import io.inverno.mod.security.identity.UserIdentityResolver;
import io.inverno.mod.web.ErrorWebRouter;
import io.inverno.mod.web.ErrorWebRouterConfigurer;
import io.inverno.mod.web.WebInterceptable;
import io.inverno.mod.web.WebInterceptorsConfigurer;
import java.util.List;

@Bean( visibility = Bean.Visibility.PRIVATE )
public class SecurityConfigurer implements WebInterceptorsConfigurer&lt;InterceptingSecurityContext&lt;PersonIdentity, AccessController&gt;&gt;, ErrorWebRouterConfigurer&lt;ExchangeContext&gt; {

    @Override
    public void configure(WebInterceptable&lt;InterceptingSecurityContext&lt;PersonIdentity, AccessController&gt;, ?&gt; interceptors) {
        interceptors
            .intercept()
                .interceptors(List.of(SecurityInterceptor.of(
                        new BasicCredentialsExtractor(),
                        new UserAuthenticator&lt;&gt;(
                            InMemoryUserRepository
                                .of(List.of(
                                    User.of("jsmith")
                                        .password(new RawPassword("password"))
                                        .identity(new PersonIdentity("jsmith", "John", "Smith", "jsmith@inverno.io"))
                                        .build()
                                ))
                                .build(), 
                            new LoginCredentialsMatcher&lt;&gt;()
                        ),
                        new UserIdentityResolver&lt;&gt;()
                    ),
                    AccessControlInterceptor.authenticated()
                ));
    }
    
    @Override
    public void configure(ErrorWebRouter&lt;ExchangeContext&gt; errorRouter) {
        errorRouter
            .intercept()
                .error(UnauthorizedException.class)
                .interceptor(new BasicAuthenticationErrorInterceptor&lt;&gt;("inverno-basic"))
            // We must apply interceptors to intercept white labels error routes
            .applyInterceptors();
    }
}
</code></pre>
                    <p>The <code>PersonIdentity</code> type is now declared in the <code>InterceptingSecurityContext</code> exchange context type and the identity is resolved from user's identity.</p>
                    <p>We can now inject the exchange security context in the route handler and get the identity to provide the personalized message:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

import io.inverno.core.annotation.Bean;
import io.inverno.core.v1.Application;
import io.inverno.mod.http.base.Method;
import io.inverno.mod.security.accesscontrol.AccessController;
import io.inverno.mod.security.http.context.SecurityContext;
import io.inverno.mod.security.identity.PersonIdentity;
import io.inverno.mod.web.annotation.WebController;
import io.inverno.mod.web.annotation.WebRoute;

@Bean
@WebController
public class Main {
    
    @WebRoute( path = "/hello", method = Method.GET)
    public String hello(SecurityContext&lt;? extends PersonIdentity, ? extends AccessController&gt; securityContext) {
        return "Hello " + securityContext.getIdentity().map(PersonIdentity::getFirstName).orElse("whoever you are") + "!";
    }
}
</code></pre>
                    <blockquote>
                        <p>Here we injected <code>io.inverno.mod.security.http.context.SecurityContext</code> which extends both <code>io.inverno.mod.security.context.SecurityContext</code> and <code>ExchangeContext</code>. This interface is not mutable and exposes the exact same components as the regular security context, it should be used in application's route interceptors and handlers. On the other hand, the <code>InterceptingSecurityContext</code> is mutable and should only be used by security related interceptors and the <code>SecurityInterceptor</code> in particular.</p>
                    </blockquote>
                    <p>User <code>jsmith</code> should now receive a personalized message when requesting http://localhost:8080/hello:</p>
                    <pre><code class="language-plaintext">$ curl -i -H 'authorization: basic anNtaXRoOnBhc3N3b3Jk' http://127.0.0.1:8080/hello
HTTP/1.1 200 OK
content-length: 11

Hello John!
</code></pre>
                    <p>Let's create another endpoint for VIP users responding with an extra polite message. VIP users can be placed into the <code>vip</code> group and a <code>RoleBasedAccessContoller</code> can be resolved using a <code>GroupsRoleBasedAccessControllerResolver</code>.</p>
                    <p>Let's start by creating the <code>/vip/hello</code> route:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

import io.inverno.core.annotation.Bean;
import io.inverno.core.v1.Application;
import io.inverno.mod.http.base.ForbiddenException;
import io.inverno.mod.http.base.Method;
import io.inverno.mod.security.accesscontrol.AccessController;
import io.inverno.mod.security.accesscontrol.RoleBasedAccessController;
import io.inverno.mod.security.http.context.SecurityContext;
import io.inverno.mod.security.identity.PersonIdentity;
import io.inverno.mod.web.annotation.WebController;
import io.inverno.mod.web.annotation.WebRoute;
import reactor.core.publisher.Mono;

@Bean
@WebController
public class Main {
    
    ...
    @WebRoute( path = "/vip/hello", method = Method.GET)
    public Mono&lt;String&gt; hello_vip(SecurityContext&lt;? extends PersonIdentity, ? extends RoleBasedAccessController&gt; securityContext) {
        return securityContext.getAccessController()
            .orElseThrow(() -&gt; new ForbiddenException())
            .hasRole("vip")
            .map(isVip -&gt; {
                if(!isVip) {
                    throw new ForbiddenException();
                }
                return "Hello my dear friend " + securityContext.getIdentity().map(PersonIdentity::getFirstName).orElse("whoever you are") + "!";
            });
    }
    ...
}
</code></pre>
                    <blockquote>
                        <p>You may have notice that we did not have to change the <code>/hello</code> route definition which can still declare <code>SecurityContext&lt;? extends PersonIdentity, ? extends AccessController&gt;</code> since it is assignable from the actual context type <code>SecurityContext&lt;PersonIdentity, RoleBasedAccessController&gt;</code> declared in the security configurer. Note that a compilation error would have been raised to report inconsistent exchange context types if we had not used upper bound wildcards.</p>
                    </blockquote>
                    <p>We can now change the Web configurer to resolve the role-based access controller using a <code>GroupsRoleBasedAccessControllerResolver</code>.</p>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

import io.inverno.core.annotation.Bean;
import io.inverno.mod.http.base.UnauthorizedException;
import io.inverno.mod.http.server.ExchangeContext;
import io.inverno.mod.security.accesscontrol.GroupsRoleBasedAccessControllerResolver;
import io.inverno.mod.security.accesscontrol.RoleBasedAccessController;
import io.inverno.mod.security.authentication.LoginCredentialsMatcher;
import io.inverno.mod.security.authentication.password.RawPassword;
import io.inverno.mod.security.authentication.user.InMemoryUserRepository;
import io.inverno.mod.security.authentication.user.User;
import io.inverno.mod.security.authentication.user.UserAuthenticator;
import io.inverno.mod.security.http.AccessControlInterceptor;
import io.inverno.mod.security.http.SecurityInterceptor;
import io.inverno.mod.security.http.basic.BasicAuthenticationErrorInterceptor;
import io.inverno.mod.security.http.basic.BasicCredentialsExtractor;
import io.inverno.mod.security.http.context.InterceptingSecurityContext;
import io.inverno.mod.security.identity.PersonIdentity;
import io.inverno.mod.security.identity.UserIdentityResolver;
import io.inverno.mod.web.ErrorWebRouter;
import io.inverno.mod.web.ErrorWebRouterConfigurer;
import io.inverno.mod.web.WebInterceptable;
import io.inverno.mod.web.WebInterceptorsConfigurer;
import java.util.List;

@Bean( visibility = Bean.Visibility.PRIVATE )
public class SecurityConfigurer implements WebInterceptorsConfigurer&lt;InterceptingSecurityContext&lt;PersonIdentity, RoleBasedAccessController&gt;&gt;, ErrorWebRouterConfigurer&lt;ExchangeContext&gt; {

    @Override
    public void configure(WebInterceptable&lt;InterceptingSecurityContext&lt;PersonIdentity, RoleBasedAccessController&gt;, ?&gt; interceptors) {
        interceptors
            .intercept()
                .interceptors(List.of(SecurityInterceptor.of(
                        new BasicCredentialsExtractor(),
                        new UserAuthenticator&lt;&gt;(
                            InMemoryUserRepository
                                .of(List.of(
                                    User.of("jsmith")
                                        .password(new RawPassword("password"))
                                        .identity(new PersonIdentity("jsmith", "John", "Smith", "jsmith@inverno.io"))
                                        .groups("vip")
                                        .build(),
                                    User.of("adoe")
                                        .password(new RawPassword("password"))
                                        .identity(new PersonIdentity("adoe", "Alice", "Doe", "adoe@inverno.io"))
                                        .build()
                                ))
                                .build(), 
                            new LoginCredentialsMatcher&lt;&gt;()
                        ),
                        new UserIdentityResolver&lt;&gt;(),
                        new GroupsRoleBasedAccessControllerResolver()
                    ),
                    AccessControlInterceptor.authenticated()
                ));
    }
    ...
}
</code></pre>
                    <p>The <code>RoleBasedAccessController</code> type is now declared in the <code>InterceptingSecurityContext</code> exchange context type, we also added another normal user and a role-based access controller based on users' groups is now resolved.</p>
                    <p>Accessing route <code>/hello</code> and <code>/vip/hello</code> with different users should provide the following results:</p>
                    <pre><code class="language-plaintext">$ curl -i -H 'authorization: basic anNtaXRoOnBhc3N3b3Jk' http://127.0.0.1:8080/hello
HTTP/1.1 200 OK
content-length: 11

Hello John!

$ curl -i -H 'authorization: basic anNtaXRoOnBhc3N3b3Jk' http://127.0.0.1:8080/vip/hello
HTTP/1.1 200 OK
content-length: 26

Hello my dear friend John!

$ curl -i -H 'authorization: basic YWRvZTpwYXNzd29yZA==' http://127.0.0.1:8080/hello
HTTP/1.1 200 OK
content-length: 12

Hello Alice!

$ curl -i -H 'authorization: basic YWRvZTpwYXNzd29yZA==' http://127.0.0.1:8080/vip/hello
HTTP/1.1 403 Forbidden
content-length: 0

</code></pre>
                    <p>Here we have decided to control access inside the <code>/vip/hello</code> route handler but we could have also globally restrict access to <code>/vip/**</code> routes to VIP users using an <code>AccessControlInterceptor</code> in the security configurer:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

import io.inverno.core.annotation.Bean;
import io.inverno.mod.http.base.ForbiddenException;
import io.inverno.mod.http.base.UnauthorizedException;
import io.inverno.mod.http.server.ExchangeContext;
import io.inverno.mod.security.accesscontrol.GroupsRoleBasedAccessControllerResolver;
import io.inverno.mod.security.accesscontrol.RoleBasedAccessController;
import io.inverno.mod.security.authentication.LoginCredentialsMatcher;
import io.inverno.mod.security.authentication.password.RawPassword;
import io.inverno.mod.security.authentication.user.InMemoryUserRepository;
import io.inverno.mod.security.authentication.user.User;
import io.inverno.mod.security.authentication.user.UserAuthenticator;
import io.inverno.mod.security.http.AccessControlInterceptor;
import io.inverno.mod.security.http.SecurityInterceptor;
import io.inverno.mod.security.http.basic.BasicAuthenticationErrorInterceptor;
import io.inverno.mod.security.http.basic.BasicCredentialsExtractor;
import io.inverno.mod.security.http.context.InterceptingSecurityContext;
import io.inverno.mod.security.identity.PersonIdentity;
import io.inverno.mod.security.identity.UserIdentityResolver;
import io.inverno.mod.web.ErrorWebRouter;
import io.inverno.mod.web.ErrorWebRouterConfigurer;
import io.inverno.mod.web.WebInterceptable;
import io.inverno.mod.web.WebInterceptorsConfigurer;
import java.util.List;

@Bean( visibility = Bean.Visibility.PRIVATE )
public class SecurityConfigurer implements WebInterceptorsConfigurer&lt;InterceptingSecurityContext&lt;PersonIdentity, RoleBasedAccessController&gt;&gt;, ErrorWebRouterConfigurer&lt;ExchangeContext&gt; {

    @Override
    public void configure(WebInterceptable&lt;InterceptingSecurityContext&lt;PersonIdentity, RoleBasedAccessController&gt;, ?&gt; interceptors) {
        interceptors
            ...
            .intercept()
                .path("/vip/**")
                .interceptor(AccessControlInterceptor.verify(securityContext -&gt; securityContext.getAccessController()
                    .orElseThrow(() -&gt; new ForbiddenException())
                    .hasRole("vip")
                ));
    }
    ...
}
</code></pre>
                    <p>The <code>/vip/hello</code> route handler can then be simplified while still being only accessible by VIP users:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

import io.inverno.core.annotation.Bean;
import io.inverno.core.v1.Application;
import io.inverno.mod.http.base.Method;
import io.inverno.mod.security.accesscontrol.AccessController;
import io.inverno.mod.security.accesscontrol.RoleBasedAccessController;
import io.inverno.mod.security.http.context.SecurityContext;
import io.inverno.mod.security.identity.PersonIdentity;
import io.inverno.mod.web.annotation.WebController;
import io.inverno.mod.web.annotation.WebRoute;

@Bean
@WebController
public class Main {
    
    ...
    @WebRoute( path = "/vip/hello", method = Method.GET)
    public String hello_vip(SecurityContext&lt;? extends PersonIdentity, ? extends RoleBasedAccessController&gt; securityContext) {
        return "Hello my dear friend " + securityContext.getIdentity().map(PersonIdentity::getFirstName).orElse("whoever you are") + "!";
    }
    ...
}
</code></pre>
                    <blockquote>
                        <p>If you followed the <em>security</em> module documentation, and you should have, you might have noticed how the <code>SecurityInterceptor</code> is similar to the <code>SecurityManager</code>, they basically have the same role which is to authenticate a request and provide a security context which, although we had to create an exchange security context, is still the central component used to secure the application. As a result, securing a Web application is no different than securing a regular application and it should therefore be easy to create secured components and libraries that can be integrated in both.</p>
                    </blockquote>
                    <h4 id="security-interceptor">Security Interceptor</h4>
                    <p>The <code>SecurityInterceptor</code> is the main entry point for securing an HTTP server or a Web application, it is the counterpart of the <code>SecurityManager</code> for regular applications. Its role is to extract <code>Credentials</code> from HTTP requests and just like the <code>SecurityManager</code>, to authenticate them and possibly resolve an <code>Identity</code> and/or an <code>AccessController</code>. It then sets the resulting security context in the exchange. Exchange interceptors and handlers can then access the security context anytime for securing services and resources.</p>
                    <p>A <code>SecurityInterceptor</code> instance is created by composing a <code>CredentialsExtractor</code> used to extract <code>Credentials</code> from the request in addition to the <code>Authenticator</code> and optional <code>IdentityResolver</code> and <code>AccessControllerResolver</code>. It should be used to intercept request targeting services or resources that must be secured or require identity information.</p>
                    <p>Although it is completely possible to use it on the global exchange handler in the HTTP server controller, we will focus on securing Web routes in a Web server in the rest of this documentation as it covers more interesting use cases.</p>
                    <p>As for the <code>SecurityManager</code>, the <code>SecurityInterceptor</code> basically chains the extraction of credentials, the authentication, the identity resolution and the access controller resolution and sets the resulting <code>SecurityContext</code> in the exchange context declared as a <code>InterceptingSecurityContext</code>.</p>
                    <p>A <code>SecurityInterceptor</code> is created as follows:</p>
                    <pre><code class="language-java">CredentialsExtractor&lt;Credentials&gt; credentialsExtractor = ...
Authenticator&lt;Credentials, Authentication&gt; authenticator = ...
IdentityResolver&lt;Authentication, Identity&gt; identityResolver = ...
AccessControllerResolver&lt;Authentication, AccessController&gt; accessControllerResolver = ...

SecurityInterceptor&lt;Credentials, Identity, AccessController, InterceptingSecurityContext&lt;Identity, AccessController&gt;, Exchange&lt;InterceptingSecurityContext&lt;Identity, AccessController&gt;&gt;&gt; securityInterceptor = SecurityInterceptor.of(credentialsExtractor, authenticator, identityResolver, accessControllerResolver);
</code></pre>
                    <p>It can be applied to Web routes just like any other exchange interceptor by defining a Web configurer implementing <code>WebInterceptorsConfigurer</code> or <code>WebRouterConfigurer</code>. The following example shows how to secure access by applying the security interceptor to all <code>/vip/**</code> routes:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

import io.inverno.mod.security.accesscontrol.AccessController;
import io.inverno.mod.security.accesscontrol.AccessControllerResolver;
import io.inverno.mod.security.authentication.Authenticator;
import io.inverno.mod.security.identity.Identity;
import io.inverno.mod.security.identity.IdentityResolver;
import io.inverno.mod.security.http.CredentialsExtractor;
import io.inverno.mod.security.http.SecurityInterceptor;
import io.inverno.mod.security.http.context.InterceptingSecurityContext;
import io.inverno.mod.web.WebInterceptable;
import io.inverno.mod.web.WebInterceptorsConfigurer;

public class SecurityConfigurer implements WebInterceptorsConfigurer&lt;InterceptingSecurityContext&lt;Identity, AccessController&gt;&gt; {

	@Override
	public void configure(WebInterceptable&lt;InterceptingSecurityContext&lt;PersonIdentity, AccessController&gt;, ?&gt; interceptors) {
        CredentialsExtractor&lt;Credentials&gt; credentialsExtractor = ...
        Authenticator&lt;Credentials, Authentication&gt; authenticator = ...
        IdentityResolver&lt;Authentication, Identity&gt; identityResolver = ...
        AccessControllerResolver&lt;Authentication, AccessController&gt; accessControllerResolver = ...

		interceptors
			.intercept()
                .path("/vip/**")
				.interceptor(SecurityInterceptor.of(credentialsExtractor, authenticator, identityResolver, accessControllerResolver));
	}
}
</code></pre>
                    <p>By combining various implementations of <code>CredentialsExtractor</code>, <code>Authenticator</code>, <code>IdentityResolver</code> and <code>AccessControllerResolver</code>, it is possible to implements any kind of HTTP authentication methods (e.g. basic, digest, token...). It is still good to remember that the role of the security interceptor is to authenticate credentials and create a resulting security context which can be anonymous, denied or authenticated, actual access control must be done in subsequent interceptors or within the route handler.</p>
                    <blockquote>
                        <p>Since the security interceptor is a regular exchange interceptor, it is possible to define various instances applied to different routes. We can for instance imagine using different security interceptors implementing different authentication methods or targeting different user repositories based on the path, the language... basically any routing criteria exposed by the <code>WebRouteManager</code>.</p>
                    </blockquote>
                    <h5 id="credentialsextractor">CredentialsExtractor</h5>
                    <p>A credentials extractor is used in a security interceptor to extract <code>Credentials</code> from an HTTP request. The <code>CredentialsExtractor</code> interface is a functional interface defining method <code>extract()</code>. The following example shows a simple inline implementation that extract <code>LoginCredentials</code> from HTTP headers returning no credentials if either username or password is missing:</p>
                    <pre><code class="language-java">CredentialsExtractor&lt;LoginCredentials&gt; credentialsExtractor = exchange -&gt; {
    return Mono.fromSupplier(() -&gt; exchange.request().headers().get("username")
        .flatMap(username -&gt; exchange.request().headers().get("password")
            .map(RawPassword::new)
            .map(password -&gt; LoginCredentials.of(username, password))
        )
        .orElse(null)
    );
};
</code></pre>
                    <p>When no credentials are returned, the security interceptor creates an anonymous security context.</p>
                    <p>Mutliple credentials extractor can be chained in order to extract credentials from different location within the request by order of prefrerence. For instance, we can create a credentials extractor to extract <code>TokenCredentials</code> from an HTTP header, a cookie, or a query parameter in that order.</p>
                    <pre><code class="language-java">CredentialsExtractor&lt;TokenCredentials&gt; headerTokenCredentialsExtractor = exchange -&gt; {
    return Mono.fromSupplier(() -&gt; exchange.request().headers().get("token").map(TokenCredentials::new).orElse(null));
};

CredentialsExtractor&lt;TokenCredentials&gt; cookieTokenCredentialsExtractor = exchange -&gt; {
    return Mono.fromSupplier(() -&gt; exchange.request().cookies().get("token").map(cookie -&gt; new TokenCredentials(cookie.asString())).orElse(null));
};

CredentialsExtractor&lt;TokenCredentials&gt; queryTokenCredentialsExtractor = exchange -&gt; {
    return Mono.fromSupplier(() -&gt; exchange.request().queryParameters().get("token").map(parameter -&gt; new TokenCredentials(parameter.asString())).orElse(null));
};

CredentialsExtractor&lt;TokenCredentials&gt; credentialsExtractor = headerTokenCredentialsExtractor
        .or(cookieTokenCredentialsExtractor)
        .or(queryTokenCredentialsExtractor);
</code></pre>
                    <h5 id="securitycontext-vs-http-securitycontext-vs-interceptingsecuritycontext">SecurityContext vs HTTP SecurityContext vs InterceptingSecurityContext</h5>
                    <p>The <em>security-http</em> module provides <code>io.inverno.mod.security.http.context.SecurityContext</code> which extends both <code>ExchangeContext</code> and <code>io.inverno.mod.security.context.SecurityContext</code> defined in the <em>security</em> module. Although the security context semantic remains unchanged, this was necessary to be able to expose it as an exchange context. The <code>io.inverno.mod.security.http.context.SecurityContext</code> can be seen as a security exchange context, it must be used to secure HTTP endpoints as it can be accessed from the <code>Exchange</code> and injected in Web route handlers.</p>
                    <p>It also provides the <code>io.inverno.mod.security.http.context.InterceptingSecurityContext</code> which extends <code>io.inverno.mod.security.http.context.SecurityContext</code> and exposes a single <code>setSecurityContext()</code> method. This is a mutable version of the <code>io.inverno.mod.security.http.context.SecurityContext</code> which enables security related interceptors or handlers, such as the <code>SecurityInterceptor</code>, to set the <code>io.inverno.mod.security.context.SecurityContext</code> in the security exchange context.</p>
                    <blockquote>
                        <p>In the end, every <code>ExchangeContext</code> types should be implemented in the generated global <code>ExchangeContext</code> type which will basically implements both <code>io.inverno.mod.security.http.context.SecurityContext</code> and <code>io.inverno.mod.security.http.context.InterceptingSecurityContext</code>. However making sure <code>io.inverno.mod.security.http.context.SecurityContext</code> is used in applicative interceptors and handlers and only allow the <code>io.inverno.mod.security.http.context.InterceptingSecurityContext</code> in specific trusted security interceptors and handlers is a good way to control and protect the security context against untrustful modifications.</p>
                    </blockquote>
                    <h4 id="access-control-interceptor">Access Control Interceptor</h4>
                    <p>As we just saw, the role of the security interceptor is to authenticate credentials and provides a security context but it does not actually control access. The security context can be anonymous, denied or authenticated, actual access control must then be done in a subsequent interceptors and/or directly in the route handler. An <code>AccessControlInterceptor</code> can be applied on secured routes to control access globally.</p>
                    <p>In the following example, <code>AccessControlInterceptor.authenticated()</code> is used to create an interceptor that restricts access to authenticated users.</p>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

import io.inverno.mod.security.accesscontrol.AccessController;
import io.inverno.mod.security.accesscontrol.AccessControllerResolver;
import io.inverno.mod.security.authentication.Authenticator;
import io.inverno.mod.security.identity.Identity;
import io.inverno.mod.security.identity.IdentityResolver;
import io.inverno.mod.security.http.AccessControlInterceptor;
import io.inverno.mod.security.http.CredentialsExtractor;
import io.inverno.mod.security.http.SecurityInterceptor;
import io.inverno.mod.security.http.context.InterceptingSecurityContext;
import io.inverno.mod.web.WebInterceptable;
import io.inverno.mod.web.WebInterceptorsConfigurer;
import java.util.List;

public class SecurityConfigurer implements WebInterceptorsConfigurer&lt;InterceptingSecurityContext&lt;Identity, AccessController&gt;&gt; {

	@Override
	public void configure(WebInterceptable&lt;InterceptingSecurityContext&lt;PersonIdentity, AccessController&gt;, ?&gt; interceptors) {
        CredentialsExtractor&lt;Credentials&gt; credentialsExtractor = ...
        Authenticator&lt;Credentials, Authentication&gt; authenticator = ...
        IdentityResolver&lt;Authentication, Identity&gt; identityResolver = ...
        AccessControllerResolver&lt;Authentication, AccessController&gt; accessControllerResolver = ...

		interceptors
			.intercept()
                .path("/vip/**")
				.interceptors(List.of(
                    SecurityInterceptor.of(credentialsExtractor, authenticator, identityResolver, accessControllerResolver),
                    AccessControlInterceptor.authenticated()
                ));
	}
}
</code></pre>
                    <p>We can use <code>AccessControlInterceptor.anonymous()</code> to restrict access to anonymous users or we can also provide custom access control using <code>AccessControlInterceptor.verify()</code> as follows:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

import io.inverno.mod.http.base.ForbiddenException;
import io.inverno.mod.security.accesscontrol.AccessControllerResolver;
import io.inverno.mod.security.accesscontrol.RoleBasedAccessController;
import io.inverno.mod.security.authentication.Authentication;
import io.inverno.mod.security.authentication.Authenticator;
import io.inverno.mod.security.authentication.Credentials;
import io.inverno.mod.security.http.AccessControlInterceptor;
import io.inverno.mod.security.http.CredentialsExtractor;
import io.inverno.mod.security.http.SecurityInterceptor;
import io.inverno.mod.security.http.context.InterceptingSecurityContext;
import io.inverno.mod.security.identity.Identity;
import io.inverno.mod.security.identity.IdentityResolver;
import io.inverno.mod.web.WebInterceptable;
import io.inverno.mod.web.WebInterceptorsConfigurer;
import java.util.List;

public class SecurityConfigurer implements WebInterceptorsConfigurer&lt;InterceptingSecurityContext&lt;Identity, RoleBasedAccessController&gt;&gt; {

    @Override
    public void configure(WebInterceptable&lt;InterceptingSecurityContext&lt;Identity, RoleBasedAccessController&gt;, ?&gt; interceptors) {
        CredentialsExtractor&lt;Credentials&gt; credentialsExtractor = null;
        Authenticator&lt;Credentials, Authentication&gt; authenticator = null;
        IdentityResolver&lt;Authentication, Identity&gt; identityResolver = null;
        AccessControllerResolver&lt;Authentication, RoleBasedAccessController&gt; accessControllerResolver = null;

        interceptors
            .intercept()
                .path("/vip/**")
                .interceptors(List.of(
                    SecurityInterceptor.of(credentialsExtractor, authenticator, identityResolver, accessControllerResolver),
                    AccessControlInterceptor.verify(securityContext -&gt; securityContext.getAccessController()
                        .orElseThrow(() -&gt; new ForbiddenException())
                        .hasRole("vip")
                    )
                ));
    }
}
</code></pre>
                    <h4 id="http-authentication">HTTP authentication</h4>
                    <p>By combining <code>CredentialsExtractor</code> with <code>Authenticator</code>, it is possible to implement various HTTP authentication methods. The security HTTP API provides credentials extractors as well as exchange interceptors and handlers that facilitate the configuration of standard HTTP authentication methods in Web applications.</p>
                    <h5 id="http-basic-authentication">HTTP Basic authentication</h5>
                    <p>The <a href="https://datatracker.ietf.org/doc/html/rfc7617">basic HTTP authentication scheme</a> is, as its name suggests, a basic authentication method on top of HTTP in which credentials are provided in the <code>authorization</code> HTTP header in the form <code>basic Base64(username ":" password)</code>. Basic authentication can be requested to the client (e.g. a Web browser) by specifying a <code>www-authenticate</code> HTTP header in an unauthorized (401) response sent when a protected resource is requested without credentials or with invalid credentials.</p>
                    <p>A security context implementing HTTP basic authentication is obtained by combining the <code>BasicCredentialsExtractor</code> which extracts <code>LoginCredentials</code> with a compatible <code>Authenticator</code> implementation. The following example uses a basic <code>PrincipalAuthenticator</code> with an in-memory login credentials resolver in order to secure <code>/basic/**</code> routes:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

...
import io.inverno.mod.security.http.basic.BasicCredentialsExtractor;
...

...
public class SecurityConfigurer implements WebInterceptorsConfigurer&lt;InterceptingSecurityContext&lt;Identity, AccessController&gt;&gt; {

    @Override
    public void configure(WebInterceptable&lt;InterceptingSecurityContext&lt;Identity, AccessController&gt;, ?&gt; interceptors) {
        interceptors
            .intercept()
                .path("/basic/**")
                .interceptor(SecurityInterceptor.of(
                    new BasicCredentialsExtractor(),
                    new PrincipalAuthenticator&lt;&gt;(
                        new InMemoryLoginCredentialsResolver(List.of(
                            LoginCredentials.of("john", new MessageDigestPassword.Encoder().encode("password")),
                            LoginCredentials.of("alice", new MessageDigestPassword.Encoder().encode("password")),
                            LoginCredentials.of("bob", new MessageDigestPassword.Encoder().encode("password"))
                        )), 
                        new LoginCredentialsMatcher&lt;LoginCredentials, LoginCredentials&gt;()
                    )
                ));
    }
}
</code></pre>
                    <p>In order to fully implement HTTP basic authentication scheme as defined by <a href="https://datatracker.ietf.org/doc/html/rfc7617">RFC 7617</a>, we also need to send a basic authentication challenge on unauthorized (401) errors. This can be done by intercepting <code>UnauthorizedException</code> on secured routes using a <code>BasicAuthenticationErrorInterceptor</code>:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

...
import io.inverno.mod.security.http.basic.BasicAuthenticationErrorInterceptor;
...

...
public class SecurityConfigurer implements WebInterceptorsConfigurer&lt;InterceptingSecurityContext&lt;Identity, AccessController&gt;&gt;, ErrorWebRouterConfigurer&lt;ExchangeContext&gt; {

    ...
    @Override
    public void configure(ErrorWebRouter&lt;ExchangeContext&gt; errorRouter) {
        errorRouter
            .intercept()
                .error(UnauthorizedException.class)
                .path("/basic/**")
                .interceptor(new BasicAuthenticationErrorInterceptor&lt;&gt;("inverno-basic"))
                 // We must apply interceptors to intercept white labels error routes which are already defined 
                .applyInterceptors();
    }
}
</code></pre>
                    <p>Using above configuration, unauthorized (401) error response corresponding to unauthenticated access will be augmented with a <code>www-authenticate</code> HTTP header requesting for basic authentication in the <code>inverno-basic</code> realm. In practice, this results in a login prompt being displayed in a Web browser.</p>
                    <p>The following shows an unauthorized (401) HTTP response with a basic authentication challenge generated by the <code>BasicAuthenticationErrorInterceptor</code>:</p>
                    <pre><code class="language-plaintext">$ curl -i http://127.0.0.1:8080/basic/hello
HTTP/1.1 401 Unauthorized
www-authenticate: basic realm="inverno-basic"
content-length: 0

</code></pre>
                    <blockquote>
                        <p>Sending a basic authentication challenge to the client has actually nothing to do with authentication, it simply gives indication to the client on what credentials are expected by the server to access a protected resource. If you don't need to strictly abide to the specification or if your HTTP resources will only be consumed by backend applications you might choose not to use the <code>BasicAuthenticationErrorInterceptor</code>.</p>
                    </blockquote>
                    <h5 id="http-digest-authentication">HTTP Digest authentication</h5>
                    <p>The <a href="https://datatracker.ietf.org/doc/html/rfc7616">HTTP digest access authentication</a> is a more secured HTTP authentication method in which login credentials (username/password) are sent digested by the client using a nonce previously sent by the server in a <code>www-authenticate</code> HTTP header. As for basic authentication, digest credentials are provided in the <code>authorization</code> HTTP header. The nonce is built using a secret, the current timestamp and a validity period which allows to expire digest credentials.</p>
                    <p>A security context implementing HTTP digest authentication is obtained by combining the <code>DigestCredentialsExtractor</code> which extracts <code>DigestCredentials</code> with a compatible <code>Authenticator</code> implementation. The <code>DigestCredentialsMatcher</code> can be used within a <code>PrincipalAuthenticator</code> or a <code>UserAuthenticator</code> to match digest credentials against trusted login credentials (digest credentials basically represent digested login credentials). The following example uses a <code>UserAuthenticator</code> with an in-memory user repository and a <code>DigestCredentialsMatcher</code> in order to secure <code>/digest/**</code> routes:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

...
import io.inverno.mod.security.http.digest.DigestCredentialsExtractor;
import io.inverno.mod.security.http.digest.DigestCredentialsMatcher;
...

...
public class SecurityConfigurer implements WebInterceptorsConfigurer&lt;InterceptingSecurityContext&lt;Identity, AccessController&gt;&gt; {

    @Override
    public void configure(WebInterceptable&lt;InterceptingSecurityContext&lt;Identity, AccessController&gt;, ?&gt; interceptors) {
        interceptors
            .intercept()
                .path("/digest/**")
                .interceptor(SecurityInterceptor.of(
                    new DigestCredentialsExtractor(),
                    new UserAuthenticator&lt;&gt;(
                        InMemoryUserRepository
                            .of(List.of(
                                User.of("jsmith")
                                    .password(new RawPassword("password"))
                                    .build(),
                                User.of("adoe")
                                    .password(new RawPassword("password"))
                                    .build()
                            ))
                            .build(), 
                        new DigestCredentialsMatcher&lt;&gt;("secret")
                    )
                ));
    }
}
</code></pre>
                    <p>As previously mentionned, digest credentials expire at a fixed datetime specified in the nonce, this is checked in the <code>DigestCredentialsMatcher</code> which fails authentication with a <code>ExpiredNonceException</code> when this happens.</p>
                    <p>The HTTP digest access authentication is based on a challenge-response mechanism as a result a digest authentication challenge must be generated server-side on an unauthorized access or expired nonce errors and sent to the client prior to authentication. This is done using a <code>DigestAuthenticationErrorInterceptor</code> on secured routes to intercept <code>UnauthorizedException</code> errors:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

...
import io.inverno.mod.security.http.basic.BasicAuthenticationErrorInterceptor;
...

...
public class SecurityConfigurer implements WebInterceptorsConfigurer&lt;InterceptingSecurityContext&lt;Identity, AccessController&gt;&gt;, ErrorWebRouterConfigurer&lt;ExchangeContext&gt; {

    ...
    @Override
    public void configure(ErrorWebRouter&lt;ExchangeContext&gt; errorRouter) {
        errorRouter
            .intercept()
                .error(UnauthorizedException.class)
                .path("/digest/**")
                .interceptor(new DigestAuthenticationErrorInterceptor&lt;&gt;("inverno-digest", "secret"))
                 // We must apply interceptors to intercept white labels error routes which are already defined 
                .applyInterceptors();
    }
}
</code></pre>
                    <p>Using above configuration, an unauthorized (401) error response corresponding to unauthenticated access will be augmented with a <code>www-authenticate</code> HTTP header containing the digest authentication challenge requesting for digest credentials in the <code>inverno-digest</code> realm. The interceptor basically generates a nonce using the specified secret, the nonce validity period (defaults to 300 seconds) and the message digest algorithm (defaults to <code>MD5</code>). In practice, this results in a login prompt being displayed in a Web browser.</p>
                    <p>The following shows an unauthorized (401) HTTP response with a digest authentication challenge generated by the <code>DigestAuthenticationErrorInterceptor</code>:</p>
                    <pre><code class="language-plaintext">$ curl -i http://localhost:8080/digest/hello
HTTP/1.1 401 Unauthorized
www-authenticate: digest realm="inverno-digest",qop="auth",nonce="ODg2OTk2MzI3NjcwMzAwOjAyZmIxNWY0ZTAyMTA0NzMzMzdjYmU4YmY4NWRhOGI4",algorithm=MD5
content-length: 0

</code></pre>
                    <h5 id="token-based-authentication">Token based authentication</h5>
                    <p>Token based authentication is a simple authentiation method based on the authentication of a token which was usually previously issued to the client by the server.</p>
                    <p>A token must be ideally difficult to forge and easy to validate which is why cryptographic methods are often used to generate secured token but solution based on random numbers stored in a trusted data store (like a session store) can also be considered.</p>
                    <p>A security context implementing token based authentication can be obtained by combining a <code>TokenCredentials</code> extractor with a compatible <code>Authenticator</code> implementation. The following example uses a <code>CookieTokenCredentialsExtractor</code> to extract <code>TokenCredentials</code> from a specific cookie and a simplistic highly unsecure authenticator which validates tokens against an hardcoded list of authorized tokens:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

...
import io.inverno.mod.security.http.token.CookieTokenCredentialsExtractor;
...

...
public class SecurityConfigurer implements WebInterceptorsConfigurer&lt;InterceptingSecurityContext&lt;Identity, AccessController&gt;&gt; {

    @Override
    public void configure(WebInterceptable&lt;InterceptingSecurityContext&lt;Identity, AccessController&gt;, ?&gt; interceptors) {
        interceptors
            .intercept()
				.path("/token/**")
				.interceptor(SecurityInterceptor.of(
					new CookieTokenCredentialsExtractor(),
					credentials -&gt; Mono.fromSupplier(() -&gt; {
						if(Set.of("token1", "token2", "token3").contains(credentials.getToken())) {
							return Authentication.granted();
						}
						return Authentication.denied();
					})
				));
    }
}
</code></pre>
                    <blockquote>
                        <p>As already mentionned, a proper token must be ideally hard to forge and using cryptographic solution such as <a href="https://datatracker.ietf.org/doc/html/rfc7515">JWS</a>, <a href="https://datatracker.ietf.org/doc/html/rfc7516">JWE</a> or <a href="https://datatracker.ietf.org/doc/html/rfc7519">JWT</a> are highly recommended.</p>
                    </blockquote>
                    <h5 id="form-based-login">Form based login</h5>
                    <p>Form based login is meant to be used to log physical users in an application using a login page in a Web browser. This is slightly more complex than a basic authentication as it usually involves the use of multiple authentication methods.</p>
                    <p>The login flow is started when a user tries to access a protected resource (1) in a Web browser without credentials or with invalid credentials, an unauthorized (401) is then raised and the user is redirected to the login page prompting for credentials (2), usually a username/password pair. The user then fills the input fields and submits the form (3) to the login action whose role is to authenticate the credentials and generate temporary credentials, usually token credentials, sent back to the client, usually in a cookie, in a found (302) response (4). The client is then redirected to the page initially requested which is now accessed with valid token credentials (5). The user can then access the protected page (6).</p> <img class="img-fluid shadow mb-4" src="doc/img/form_based_flow.png" alt="Form based login flow" />
                    <p>Form based login then requires two authentication methods: one to authenticate credentials provided by the user to a login action which should generate the actual credentials that are authenticated by the second method to grant access to protected resources.</p>
                    <p>Let's start by configuring Web routes to the login page and the login action.</p>
                    <p>The API provides the <code>FormLoginPageHandler</code> which renders a white label login page containing the login form using an Inverno reactive template. The actual login action URI can be configured when creating the handler (defaults to <code>/login</code>). The login form sends three parameters: <code>username</code>, <code>password</code> and <code>redirect_uri</code>.</p>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

...

public class SecurityConfigurer implements WebRoutesConfigurer&lt;SecurityContext&lt;Identity, AccessController&gt;&gt; {

	@Override
	public void configure(WebRoutable&lt;SecurityContext&lt;Identity, AccessController&gt;, ?&gt; routes) {
		routes
			.route()
				.method(Method.GET)
				.path("/login")
				.produces(MediaTypes.TEXT_HTML)
				.handler(new FormLoginPageHandler&lt;&gt;("/login"));
	}
}
</code></pre>
                    <blockquote>
                        <p>The login page is not different than a standard route and a custom login page can be easily used instead of the white label login page.</p>
                    </blockquote>
                    <p>The <code>LoginActionHandler</code> is a route handler that must be targeted by the login form to authentiate the user credentials. It relies on a <code>CredentialsExtractor</code> to extract credentials from the login request and a compatible <code>Authenticator</code> to authenticate them. Finally, it uses a <code>LoginSuccessHandler</code> and a <code>LoginFailureHandler</code> to determine what to do in case of successful or failed authentication. If no <code>LoginSuccessHandler</code> is defined, a blank response is returned on successful authentication. If no <code>LoginFailureHandler</code> is defined, a unauthorized (401) error is returned on failed authentication.</p>
                    <p>In the following example, we decided to generate a <a href="https://datatracker.ietf.org/doc/html/rfc7515">JWS</a> on successful authentication which requires to inject a <code>JWKService</code> to generate a JSON Web Key and a <code>JWSService</code> to create JWS tokens.</p>
                    <blockquote>
                        <p>Please refer to the <a href="#json-object-signing-and-encryption"><em>security-jose</em> module documentation</a> to learn how to create and validate <a href="https://datatracker.ietf.org/doc/html/rfc7515">JWS</a>, <a href="https://datatracker.ietf.org/doc/html/rfc7516">JWE</a> or <a href="https://datatracker.ietf.org/doc/html/rfc7519">JWT</a>.</p>
                    </blockquote>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

...

public class SecurityConfigurer implements WebRoutesConfigurer&lt;SecurityContext&lt;Identity, AccessController&gt;&gt; {

    private final Mono&lt;? extends OCTJWK&gt; jwsKey;
    private final JWSService jwsService;
    
    public SecurityConfigurer(JWKService jwkService, JWSService jwsService) {
        this.jwsKey = jwkService.oct().generator()
            .algorithm(OCTAlgorithm.HS256.getAlgorithm())
            .generate()
            .cache();
        this.jwsService = jwsService;
    }
    
    @Override
    public void configure(WebRoutable&lt;SecurityContext&lt;Identity, AccessController&gt;, ?&gt; routes) {
        routes
            ...
            .route()
                .method(Method.POST)
                .path("/login")
                .handler(new LoginActionHandler&lt;&gt;(                                                                 // 1 
                    new FormCredentialsExtractor(),                                                                // 2 
                    new PrincipalAuthenticator&lt;&gt;(                                                                  // 3 
                        new InMemoryLoginCredentialsResolver(List.of(
                            LoginCredentials.of("john", new MessageDigestPassword.Encoder().encode("password")),
                            LoginCredentials.of("alice", new MessageDigestPassword.Encoder().encode("password")),
                            LoginCredentials.of("bob", new MessageDigestPassword.Encoder().encode("password"))
                        )), 
                        new LoginCredentialsMatcher&lt;LoginCredentials, LoginCredentials&gt;()
                    )
                    .failOnDenied()                                                                                // 4 
                    .flatMap(authentication -&gt; this.jwsService.builder(PrincipalAuthentication.class, this.jwsKey) // 5 
                        .header(header -&gt; header
                            .algorithm(OCTAlgorithm.HS256.getAlgorithm())
                        )
                        .payload(authentication)
                        .build(MediaTypes.APPLICATION_JSON)
                        .map(JWSAuthentication::new)
                    ),
                    LoginSuccessHandler.of(
                        new CookieTokenLoginSuccessHandler&lt;&gt;("/form"),                                             // 6 
                        new RedirectLoginSuccessHandler&lt;&gt;()                                                        // 7 
                    ),
                    new RedirectLoginFailureHandler&lt;&gt;("/login")                                                    // 8
                ));
    }
}
</code></pre>
                    <ol>
                        <li>The <code>LoginActionHandler</code> is used to handle <code>POST</code> request submitted in the login form.</li>
                        <li>The <code>FormCredentialsExtractor</code> is used to extract user credentials submitted in the login form as <code>LoginCredentials</code>, the actual username and password form parameter names can be set in the credentials extractor (defaults to <code>username</code> and <code>password</code>).</li>
                        <li>A simple <code>PrincipalAuthenticator</code> is then used to authenticate the credentials.</li>
                        <li>The authentication shall fail if the principal authenticator returns a denied authentication.</li>
                        <li>The resulting <code>PrincipalAuthentication</code> is then wrapped into a <code>JWSAuthentication</code>. We don't have to check whether the authentication is authenticated before creating the JWS token since we used <code>failOnDenied()</code>.</li>
                        <li>The <code>CookieTokenLoginSuccessHandler</code> is used to set the compact representation of the JWS token in a response cookie. The cookie name and the cookie path can be set when creating the login success handler (defaults to <code>AUTH-TOKEN</code> and <code>/</code>).</li>
                        <li>The <code>RedirectLoginSuccessHandler</code> is then chained to redirect the user to the the page initially requested.</li>
                        <li>The <code>RedirectLoginFailureHandler</code> is used to redirect the user to the login page in case of failed authentication, the actual authentication error is specified in a query parameter (defaults to <code>error</code>) so it can be displayed in the login form.</li>
                    </ol>
                    <p>The login page and the login action handler are all set, we can now move on and configure a token based authentication to secure <code>/form/**</code> routes and restrict access to authenticated users. Since the login action handler sets a JWS token in a cookie we need to use a <code>CookieTokenCredentialsExtractor</code> to extract the <code>TokenCredentials</code> and a <code>JWSAuthenticator</code> to validate the JWS. The JWS actually wraps the original <code>PrincipalAuthentication</code> we can then unwrap it in order to restore the original authentication.</p>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

...

public class SecurityConfigurer implements WebRoutesConfigurer&lt;SecurityContext&lt;Identity, AccessController&gt;&gt;, WebInterceptorsConfigurer&lt;InterceptingSecurityContext&lt;Identity, AccessController&gt;&gt; {

    ...
    @Override
    public void configure(WebInterceptable&lt;InterceptingSecurityContext&lt;Identity, AccessController&gt;, ?&gt; interceptors) {
        interceptors
            .intercept()
                .path("/form/**")
                .interceptors(List.of(
                    SecurityInterceptor.of(
                        new CookieTokenCredentialsExtractor(), 
                        new JWSAuthenticator&lt;&gt;(this.jwsService, PrincipalAuthentication.class, this.jwsKey)
                            .failOnDenied()
                            .map(jwsAuthentication -&gt; jwsAuthentication.getJws().getPayload())
                    ),
                    AccessControlInterceptor.authenticated()
                ));
    }
}
</code></pre>
                    <p>In above code, the JWS authenticator uses the JWS service to parse and validate the JWS token. A denied <code>JWSAuthentication</code> with an <code>InvalidCredentialsException</code> cause is returned on invalid tokens.</p>
                    <blockquote>
                        <p>Using a JWS token allows to restore the original authentication which can be very useful for resolving identity and/or access controller using regular authentication types (e.g. <code>PrincipalAuthentication</code>, <code>UserAuthentication</code>...).</p>
                    </blockquote>
                    <p>Accessing a protected resource with no token or an invalid token results in an <code>UnauthorizedException</code> error since the access is retricted to authenticated users. the client should then be redirected to the login page. This can be done applying the <code>FormAuthenticationErrorInterceptor</code> on <code>UnauthorizedException</code> errors on <code>/form/**</code> routes.</p>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

...

public class SecurityConfigurer implements WebRoutesConfigurer&lt;SecurityContext&lt;Identity, AccessController&gt;&gt;, WebInterceptorsConfigurer&lt;InterceptingSecurityContext&lt;Identity, AccessController&gt;&gt;, ErrorWebRouterConfigurer&lt;ExchangeContext&gt; {

	...
	@Override
	public void configure(ErrorWebRouter&lt;ExchangeContext&gt; errorRouter) {
		errorRouter
			.intercept()
				.error(UnauthorizedException.class)
				.path("/form/**")
				.interceptor(new FormAuthenticationErrorInterceptor&lt;&gt;("/login"))
			// We must apply interceptors to intercept white labels error routes which are already defined 
			.applyInterceptors(); 
	}
}
</code></pre>
                    <p>Finally, a <code>/logout</code> route can also be defined using a <code>LogoutActionHandler</code> which uses an <code>AuthenticationReleaser</code> to release the security context and a <code>LogoutSuccessHandler</code> to handle successful logout and respond to the client. In the following example, a <code>CookieTokenLogoutSuccessHandler</code> is used to delete the token cookie and a <code>RedirectLogoutSuccessHandler</code> is used to redirect the user after a successful logout to the root of the server (<code>/</code>).</p>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

...

public class SecurityConfigurer implements WebRoutesConfigurer&lt;SecurityContext&lt;Identity, AccessController&gt;&gt;, WebInterceptorsConfigurer&lt;InterceptingSecurityContext&lt;Identity, AccessController&gt;&gt;, ErrorWebRouterConfigurer&lt;ExchangeContext&gt; {

    ...
    @Override
    public void configure(WebRoutable&lt;SecurityContext&lt;Identity, AccessController&gt;, ?&gt; routes) {
        routes
            ...
            .route()
                .method(Method.GET)
                .path("/logout")
                .handler(new LogoutActionHandler&lt;&gt;(
                    authentication -&gt; Mono.empty(),
                    LogoutSuccessHandler.of(
                        new CookieTokenLogoutSuccessHandler&lt;&gt;("/form"),
                        new RedirectLogoutSuccessHandler&lt;&gt;()
                    )
                ));
    }
    ...
}
</code></pre>
                    <p>Here is the complete code of the <code>SecurityConfigurer</code> used to configure form login flow:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

import io.inverno.core.annotation.Bean;
import io.inverno.mod.base.resource.MediaTypes;
import io.inverno.mod.http.base.Method;
import io.inverno.mod.http.base.UnauthorizedException;
import io.inverno.mod.http.server.ExchangeContext;
import io.inverno.mod.security.accesscontrol.AccessController;
import io.inverno.mod.security.authentication.InMemoryLoginCredentialsResolver;
import io.inverno.mod.security.authentication.LoginCredentials;
import io.inverno.mod.security.authentication.LoginCredentialsMatcher;
import io.inverno.mod.security.authentication.PrincipalAuthentication;
import io.inverno.mod.security.authentication.PrincipalAuthenticator;
import io.inverno.mod.security.authentication.password.MessageDigestPassword;
import io.inverno.mod.security.http.AccessControlInterceptor;
import io.inverno.mod.security.http.SecurityInterceptor;
import io.inverno.mod.security.http.context.InterceptingSecurityContext;
import io.inverno.mod.security.http.context.SecurityContext;
import io.inverno.mod.security.http.form.FormAuthenticationErrorInterceptor;
import io.inverno.mod.security.http.form.FormCredentialsExtractor;
import io.inverno.mod.security.http.form.FormLoginPageHandler;
import io.inverno.mod.security.http.form.RedirectLoginFailureHandler;
import io.inverno.mod.security.http.form.RedirectLoginSuccessHandler;
import io.inverno.mod.security.http.form.RedirectLogoutSuccessHandler;
import io.inverno.mod.security.http.login.LoginActionHandler;
import io.inverno.mod.security.http.login.LoginSuccessHandler;
import io.inverno.mod.security.http.login.LogoutActionHandler;
import io.inverno.mod.security.http.login.LogoutSuccessHandler;
import io.inverno.mod.security.http.token.CookieTokenCredentialsExtractor;
import io.inverno.mod.security.http.token.CookieTokenLoginSuccessHandler;
import io.inverno.mod.security.http.token.CookieTokenLogoutSuccessHandler;
import io.inverno.mod.security.identity.Identity;
import io.inverno.mod.security.jose.jwa.OCTAlgorithm;
import io.inverno.mod.security.jose.jwk.JWKService;
import io.inverno.mod.security.jose.jwk.oct.OCTJWK;
import io.inverno.mod.security.jose.jws.JWSAuthentication;
import io.inverno.mod.security.jose.jws.JWSAuthenticator;
import io.inverno.mod.security.jose.jws.JWSService;
import io.inverno.mod.web.ErrorWebRouter;
import io.inverno.mod.web.ErrorWebRouterConfigurer;
import io.inverno.mod.web.WebInterceptable;
import io.inverno.mod.web.WebInterceptorsConfigurer;
import io.inverno.mod.web.WebRoutable;
import io.inverno.mod.web.WebRoutesConfigurer;
import java.util.List;
import reactor.core.publisher.Mono;

@Bean( visibility = Bean.Visibility.PRIVATE )
public class SecurityConfigurer implements WebRoutesConfigurer&lt;SecurityContext&lt;Identity, AccessController&gt;&gt;, WebInterceptorsConfigurer&lt;InterceptingSecurityContext&lt;Identity, AccessController&gt;&gt;, ErrorWebRouterConfigurer&lt;ExchangeContext&gt; {

	private final Mono&lt;? extends OCTJWK&gt; jwsKey;
	private final JWSService jwsService;
	
	public SecurityConfigurer(JWKService jwkService, JWSService jwsService) {
		this.jwsKey = jwkService.oct().generator()
			.algorithm(OCTAlgorithm.HS256.getAlgorithm())
			.generate()
			.cache();
		this.jwsService = jwsService;
	}
	
	@Override
	public void configure(WebRoutable&lt;SecurityContext&lt;Identity, AccessController&gt;, ?&gt; routes) {
		routes
			.route()
				.method(Method.GET)
				.path("/login")
				.produces(MediaTypes.TEXT_HTML)
				.handler(new FormLoginPageHandler&lt;&gt;("/login"))
			.route()
				.method(Method.POST)
				.path("/login")
				.handler(new LoginActionHandler&lt;&gt;(
					new FormCredentialsExtractor(), 
					new PrincipalAuthenticator&lt;&gt;(
                        new InMemoryLoginCredentialsResolver(List.of(
                            LoginCredentials.of("john", new MessageDigestPassword.Encoder().encode("password")),
                            LoginCredentials.of("alice", new MessageDigestPassword.Encoder().encode("password")),
                            LoginCredentials.of("bob", new MessageDigestPassword.Encoder().encode("password"))
                        )), 
                        new LoginCredentialsMatcher&lt;LoginCredentials, LoginCredentials&gt;()
                    )
					.failOnDenied()
					.flatMap(authentication -&gt; this.jwsService.builder(PrincipalAuthentication.class, this.jwsKey)
						.header(header -&gt; header
							.algorithm(OCTAlgorithm.HS256.getAlgorithm())
						)
						.payload(authentication)
						.build(MediaTypes.APPLICATION_JSON)
						.map(JWSAuthentication::new)
					),
					LoginSuccessHandler.of(
						new CookieTokenLoginSuccessHandler&lt;&gt;("/form"),
						new RedirectLoginSuccessHandler&lt;&gt;()
					),
					new RedirectLoginFailureHandler&lt;&gt;("/login")
				))
			.route()
				.method(Method.GET)
				.path("/form/logout")
				.handler(new LogoutActionHandler&lt;&gt;(
					authentication -&gt; Mono.empty(),
					LogoutSuccessHandler.of(
						new CookieTokenLogoutSuccessHandler&lt;&gt;("/form"),
						new RedirectLogoutSuccessHandler&lt;&gt;()
					)
				));
	}

	@Override
	public void configure(WebInterceptable&lt;InterceptingSecurityContext&lt;Identity, AccessController&gt;, ?&gt; interceptors) {
		interceptors
			.intercept()
				.path("/form/**")
				.interceptors(List.of(
					SecurityInterceptor.of(
						new CookieTokenCredentialsExtractor(), 
						new JWSAuthenticator&lt;&gt;(this.jwsService, PrincipalAuthentication.class, this.jwsKey)
							.failOnDenied()
							.map(jwsAuthentication -&gt; jwsAuthentication.getJws().getPayload())
					),
					AccessControlInterceptor.authenticated()
				));
	}

	@Override
	public void configure(ErrorWebRouter&lt;ExchangeContext&gt; errorRouter) {
		errorRouter
			.intercept()
				.error(UnauthorizedException.class)
				.path("/form/**")
				.interceptor(new FormAuthenticationErrorInterceptor&lt;&gt;("/login"))
			// We must apply interceptors to intercept white labels error routes which are already defined 
			.applyInterceptors(); 
	}
}
</code></pre>
                    <p>After defining routes <code>/form/hello</code> and <code>/</code>, we can run the application and test the login flow by accessing <code>http://localhost:8080/form/hello</code> which should redirect the Web browser to the white label login page:</p> <img class="img-fluid shadow mb-4" src="doc/img/login_page.png" alt="Login page" />
                    <p>After filling valid login credentials in the login form, we should be redirected to the protected resource which is now accessible.</p> <img class="img-fluid shadow mb-4" src="doc/img/form_hello.png" alt="Form hello" />
                    <blockquote>
                        <p>We described a basic form login flow but it can be extended to match more complex or specific security requirements.</p>
                        <p>For instance, two-factors authentication could be implemented quite easily by providing a custom login form that would include a second authentication factor in addition to the login credentials and a specific login credentials authenticator that would check that factor as well, it is even possible to use the standard <code>UserAuthenticator</code> and just chain another authenticator to validate the second factor.</p>
                    </blockquote>
                    <h4 id="cross-origin-resource-sharing-cors">Cross-origin resource sharing (CORS)</h4>
                    <p>Cross-origin resource sharing is a mechanism that allows for cross-domain requests where a resource is requested in a Web browser from a page in another domain. Cross-domain requests are usually forbidden by Web browsers following the <a href="https://en.wikipedia.org/wiki/Same-origin_policy">same-origin policy</a>, CORS defines a protocol that allows the Web browser to communicate with the server and determine whether a cross-origin request can be authorized.</p>
                    <p>The <code>CORSInterceptor</code> can be used to configure the CORS policy, it can be applied to routes that might be accessed from different domain than the server or globally to apply the policy to all routes.</p>
                    <p>Assuming the HTTP server runs locally on port <code>8080</code>, the following example shows how to authorize all requests from <code>http://127.0.0.1:9090</code>:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

import io.inverno.mod.http.server.ExchangeContext;
import io.inverno.mod.security.http.cors.CORSInterceptor;
import io.inverno.mod.web.WebInterceptable;
import io.inverno.mod.web.WebInterceptorsConfigurer;

public class SecurityConfigurer implements WebInterceptorsConfigurer&lt;ExchangeContext&gt; {

    @Override
    public void configure(WebInterceptable&lt;ExchangeContext, ?&gt; interceptors) {
        interceptors
            .intercept()
                .interceptor(CORSInterceptor.builder("http://127.0.0.1:9090").build());
    }
}
</code></pre>
                    <p>The <code>CORSInterceptor</code> fully supports the CORS protocol, it allows to define allowed origins (static or using a pattern), methods, headers with max age allowing credentials or private network. Please refer to the <a href="https://fetch.spec.whatwg.org/#http-cors-protocol">HTTP CORS protocol specification</a> for further details in order to create more complex configuration</p>
                    <h4 id="cross-site-request-forgery-protection-csrf">Cross-site request forgery protection (CSRF)</h4>
                    <p>Cross-site request forgery attack consists for an attacker to make the Web browser of a victim perform unwanted action on a trusted Web site when the user is authenticated. This is made possible by the use of cookies holding authentication credentials and which are automatically included in the requests by the Web browser. As far as the server is concerned, it can not make the difference between a legitimate and a malicious request as long as it contains valid credentials.</p>
                    <p>The <code>CSRFDoubleSubmitCookieInterceptor</code> can be used to protect against CSRF attacks, it implements the double submit cookie method advised by <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html">OWASP</a>.</p>
                    <p>The following example shows how to configure the Web server in order to prevent CSRF attacks:</p>
                    <pre><code class="language-java">package io.inverno.example.app_web_security;

import io.inverno.mod.http.server.ExchangeContext;
import io.inverno.mod.security.http.csrf.CSRFDoubleSubmitCookieInterceptor;
import io.inverno.mod.web.WebInterceptable;
import io.inverno.mod.web.WebInterceptorsConfigurer;

public class SecurityConfigurer implements WebInterceptorsConfigurer&lt;ExchangeContext&gt; {

	@Override
	public void configure(WebInterceptable&lt;ExchangeContext, ?&gt; interceptors) {
		interceptors
			.intercept()
				.interceptor(CSRFDoubleSubmitCookieInterceptor.builder().httpOnly(false).build());;
	}
}
</code></pre>
                    <p>The name of the reference cookie token is set to <code>XSRF-TOKEN</code>, on a <code>POST</code>, <code>PUT</code>, <code>PATCH</code> or <code>DELETE</code> request, the interceptor tries to compare its value to a header (<code>X-CSRF-TOKEN</code> by default) or, if missing, to a query parameter (<code>_csrf_token</code> by default). If the two values are matching, which basically means the client was able to read the cookie, the request can be safely authorized otherwise a forbidden (403) error shall be return to the client.</p>
                    <blockquote>
                        <p>When using the <code>CSRFDoubleSubmitCookieInterceptor</code> with a Web application developped with <a href="https://angular.io">Angular</a> or other any other framework that support double submit cookie, the <code>httpOnly</code> flag of the reference cookie must be set to <code>false</code>.</p>
                    </blockquote>
                    <h3 id="security-ldap">Security LDAP</h3>
                    <p>The Inverno <em>security-ldap</em> module provides authenticators used to authenticate login credentials against <a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol">LDAP</a> or <a href="https://en.wikipedia.org/wiki/Active_Directory">Active Directory</a> servers.</p>
                    <p>It also provides an identity resolver for resolving user identity from the LDAP attributes of a user entry.</p>
                    <p>The LDAP client provided in module <em>ldap</em> is therefore required, in order to use the the Inverno <em>securiy-ldap</em> module we need then to declare the following dependencies in the module descriptor:</p>
                    <pre><code class="language-java">module io.inverno.example.app {
    ...
    requires io.inverno.mod.ldap;
    requires io.inverno.mod.security.ldap;
    ...
}
</code></pre>
                    <p>And also declare these dependencies in the build descriptor:</p>
                    <p>Using Maven:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-ldap&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-security-ldap&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <p>Using Gradle:</p>
                    <pre><code class="language-java">...
compile 'io.inverno.mod:inverno-security-http:1.5.2'
compile 'io.inverno.mod:inverno-security-ldap:1.5.2'
...
</code></pre>
                    <p>The following example shows how to configure a security manager to authenticate login credentials against an LDAP server, resolving the authenticated user's identity from the LDAP server and a role-based access controller from user's groups.</p>
                    <pre><code class="language-java">// Provided by the ldap module
LDAPClient ldapClient = null;
		
SecurityManager&lt;LoginCredentials, LDAPIdentity, RoleBasedAccessController&gt; securityManager = SecurityManager.of(
    new LDAPAuthenticator(ldapClient, "dc=inverno,dc=io"),
    new LDAPIdentityResolver(ldapClient),
    new GroupsRoleBasedAccessControllerResolver()
);
</code></pre>
                    <h4 id="ldap-authenticator">LDAP authenticator</h4>
                    <p>The <code>LDAPAuthenticator</code> can authenticate <code>LoginCredentials</code> (username/password) against a standard LDAP server.</p>
                    <p>When the password specified in the credentials is a <code>RawPassword</code>, authentication is made by a binding operation to the LDAP server. If the password is an encoded password, authentication is made by comparing the encoded value to the password attribute (<code>userPassword</code> by default) of the LDAP user entry.</p>
                    <p>The user <code>DN</code> is obtained using username template (defaults to <code>cn={0},ou=users</code>) formatted with the username specified in the credentials. User groups are resolved by searching for groups using a search filter set to <code>(&amp;(objectClass=groupOfNames)(member={0}))</code> by default.</p>
                    <p>An <code>LDAPAuthenticator</code> is created using an <code>LDAPClient</code> and a base <code>DN</code> which identifies the origanization where to look for entries. The following example shows how to create an <code>LDAPAuthenticator</code> to authenticate users in the <code>dc=inverno,dc=io</code> organization:</p>
                    <pre><code class="language-java">// Provided by the ldap module
LDAPClient ldapClient = ...

LDAPAuthenticator ldapAuthenticator = new LDAPAuthenticator(ldapClient, "dc=inverno,dc=io");

LDAPAuthentication authentication = ldapAuthenticator.authenticate(LoginCredentials.of("jsmith", new RawPassword("password"))).block();
</code></pre>
                    <p>The <code>LDAPAuthentication</code> returned by the <code>LDAPAuthenticator</code> is a specific principal authentication that exposes the user's DN, it also extends <code>GroupAwareAuthentication</code> since LDAP users can be a organized in groups (i.e. <code>groupOfNames</code> class). These information are resolved when authenticating credentials in the LDAP authenticator. A <code>GroupsRoleBasedAccessControllerResolver</code> can then be used in a security manager or security interceptor to resolve a role-based access contoller using users groups as roles.</p>
                    <h4 id="active-directory-authenticator">Active Directory authenticator</h4>
                    <p>The <code>ActiveDirectoryAuthenticator</code> is a similar implementation used to authenticate <code>LoginCredentials</code> against an <a href="https://en.wikipedia.org/wiki/Active_Directory">Active Directory</a> server and returning <code>LDAPAuthentication</code>.</p>
                    <p>Although Active Directory can be accessed using LDAP, the internal semantic is quite different than standard LDAP server like <a href="https://www.openldap.org">OpenLDAP</a> which is why we needed a specific implementation.</p>
                    <p>Unlike the <code>LDAPAuthenticator</code>, authentication using password comparison is not supported and therefore it can only authenticate credentials specified with raw passwords using a bind operation. User groups are resolved from the <code>memberOf</code> attribute of the user entry which is resolved using a search user filter set to <code>(&amp;(objectClass=user)(userPrincipalName={0}))</code> by default.</p>
                    <p>An <code>ActiveDirectoryAuthenticator</code> is created using an <code>LDAPClient</code> and a domain. The following example shows how to create an <code>ActiveDirectoryAuthenticator</code> to authenticate users in <code>inverno.io</code> domain:</p>
                    <pre><code class="language-java">// Provided by the ldap module
LDAPClient ldapClient = ...

ActiveDirectoryAuthenticator adAuthenticator = new ActiveDirectoryAuthenticator(ldapClient, "inverno.io");

LDAPAuthentication authentication = adAuthenticator.authenticate(LoginCredentials.of("jsmith", new RawPassword("password"))).block();
</code></pre>
                    <h4 id="ldap-identity">LDAP identity</h4>
                    <p>An LDAP server is basically a directory service which can provide any kind of information about a user such as email addresses, postal addresses, phone numbers... The <code>LDAPIdentity</code> exposes standard LDAP attributes of <code>person</code>, <code>organizationalPerson</code> and <code>inetOrgPerson</code> classes as defined by <a href="https://datatracker.ietf.org/doc/html/rfc2256">RFC 2256</a> and <a href="https://datatracker.ietf.org/doc/html/rfc2798">RFC 2798</a>.</p>
                    <p>The LDAP identity is resolved in a security manager or a security interceptor from an <code>LDAPAuthentication</code> using an <code>LDAPIdentityResolver</code> which basically look up the LDAP user entry with specific attributes in the LDAP server using the user DN and a search user filter set to <code>(&amp;(objectClass=inetOrgPerson)(uid={0}))</code> by default.</p>
                    <p>An <code>LDAPIdentityResolver</code> is created using an <code>LDAPClient</code>. The following example shows how to create a simple <code>LDAPIdentityResolver</code> for resolving common identity attributes:</p>
                    <pre><code class="language-java">// Provided by the ldap module
LDAPClient ldapClient = ...

LDAPIdentityResolver ldapIdentityResolver = new LDAPIdentityResolver();
</code></pre>
                    <p>It is possible to specify which attributes must be queried as follows:</p>
                    <pre><code class="language-java">// Provided by the ldap module
LDAPClient ldapClient = ...

LDAPIdentityResolver ldapIdentityResolver = new LDAPIdentityResolver(ldapClient, "uid", "mail", "mobile");
</code></pre>
                    <h3 id="json-object-signing-and-encryption">JSON Object Signing and Encryption</h3>
                    <p>The Inverno <em>security-jose</em> module is a complete implementation of JSON Object Signing and Encryption RFC specifications.</p>
                    <p>It allows to create, load or manipulate JSON Web Keys used to sign and verify JWS tokens or encrypt and decrypt JWE tokens. It also allows to manipulate so-called JSON Web Tokens (JWT) which are basically a set of claims wrapped inside a JWS or JWE token.</p>
                    <p>JWS and JWE tokens are using cryptographic signature and encryption algorithms which offer both payload integrity and/or privacy. The fact that they can be easily validated makes them an ideal choice for token credentials which do not necessarily require external systems for authentication.</p>
                    <p>Here is the complete list of RFCs implemented in the <em>security-jose</em> module:</p>
                    <ul>
                        <li><a href="https://datatracker.ietf.org/doc/html/rfc7515">RFC 7515</a> JSON Web Signature (JWS)</li>
                        <li><a href="https://datatracker.ietf.org/doc/html/rfc7516">RFC 7516</a> JSON Web Encryption (JWE)</li>
                        <li><a href="https://datatracker.ietf.org/doc/html/rfc7517">RFC 7517</a> JSON Web Key (JWK)</li>
                        <li><a href="https://datatracker.ietf.org/doc/html/rfc7518">RFC 7518</a> JSON Web Algorithms (JWA)</li>
                        <li><a href="https://datatracker.ietf.org/doc/html/rfc7519">RFC 7519</a> JSON Web Token (JWT)</li>
                        <li><a href="https://datatracker.ietf.org/doc/html/rfc7638">RFC 7638</a> JSON Web Key (JWK) Thumbprint</li>
                        <li><a href="https://datatracker.ietf.org/doc/html/rfc7797">RFC 7797</a> JSON Web Signature (JWS) Unencoded Payload Option</li>
                        <li><a href="https://datatracker.ietf.org/doc/html/rfc8037">RFC 8037</a> CFRG Elliptic Curve Diffie-Hellman (ECDH) and Signatures in JSON Object Signing and Encryption (JOSE)</li>
                        <li><a href="https://datatracker.ietf.org/doc/html/rfc8812">RFC 8812</a> CBOR Object Signing and Encryption (COSE) and JSON Object Signing and Encryption (JOSE) Registrations for Web Authentication (WebAuthn) Algorithms</li>
                    </ul>
                    <p>The Inverno <em>security-jose</em> module requires media type converters to be able to convert JWS and JWE payloads (e.g. object to JSON...), media type converters are usually provided in the <em>boot</em> module, as a result in order to use the module, we need to declare the following dependencies in the module descriptor:</p>
                    <pre><code class="language-java">@io.inverno.core.annotation.Module
module io.inverno.example.app {
    ...
    requires io.inverno.mod.boot;
    requires io.inverno.mod.security.jose;
    ...
}
</code></pre>
                    <p>And also declare these dependencies in the build descriptor:</p>
                    <p>Using Maven:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
    &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-boot&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-security-jose&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
                    <p>Using Gradle:</p>
                    <pre><code class="language-java">...
compile 'io.inverno.mod:inverno-security-jose:1.5.2'
...
</code></pre>
                    <p>The <em>security-jose</em> module is an Inverno module which exposes four services:</p>
                    <ul>
                        <li>the <strong>jwkService</strong> used to manage JSON Web Keys.</li>
                        <li>the <strong>jwsService</strong> used to sign and verify JSON Web signature tokens.</li>
                        <li>the <strong>jwsService</strong> used to encrypt and decrypt JSON Web signature tokens.</li>
                        <li>the <strong>jwtService</strong> used to create JSON Web tokens as JWS or JWE.</li>
                    </ul>
                    <p>It also provides JOSE object media type converters (e.g. <code>application/jose</code>, <code>application/jose+json</code>, <code>application/jwk+json</code>...) which can be used to decode (parse, verify, decrypt) JWS, JWE or JWK.</p>
                    <p>It can be easily composed in another Inverno module, as shown above, to get these services injected where they are needed but it can also be used in any other application which requires JOSE support. Media type converters might however be required to automatically convert payloads inside JWS or JWE token based on the content type, they can be provided explicitly when creating the module.</p>
                    <blockquote>
                        <p>Explicit encoders and decoders can also be used to convert payloads, it is then completely possible to run the module without specifying media type converters.</p>
                    </blockquote>
                    <p>A <code>Jose</code> module instance embeddable in any Java application and able to handle <code>application/json</code> or <code>text/plain</code> payloads can be obtained as follows:</p>
                    <pre><code class="language-java">// Exported in the 'boot' module
JsonStringMediaTypeConverter jsonConverter = new JsonStringMediaTypeConverter(new JacksonStringConverter(new ObjectMapper()));
TextStringMediaTypeConverter textConverter = new TextStringMediaTypeConverter(new StringConverter());

// Build Jose module
Jose jose = new Jose.Builder(List.of(jsonConverter, textConverter)).build();

// Initialize Jose module
jose.start();

// Create, load or store JSON Web keys
JWKService jwkService = jose.jwkService();
...

// Create, sign and verify JSON Web Signature tokens
JWSService jwsService = jose.jwsService();
...

// Create, encrypt and decrypt JSON Web encryption tokens
JWEService jweService = jose.jweService();
...

// Create JSON Web Token as JWS or JWE
JWTService jwtService = jose.jwtService();
...

// Destroy Jose module
jose.stop();
</code></pre>
                    <p>Although it is recommended to compose the <em>security-jose</em> module with the <em>boot</em> module inside an Inverno application so as not to have to deal with dependency injection or module's lifecycle, it is completely feasible to use JOSE services in any Java application as shown above, even those which do not use the Java module system.</p>
                    <p>The API is quite complete and supports advanced features such as automatic key resolution by JWK key id or X.509 thumbprints (from a Java key store or other trusted repositories), a JWK store to store frequently used keys, JWK certificate path validation, JWK Set resolution, JWE compression... Before seeing all this in details, let's quickly see how to create JSON Web Keys and use them to create and read JWS, JWE or JWT tokens.</p>
                    <p>A JSON Web Key (JWK) represents a cryptographic key used to sign/verify or encrypt/decrypt JWS or JWE tokens. The following example shows how to create a simple symmetric octet key using HS256 signature algorithm:</p>
                    <pre><code class="language-java">// Injected or obtained from a 'Jose' instance
JWKService jwkService = ...

/*
 * {
 *   "alg":"HS512",
 *   "k":"h92UNTmd5NpTl5UUalbp03z4AygiLZrDYHOaSjwjYQ_fma8_aO6A8MwOUjJGJyFEGPLJ46ujcTLlKoO_AjK3UQ",
 *   "kty":"oct",
 *   "kid":"octKey"
 * }
 */ 
Mono&lt;? extends OCTJWK&gt; octKey = jwkService.oct().generator()
    .keyId("octKey")
    .algorithm(OCTAlgorithm.HS512.getAlgorithm())
    .generate()
    .cache();
</code></pre>
                    <p>The API is fully reactive, subscribing multiple times to the <code>Mono</code> returned by the key generator would result in multiple keys being generated which is why <code>cache()</code> was used to make sure one single key is generated and returned. The key thus obtained can then be used to sign or verify JWS tokens.</p>
                    <p>A JSON Web Signature token (JWS) is composed of a header, a payload and a payload signature. The header basically specifies the information needed to verify the payload signature. A JWS token then provides integrity protection since although it is possible to read the content of the payload, it is not possible to modify it without breaking the signature.</p>
                    <p>The following example shows how to create a JWS token with a simple text payload using previous symmetric key:</p>
                    <pre><code class="language-java">// Injected or obtained from a 'Jose' instance
JWSService jwsService = ...

/* 
 * {
 *   "header":{
 *     "alg":"HS512",
 *     "cty":"text/plain",
 *     "kid":"octKey"
 *   },
 *   "payload":"This is a simple payload",
 *   "signature":"mwq--Ke2Om3zA2y1F9cQlw5SyFPzhkvwoRaaezbzqifL5joJWuJEddPbtFDKLaBUD9Ufwi6R6IFbbOe-nxkr4w"
 * }
 */
Mono&lt;JWS&lt;String&gt;&gt; jws = jwsService.builder(String.class, octKey)
    .header(header -&gt; header
        .keyId("octKey")
        .algorithm(OCTAlgorithm.HS512.getAlgorithm())
        .contentType(MediaTypes.TEXT_PLAIN)
    )
    .payload("This is a simple payload")
    .build();

// eyJjdHkiOiJ0ZXh0L3BsYWluIiwia2lkIjoib2N0S2V5IiwiYWxnIjoiSFM1MTIifQ.VGhpcyBpcyBhIHNpbXBsZSBwYXlsb2Fk.mwq--Ke2Om3zA2y1F9cQlw5SyFPzhkvwoRaaezbzqifL5joJWuJEddPbtFDKLaBUD9Ufwi6R6IFbbOe-nxkr4w
String jwsCompact = jws.block().toCompact();
</code></pre>
                    <blockquote>
                        <p>The JWS content type must be set in order to determine which media type converters to use to convert the payload. If you don't want to include the content type property (<code>cty</code>) in the resulting JWS, the content type can also be specified on the <code>build()</code> method. An explicit <code>Function&lt;T, Mono&lt;String&gt;&gt;</code> payload encoder can also be specified on the <code>build()</code> method in order to bypass media type converters.</p>
                    </blockquote>
                    <p>The compact representation of the JWS token can then be used to communicate integrity protected data to a recipient sharing the same symmetric key. A JWS token compact representation is parsed and validated as follows:</p>
                    <pre><code class="language-java">Mono&lt;JWS&lt;String&gt;&gt; jws = jwsService.reader(String.class, octKey)
    .read(compactJWS);

// Returns "This is a simple payload" or throw a JWSReadException if the token is invalid
jws.block().getPayload();
</code></pre>
                    <p>A JSON Web Encryption token (JWE) provides privacy in addition to integrity by encrypting the payload. Is is composed of a header which specifies how to decrypt and verify the cipher text, an encrypted key (used for digital signature and encryption), an initilization vector, the cipher text and an authentication tag.</p>
                    <p>The following example shows how to load an RSA key pair into a JWK, use it to create a JWE token and read its compact representation:</p>
                    <pre><code class="language-java">// Injected or obtained from a 'Jose' instance
JWEService jweService = ...

/*
 * From RFC7516 Section A.1:
 * {
 *   "n":"oahUIoWw0K0usKNuOR6H4wkf4oBUXHTxRvgb48E-BVvxkeDNjbC4he8rUWcJoZmds2h7M70imEVhRU5djINXtqllXI4DFqcI1DgjT9LewND8MW2Krf3Spsk_ZkoFnilakGygTwpZ3uesH-PFABNIUYpOiN15dsQRkgr0vEhxN92i2asbOenSZeyaxziK72UwxrrKoExv6kc5twXTq4h-QChLOln0_mtUZwfsRaMStPs6mS6XrgxnxbWhojf663tuEQueGC-FCMfra36C9knDFGzKsNa7LZK2djYgyD3JR_MB_4NUJW_TqOQtwHYbxevoJArm-L5StowjzGy-_bq6Gw",
 *   "e":"AQAB","d":"kLdtIj6GbDks_ApCSTYQtelcNttlKiOyPzMrXHeI-yk1F7-kpDxY4-WY5NWV5KntaEeXS1j82E375xxhWMHXyvjYecPT9fpwR_M9gV8n9Hrh2anTpTD93Dt62ypW3yDsJzBnTnrYu1iwWRgBKrEYY46qAZIrA2xAwnm2X7uGR1hghkqDp0Vqj3kbSCz1XyfCs6_LehBwtxHIyh8Ripy40p24moOAbgxVw3rxT_vlt3UVe4WO3JkJOzlpUf-KTVI2Ptgm-dARxTEtE-id-4OJr0h-K-VFs3VSndVTIznSxfyrj8ILL6MG_Uv8YAu7VILSB3lOW085-4qE3DzgrTjgyQ",
 *   "p":"1r52Xk46c-LsfB5P442p7atdPUrxQSy4mti_tZI3Mgf2EuFVbUoDBvaRQ-SWxkbkmoEzL7JXroSBjSrK3YIQgYdMgyAEPTPjXv_hI2_1eTSPVZfzL0lffNn03IXqWF5MDFuoUYE0hzb2vhrlN_rKrbfDIwUbTrjjgieRbwC6Cl0",
 *   "q":"wLb35x7hmQWZsWJmB_vle87ihgZ19S8lBEROLIsZG4ayZVe9Hi9gDVCOBmUDdaDYVTSNx_8Fyw1YYa9XGrGnDew00J28cRUoeBB_jKI1oma0Orv1T9aXIWxKwd4gvxFImOWr3QRL9KEBRzk2RatUBnmDZJTIAfwTs0g68UZHvtc",
 *   "dp":"ZK-YwE7diUh0qR1tR7w8WHtolDx3MZ_OTowiFvgfeQ3SiresXjm9gZ5KLhMXvo-uz-KUJWDxS5pFQ_M0evdo1dKiRTjVw_x4NyqyXPM5nULPkcpU827rnpZzAJKpdhWAgqrXGKAECQH0Xt4taznjnd_zVpAmZZq60WPMBMfKcuE",
 *   "dq":"Dq0gfgJ1DdFGXiLvQEZnuKEN0UUmsJBxkjydc3j4ZYdBiMRAy86x0vHCjywcMlYYg4yoC4YZa9hNVcsjqA3FeiL19rk8g6Qn29Tt0cj8qqyFpz9vNDBUfCAiJVeESOjJDZPYHdHY8v1b-o-Z2X5tvLx-TCekf7oxyeKDUqKWjis",
 *   "qi":"VIMpMYbPf47dT1w_zDUXfPimsSegnMOA1zTaX7aGk_8urY6R8-ZW1FxU7AlWAyLWybqq6t16VFd7hQd0y6flUK4SlOydB61gwanOsXGOAOv82cHq0E3eL4HrtZkUuKvnPrMnsUUFlfUdybVzxyjz9JF_XyaY14ardLSjf4L_FNY",
 *   "kty":"RSA",
 *   "kid":"rsaKey"
 * }
 */
Mono&lt;? extends RSAJWK&gt; rsaKey = jwkService.rsa().builder()
    .keyId("rsaKey")
    .modulus("oahUIoWw0K0usKNuOR6H4wkf4oBUXHTxRvgb48E-BVvxkeDNjbC4he8rUWcJoZmds2h7M70imEVhRU5djINXtqllXI4DFqcI1DgjT9LewND8MW2Krf3Spsk_ZkoFnilakGygTwpZ3uesH-PFABNIUYpOiN15dsQRkgr0vEhxN92i2asbOenSZeyaxziK72UwxrrKoExv6kc5twXTq4h-QChLOln0_mtUZwfsRaMStPs6mS6XrgxnxbWhojf663tuEQueGC-FCMfra36C9knDFGzKsNa7LZK2djYgyD3JR_MB_4NUJW_TqOQtwHYbxevoJArm-L5StowjzGy-_bq6Gw")
    .publicExponent("AQAB")
    .privateExponent("kLdtIj6GbDks_ApCSTYQtelcNttlKiOyPzMrXHeI-yk1F7-kpDxY4-WY5NWV5KntaEeXS1j82E375xxhWMHXyvjYecPT9fpwR_M9gV8n9Hrh2anTpTD93Dt62ypW3yDsJzBnTnrYu1iwWRgBKrEYY46qAZIrA2xAwnm2X7uGR1hghkqDp0Vqj3kbSCz1XyfCs6_LehBwtxHIyh8Ripy40p24moOAbgxVw3rxT_vlt3UVe4WO3JkJOzlpUf-KTVI2Ptgm-dARxTEtE-id-4OJr0h-K-VFs3VSndVTIznSxfyrj8ILL6MG_Uv8YAu7VILSB3lOW085-4qE3DzgrTjgyQ")
    .firstPrimeFactor("1r52Xk46c-LsfB5P442p7atdPUrxQSy4mti_tZI3Mgf2EuFVbUoDBvaRQ-SWxkbkmoEzL7JXroSBjSrK3YIQgYdMgyAEPTPjXv_hI2_1eTSPVZfzL0lffNn03IXqWF5MDFuoUYE0hzb2vhrlN_rKrbfDIwUbTrjjgieRbwC6Cl0")
    .secondPrimeFactor("wLb35x7hmQWZsWJmB_vle87ihgZ19S8lBEROLIsZG4ayZVe9Hi9gDVCOBmUDdaDYVTSNx_8Fyw1YYa9XGrGnDew00J28cRUoeBB_jKI1oma0Orv1T9aXIWxKwd4gvxFImOWr3QRL9KEBRzk2RatUBnmDZJTIAfwTs0g68UZHvtc")
    .firstFactorExponent("ZK-YwE7diUh0qR1tR7w8WHtolDx3MZ_OTowiFvgfeQ3SiresXjm9gZ5KLhMXvo-uz-KUJWDxS5pFQ_M0evdo1dKiRTjVw_x4NyqyXPM5nULPkcpU827rnpZzAJKpdhWAgqrXGKAECQH0Xt4taznjnd_zVpAmZZq60WPMBMfKcuE")
    .secondFactorExponent("Dq0gfgJ1DdFGXiLvQEZnuKEN0UUmsJBxkjydc3j4ZYdBiMRAy86x0vHCjywcMlYYg4yoC4YZa9hNVcsjqA3FeiL19rk8g6Qn29Tt0cj8qqyFpz9vNDBUfCAiJVeESOjJDZPYHdHY8v1b-o-Z2X5tvLx-TCekf7oxyeKDUqKWjis")
    .firstCoefficient("VIMpMYbPf47dT1w_zDUXfPimsSegnMOA1zTaX7aGk_8urY6R8-ZW1FxU7AlWAyLWybqq6t16VFd7hQd0y6flUK4SlOydB61gwanOsXGOAOv82cHq0E3eL4HrtZkUuKvnPrMnsUUFlfUdybVzxyjz9JF_XyaY14ardLSjf4L_FNY")
    .build()
    .cache();

/*
 * {
 *   "header":{
 *     "enc":"A256GCM",
 *     "alg":"RSA-OAEP",
 *     "cty":"text/plain",
 *     "kid":"rsaKey"
 *   },
 *   "payload":"This is a simple payload",
 *   "initializationVector":"97ZuhWEQOygN7T3g",
 *   "authenticationTag":"_e-vSUwj5LawcnXROqKvmQ",
 *   "encryptedKey":"VOk1HQDwucfkljliz8RzxvuKXX_B6sTMwZbwKJztZjL0Ga8i3yrRl_4jumBTKBIyWMDdZYxcbHtkzZQhQDFJVpvNcf1QxEryhe3OnFOEF2BGJDPwSYc-AVmAq01gHrUaTF02xvWntfvzu3ePq5vVHl4eiL72POVdoN9w8ck4HaOjeoooYcrkaV8l15cYurXsJ8oo_KQ40SBmKnK99CRrqR1QggPscTpE1QeVj2Z9tw5A3rqYGbCX2d2QwP-zc7w5o1bsuB5qE99i0iAKtMwEdaz6iC97nDry8Vo2uSPf3YviwpzmLbbwJlb_bHhl1aeTZaNQl9JLvxvqCDQehdAx7g",
 *   "cipherText":"YFPMGQXbmI5ZWZXkpH04vEWsBLCmBJ4G"
  * }
 */
Mono&lt;JWE&lt;String&gt;&gt; jwe = jweService.builder(String.class, rsaKey)
    .header(header -&gt; header
        .keyId("rsaKey")
        .algorithm("RSA-OAEP")
        .encryptionAlgorithm("A256GCM")
    )
    .payload("This is a simple payload")
    .build(MediaTypes.TEXT_PLAIN);

// eyJlbmMiOiJBMjU2R0NNIiwiYWxnIjoiUlNBLU9BRVAiLCJjdHkiOiJ0ZXh0L3BsYWluIiwia2lkIjoicnNhS2V5In0.EG3dFsn0MAxWRadls1UHpmfNFspczXldNTwr9LfO8BZXsliEJJ8J9-Z25oFnpaI7q3lXazNg06C9upJW2ZiDg2hmmqoCzYD7xdFEz_YkgO7_92tPxCm0XSGZJUtX1d8gpJBoIQWmPCmO6vVveoCds-kmtTQEigokSewKmkIQyOQcyAhLT5y_gkL0JrKLTPjTKGept7dl9uTzuZenWi-5apdVynDhOkraOkCSu8ahVPPPSf5s9aHUS8th-pjWAtS7OFwMOrjLzYXmcqdNPAYM0Pcg88Fw_uI8J7I6tzDInV31rVZ9pDlVarmVSYhS9Rfa91gZaba-onCiFURceUaeOg.im9v2BnFnFp_uGtX.VItnFUA2xtrgrO-Fs-LukV0RZbRUrNkv.eFgbb8i1olfIkSHFM8IkXA
String jweCompact = jwe.block().toCompact();
</code></pre>
                    <pre><code class="language-java">Mono&lt;JWE&lt;String&gt;&gt; jwe = jweService.reader(String.class, rsaKey)
    .read(jweCompact);

// Returns "This is a simple payload" or throw a JWEReadException if the token is invalid
jwe.block().getPayload();
</code></pre>
                    <p>In above example, the RSA public key was used to encrypt a generated symmetric key (using RSA-OAEP algorithm) which is used to encrypt the payload (using A256GCM algorithm) and the RSA private key was used to decrypt that encryption key and use it to decrypt and validate the token.</p>
                    <p>A JSON Web Token (JWT) can be a JWS or a JWE with a JWT Claims Set as payload.</p>
                    <p>The following example shows how to create and validate a JWT expiring in ten minutes from now using previous symmetric key:</p>
                    <pre><code class="language-java">// Injected or obtained from a 'Jose' instance
JWTService jwtService = ...

/*
 * {
 *   "header":{
 *     "typ":"JWT",
 *     "kid":"octKey",
 *     "alg":"HS512"
 *   },
 *   "payload":{
 *     "iss":"john",
 *     "exp":1659346862,
 *     "http://example.com/is_root":true
 *   },
 *   "signature":"hX_m668usLB1DHGW4cD2NJ1UzCs3T6sGCa0ctvGTkresiZ87iIeKnY0-EoIvWmDy3SY69rGLMsbsEjsru1QdZw"
 * }
 */
Mono&lt;JWS&lt;JWTClaimsSet&gt;&gt; jwt = jwtService.jwsBuilder(octKey)
    .header(header -&gt; header
        .keyId("octKey")
        .algorithm("HS512")
        .type("JWT")
    )
    .payload(JWTClaimsSet.of("john", ZonedDateTime.now().plusMinutes(10).toEpochSecond())
        .addCustomClaim("http://example.com/is_root", true)
        .build()
    )
    .build();

// eyJ0eXAiOiJKV1QiLCJraWQiOiJvY3RLZXkiLCJhbGciOiJIUzUxMiJ9.eyJpc3MiOiJqb2huIiwiZXhwIjoxNjU5MzQ2ODYyLCJodHRwOi8vZXhhbXBsZS5jb20vaXNfcm9vdCI6dHJ1ZX0.hX_m668usLB1DHGW4cD2NJ1UzCs3T6sGCa0ctvGTkresiZ87iIeKnY0-EoIvWmDy3SY69rGLMsbsEjsru1QdZw
String jwtCompact = jwt.block().toCompact();
</code></pre>
                    <pre><code class="language-java">Mono&lt;JWS&lt;JWTClaimsSet&gt;&gt; jwt = jwtService.jwsReader(octKey)
    .read(compactJWT);

// Throw a JWSReadException if the signature is invalid or an InvalidJWTException if the JWT Claims set is invalid (e.g. expired, inactive...) 
jwt.block().getPayload().ifInvalidThrow();
</code></pre>
                    <blockquote>
                        <p>Note that here we didn't have to specify the content type since a JWT payload is always <code>application/json</code>.</p>
                    </blockquote>
                    <h4 id="jwk-service">JWK Service</h4>
                    <p>The JWK service is used to build, generate or read JSON Web Keys (JWK) which represent cryptographic keys as specified by <a href="https://datatracker.ietf.org/doc/html/rfc7517">RFC 7517</a>. A <code>JWK</code> is meant to be used to sign or verify the signature part in a JWS, derive, encrypt/decrypt or wrap/unwrap the content encryption key in a JWE or encrypt or decrypt a JWE. It is characterized by a set of properties:</p>
                    <ul>
                        <li><code>kty</code> (key type) which identifies the cryptographic algorithm family used with the key (e.g. RSA, EC...).</li>
                        <li><code>use</code> (public use) which identifies the intended use of the public key (signature or encryption).</li>
                        <li><code>key_ops</code> (key operations) which identifies the operations for which the key is intended to be used (e.g. sign, verify, encrypt, decrypt...).</li>
                        <li><code>alg</code> (algorithm) which identifies the algorithm intended for use with the key (e.g. HS256).</li>
                        <li><code>kid</code> (key id) which identifies the key in issuer and recipient systems.</li>
                        <li><code>x5u</code> (X.509 URL) which is a URI pointing to a resource for an X.509 public key certificate or certificate chain (the public key when considering asymmetric JWK).</li>
                        <li><code>x5c</code> (X.509 certificate chain) which contains a chain of one or more PKIX certificates (the public key when considering asymmetric JWK).</li>
                        <li><code>x5t</code> an <code>x5t#S256</code> (X.509 thumbprints) which are Base64 encoded X.509 certificate thumbprint used to uniquely identifies a key (the public key when considering asymmetric JWK).</li>
                    </ul>
                    <p>Depending on the key type and more particularly the cryptographic algorithm family, additional properties may be required (e.g. the name of an elliptic curve, the modulus of an RSA public key...).</p>
                    <p>A JWK can be symmetrical or asymmetrical composed of a public and private key pair and respectively used in symmetrical (e.g. HMAC, AES...) or asymmetrical (e.g. Elliptic Curve, RSA...) cryptographic algorithms as specified by <a href="https://datatracker.ietf.org/doc/html/rfc7518">RFC 7518</a>. The specification differentiates three types of algorithms:</p>
                    <ul>
                        <li><em>Digital Signatures and MACs</em> which are used to digitally sign or create a MAC of a JWS.</li>
                        <li><em>Key Management</em> which are used to derive or encrypt/decrypt the Content Encryption Key (CEK) used to encrypt a JWE.</li>
                        <li><em>Content Encryption</em> which are used to encrypt and identity-protect a JWE using a CEK.</li>
                    </ul>
                    <p>The <code>JWK</code> interface exposes common JWK properties and provides <code>JWASigner</code>, <code>JWAKeyManager</code> or <code>JWACipher</code> instances for any of these cryptographic operations assuming they are supported by the JWK. For instance, an <code>ECJWK</code> which supports Elliptic-Curve algorithms cannot be used for content encryption but it can be used to digitally sign content and decrypt or derive keys, a <code>JWKProcessingException</code> shall be thrown when trying to obtain a signer, a key manager or a cipher when the JWK does not support it, when JWK properties are not consistent with the requested algorithm or if the requested algorithm is not of the requested type.</p>
                    <pre><code class="language-java">ECJWK ecJWK = jwkService.ec().generator()
    .curve(ECCurve.P_256.getCurve())
    .generate()
    .block();

// Throw a JWKProcessingException since Elliptic-curve algorithms cannot be used to encrypt data
ecJWK.cipher();

// Throw a JWKProcessingException since no algorithm was specified in the JWK
ecJWK.signer();

// Throw a JWKProcessingException since ES512 algorithm is not a key management algorithm
ecJWK.keyManager(ECAlgorithm.ES512.getAlgorithm());

// Throw a JWKProcessingException since ES512 algorithm is not consistent with curve P_256 (P_512 is expected)
ecJWK.signer(ECAlgorithm.ES512.getAlgorithm());

// Return a key manager using ECDH ES algorithm on curve P_256
ecJWK.keyManager(ECAlgorithm.ECDH_ES.getAlgorithm());

OCTJWK octJWK = jwkService.oct().generator()
    .algorithm(OCTAlgorithm.HS512.getAlgorithm())
    .generate()
    .block();

// Throw a JWKProcessingException since HS256 algorithm is requested which is not consistent with HS512 algorithm specified in the JWK
octJWK.signer(OCTAlgorithm.HS256.getAlgorithm());

// Return a signer using HS512 algorithm 
octJWK.signer();
</code></pre>
                    <p>A <code>SymmetricJWK</code> exposes a symmetric secret key whereas an <code>AsymmetricJWK</code> exposes a public and private key pair.</p>
                    <p>A <code>JWK</code> can be minified using method <code>minified()</code> which returns a <code>JWK</code> containing required minimal properties as specified by <a href="https://datatracker.ietf.org/doc/html/rfc7638">RFC 7638</a>. A JWK thumbprint can be created using method <code>toJWKThumbprint()</code> which allows to specify the message digest (defaults to SHA-256) to use to digest the minified <code>JWK</code>. A JWK thumbprint can be used as key id to uniquely identify a <code>JWK</code>.</p>
                    <p>A <code>JWK</code> can be converted to a public <code>JWK</code> using method <code>toPublicJWK()</code> which removes any sensitive properties: in case of a <code>SymmetricJWK</code> the secret key value is removed and in case of an <code>AsymmetricJWK</code> the private key value and any related information are removed.</p>
                    <blockquote>
                        <p>Private <code>JWK</code> containing sensitive data shall never be communicated unprotected, most of the time the public representation shall be enough for a recipient to resolve the key to use to verify or decrypt a JWS or a JWE.</p>
                    </blockquote>
                    <p>A <code>JWK</code> can be trusted or untrusted depending on how the key was resolved by the JWK service. For instance, a <code>JWK</code> built from an X.509 certificate chain (<code>x5c</code> or <code>x5u</code>) whose path could not be validated will be considered untrusted. Digital signature or content decryption will eventually fail in JWS and JWE services when using an untrusted key. It is possible to explicitly trust a key using method <code>trust()</code> when its authenticity could be determined using external means.</p>
                    <p>The <code>JWKService</code> bean uses <code>JWKFactory</code> implementations to generate, build or read JWKs, they are injected into the service when the module is initialized. Standard implementations supporting Elliptic-curve, RSA, Octet, Edward-Curve, extended Elliptic-Curve and PBES2 keys are provided and injected by default as defined by <a href="https://datatracker.ietf.org/doc/html/rfc7518">RFC 7518</a> and <a href="https://datatracker.ietf.org/doc/html/rfc8037">RFC 8037</a>. Additional <code>JWKFactory</code> implementations can be added when building the module to extend the module's capabilities and support extra signature, encryption or key management algorithms.</p>
                    <p>Standard built-in factories are directly exposed on the <code>JWKService</code> in order to quikly generate or build specific JWK:</p>
                    <pre><code class="language-java">// Return the ECJWKFactory
jwkService.ec()...
		
// Return the RSAJWKFactory
jwkService.rsa()...
		
// Return the OCTJWKFactory
jwkService.oct()...

// Return the EdECJWKFactory
jwkService.edec()...

// Return the XECJWKFactory
jwkService.xec()...

// Return the PBES2JWKFactory
jwkService.pbes2()...
</code></pre>
                    <blockquote>
                        <p>External factories cannot be exposed explicitly by the <code>JWKService</code> interface. When reading or generating a <code>JWK</code>, The JWK service basically retains all factories that supports the requested key type and algorithm, including external ones. Multiple JWKs built by different factories might then be returned by <code>read()</code> and <code>generate()</code> methods.</p>
                    </blockquote>
                    <p>The <code>JWKService</code> interface also exposes methods for reading JWK JSON representations. For instance the following example shows how to resolve and read a JWK Set JSON resource located at a specific URIs as defined by <a href="https://datatracker.ietf.org/doc/html/rfc7517">RFC 7517 Section 5</a>:</p>
                    <pre><code class="language-java">// Return one or more JWKs
Publisher&lt;? extends JWK&gt; read = jwkService.read(URI.create("https://host/jwks.json"));
</code></pre>
                    <h5 id="jwk-factory">JWK Factory</h5>
                    <p>A <code>JWKFactory</code> allows to generate a <code>JWK</code> using a <code>JWKGenerator</code>, build a <code>JWK</code> using a <code>JWKBuilder</code> and read a <code>JWK</code> from a JSON representation.</p>
                    <h6 id="generating-jwk">Generating JWK</h6>
                    <p>A <code>JWKGenerator</code> is used to generate a new <code>JWK</code>. Depending on the type (symmetric or assymeytric) this results in the creation of a secret key or a public and private key pair matching the key type and algorithm specified in the generator instance.</p>
                    <p>For instance, a symmetric octet key can be generated as follows:</p>
                    <pre><code class="language-java">JWKService jwkService = ...

OCTJWK mySymmetricKey = jwkService.oct().generator()
    .keyId("mySymmetricKey")
    .algorithm(OCTAlgorithm.HS512.getAlgorithm())
    .keySize(24)
    .generate()
    .block();
</code></pre>
                    <p>An asymmetric RSA key pair can be generated as follows:</p>
                    <pre><code class="language-java">JWKService jwkService = ...

Mono&lt;? extends RSAJWK&gt; myAsymmetricKey = jwkService.rsa().generator()
    .keyId("myAsymmetricKey")
    .algorithm(RSAAlgorithm.PS256.getAlgorithm())
    .generate()
    .cache();
</code></pre>
                    <blockquote>
                        <p>Note how <code>cache()</code> was used to transform the resulting <code>Mono</code> into a hot source and prevent generating a new key each time it is being subscribed.</p>
                    </blockquote>
                    <h6 id="building-jwk">Building JWK</h6>
                    <p>A <code>JWKBuilder</code> is used to build a <code>JWK</code> from a set of properties as defined by <a href="https://datatracker.ietf.org/doc/html/rfc7517">RFC 7517</a>. A JWK builder does not simply create a <code>JWK</code> instance filled with the provided properties, it can also directly resolve the JWK from a <code>JWKStore</code> or resolve keys (secret, public or private) using a <code>JWKKeyResolver</code> and determines whether the resulting <code>JWK</code> is consistent and can be trusted.</p>
                    <blockquote>
                        <p>The default <code>JWKKeyResolver</code> implementation uses a Java Key Store to resolve keys corresponding to the key id or X.509 thumbprints properties in that order. The Java Key Store location is specified in the module's configuration (<code>JOSEConfiguration</code>).</p>
                    </blockquote>
                    <p>In practice, a <code>JWK</code> is resolved as follows:</p>
                    <ol>
                        <li>The builder first tries to get a matching <code>JWK</code> in the module's <code>JWKStore</code> from the key id, the X.509 SHA-1 or the X.509 SHA-256 thumbprints in that order. If a matching <code>JWK</code> is found the process stops and the <code>JWK</code> returned.</li>
                        <li>If no matching <code>JWK</code> was found, it tries to resolve the secret key or the public and private key pair from the key id, X.509 SHA-1 or X.509 SHA-256 thumbprints in that order using the module's <code>JWKKeyResolver</code>.</li>
                        <li>X.509 certificates chain (<code>x5c</code>), if any, is validated using module's <code>X509JWKCertPathValidator</code> and corresponding public key value is extracted.</li>
                        <li>X.509 certificates chain URI (<code>x5u</code>), if any, is resolved using module's <code>JWKURLResolver</code> and validated using module's <code>X509JWKCertPathValidator</code> and corresponding public key value is extracted.</li>
                        <li>It then checks that all information are consistent (i.e. specified key values match the ones resolved with the <code>JWKKeyResolver</code>, and the ones extracted from X.509 certificates).</li>
                        <li>It finally returns a consistent JWK which is trusted when key values were resolved with the <code>JWKKeyResolver</code> (which is assumed to be trusted) or when the X.509 certificate path have been validated (i.e. a certificate in the chain is trusted).</li>
                    </ol>
                    <p>Any issue detected during that process results in a <code>JWKProcessingException</code>. X.509 certificates chain resolution as well as certificate path validation are disabled by default (<code>x5c</code> and <code>x5u</code> are simply ignored) and can be activated by setting properties <code>resolve_x5u</code> and <code>validate_certificate</code> to <code>true</code> in the module's configuration (<code>JOSEConfiguration</code>).</p>
                    <blockquote>
                        <p>Automatic resolution of X.509 certificates URI can be dangerous and might be considered as a threat which is why this is disable by default.</p>
                    </blockquote>
                    <p>The following example shows how to build an <code>RSAJWK</code> with a public and private key pair by specifying each properties:</p>
                    <pre><code class="language-java">RSAJWK rsaKey = jwkService.rsa().builder()
    .keyId("rsaKey")
    .modulus("oahUIoWw0K0usKNuOR6H4wkf4oBUXHTxRvgb48E-BVvxkeDNjbC4he8rUWcJoZmds2h7M70imEVhRU5djINXtqllXI4DFqcI1DgjT9LewND8MW2Krf3Spsk_ZkoFnilakGygTwpZ3uesH-PFABNIUYpOiN15dsQRkgr0vEhxN92i2asbOenSZeyaxziK72UwxrrKoExv6kc5twXTq4h-QChLOln0_mtUZwfsRaMStPs6mS6XrgxnxbWhojf663tuEQueGC-FCMfra36C9knDFGzKsNa7LZK2djYgyD3JR_MB_4NUJW_TqOQtwHYbxevoJArm-L5StowjzGy-_bq6Gw")
    .publicExponent("AQAB")
    .privateExponent("kLdtIj6GbDks_ApCSTYQtelcNttlKiOyPzMrXHeI-yk1F7-kpDxY4-WY5NWV5KntaEeXS1j82E375xxhWMHXyvjYecPT9fpwR_M9gV8n9Hrh2anTpTD93Dt62ypW3yDsJzBnTnrYu1iwWRgBKrEYY46qAZIrA2xAwnm2X7uGR1hghkqDp0Vqj3kbSCz1XyfCs6_LehBwtxHIyh8Ripy40p24moOAbgxVw3rxT_vlt3UVe4WO3JkJOzlpUf-KTVI2Ptgm-dARxTEtE-id-4OJr0h-K-VFs3VSndVTIznSxfyrj8ILL6MG_Uv8YAu7VILSB3lOW085-4qE3DzgrTjgyQ")
    .firstPrimeFactor("1r52Xk46c-LsfB5P442p7atdPUrxQSy4mti_tZI3Mgf2EuFVbUoDBvaRQ-SWxkbkmoEzL7JXroSBjSrK3YIQgYdMgyAEPTPjXv_hI2_1eTSPVZfzL0lffNn03IXqWF5MDFuoUYE0hzb2vhrlN_rKrbfDIwUbTrjjgieRbwC6Cl0")
    .secondPrimeFactor("wLb35x7hmQWZsWJmB_vle87ihgZ19S8lBEROLIsZG4ayZVe9Hi9gDVCOBmUDdaDYVTSNx_8Fyw1YYa9XGrGnDew00J28cRUoeBB_jKI1oma0Orv1T9aXIWxKwd4gvxFImOWr3QRL9KEBRzk2RatUBnmDZJTIAfwTs0g68UZHvtc")
    .firstFactorExponent("ZK-YwE7diUh0qR1tR7w8WHtolDx3MZ_OTowiFvgfeQ3SiresXjm9gZ5KLhMXvo-uz-KUJWDxS5pFQ_M0evdo1dKiRTjVw_x4NyqyXPM5nULPkcpU827rnpZzAJKpdhWAgqrXGKAECQH0Xt4taznjnd_zVpAmZZq60WPMBMfKcuE")
    .secondFactorExponent("Dq0gfgJ1DdFGXiLvQEZnuKEN0UUmsJBxkjydc3j4ZYdBiMRAy86x0vHCjywcMlYYg4yoC4YZa9hNVcsjqA3FeiL19rk8g6Qn29Tt0cj8qqyFpz9vNDBUfCAiJVeESOjJDZPYHdHY8v1b-o-Z2X5tvLx-TCekf7oxyeKDUqKWjis")
    .firstCoefficient("VIMpMYbPf47dT1w_zDUXfPimsSegnMOA1zTaX7aGk_8urY6R8-ZW1FxU7AlWAyLWybqq6t16VFd7hQd0y6flUK4SlOydB61gwanOsXGOAOv82cHq0E3eL4HrtZkUuKvnPrMnsUUFlfUdybVzxyjz9JF_XyaY14ardLSjf4L_FNY")
    .build()
    .block();
</code></pre>
                    <p>If we assumed that <code>rsaKey</code> is not stored in the module's <code>JWKStore</code> and that public and private keys are also not stored in the module's Java Key Store, the resulting <code>RSAKey</code> is therefore untrusted since the provided information could not be authenticated.</p>
                    <p>An untrusted <code>JWK</code> cannot be used to digitally sign, encrypt or derive keys. If we know by external means that the provided information can be trusted after all, we can explicitly trust the <code>JWK</code> as follows:</p>
                    <pre><code class="language-java">rsaKey.trust();

// The JWK is now trusted
...
</code></pre>
                    <blockquote>
                        <p>Note that this can be considered unsafe and should be used with extra care.</p>
                    </blockquote>
                    <p>Now if we assume that <code>rsaKey</code> is stored in the module's <code>JWKStore</code>, the key can be built, or in that case simply loaded, as follows:</p>
                    <pre><code class="language-java">RSAJWK rsaKey = jwkService.rsa().builder()
    .keyId("rsaKey")
    .build()
    .block();
</code></pre>
                    <p>In that case, the returned <code>JWK</code> is trusted as it comes from a trusted <code>JWKStore</code>.</p>
                    <p>Finally, if the <code>rsaKey</code> is not stored in the module's <code>JWKStore</code>, but a public and private key pair is stored in the module's Java Key Store, the <code>JWK</code> can be loaded in the exact same way:</p>
                    <pre><code class="language-java">RSAJWK rsaKey = jwkService.rsa().builder()
    .keyId("rsaKey")
    .build()
    .block();
</code></pre>
                    <p>There is however a noticeable difference between the two, when a <code>JWK</code> is resolved from the module's <code>JWKStore</code>, properties specified in the builder other than the key id or X.509 thumbprints are simply ignored and no further consistency check is performed. On the other hand, when keys are resolved using the module's <code>JWKKeyResolver</code>, the properties specified in the builder must be consistent. The purpose of the <code>JWKStore</code> is to optimize the resolution of frequently used keys which is incompatible with systematic consistency check.</p>
                    <p>Please refer to <a href="#jwk-store">JWK Store</a> and <a href="#jwk-key-resolution">JWK Key Resolution</a> to better understand how JWK and key resolution work.</p>
                    <h6 id="reading-jwk">Reading JWK</h6>
                    <p>A <code>JWK</code> is read from a JSON representation in a similar way as the one described for the JWK builder. The JSON object is basically parsed in a map of properties which are then injected in a <code>JWKBuilder</code> which is used to build the resulting <code>JWK</code>.</p>
                    <p>The following example shows how to parse the JSON representation of the <code>RSAJWK</code> built in previous section:</p>
                    <pre><code class="language-java">String rsaJwkJSON = "{\n"
    + "   \"n\":\"oahUIoWw0K0usKNuOR6H4wkf4oBUXHTxRvgb48E-BVvxkeDNjbC4he8rUWcJoZmds2h7M70imEVhRU5djINXtqllXI4DFqcI1DgjT9LewND8MW2Krf3Spsk_ZkoFnilakGygTwpZ3uesH-PFABNIUYpOiN15dsQRkgr0vEhxN92i2asbOenSZeyaxziK72UwxrrKoExv6kc5twXTq4h-QChLOln0_mtUZwfsRaMStPs6mS6XrgxnxbWhojf663tuEQueGC-FCMfra36C9knDFGzKsNa7LZK2djYgyD3JR_MB_4NUJW_TqOQtwHYbxevoJArm-L5StowjzGy-_bq6Gw\",\n"
    + "   \"e\":\"AQAB\",\"d\":\"kLdtIj6GbDks_ApCSTYQtelcNttlKiOyPzMrXHeI-yk1F7-kpDxY4-WY5NWV5KntaEeXS1j82E375xxhWMHXyvjYecPT9fpwR_M9gV8n9Hrh2anTpTD93Dt62ypW3yDsJzBnTnrYu1iwWRgBKrEYY46qAZIrA2xAwnm2X7uGR1hghkqDp0Vqj3kbSCz1XyfCs6_LehBwtxHIyh8Ripy40p24moOAbgxVw3rxT_vlt3UVe4WO3JkJOzlpUf-KTVI2Ptgm-dARxTEtE-id-4OJr0h-K-VFs3VSndVTIznSxfyrj8ILL6MG_Uv8YAu7VILSB3lOW085-4qE3DzgrTjgyQ\",\n"
    + "   \"p\":\"1r52Xk46c-LsfB5P442p7atdPUrxQSy4mti_tZI3Mgf2EuFVbUoDBvaRQ-SWxkbkmoEzL7JXroSBjSrK3YIQgYdMgyAEPTPjXv_hI2_1eTSPVZfzL0lffNn03IXqWF5MDFuoUYE0hzb2vhrlN_rKrbfDIwUbTrjjgieRbwC6Cl0\",\n"
    + "   \"q\":\"wLb35x7hmQWZsWJmB_vle87ihgZ19S8lBEROLIsZG4ayZVe9Hi9gDVCOBmUDdaDYVTSNx_8Fyw1YYa9XGrGnDew00J28cRUoeBB_jKI1oma0Orv1T9aXIWxKwd4gvxFImOWr3QRL9KEBRzk2RatUBnmDZJTIAfwTs0g68UZHvtc\",\n"
    + "   \"dp\":\"ZK-YwE7diUh0qR1tR7w8WHtolDx3MZ_OTowiFvgfeQ3SiresXjm9gZ5KLhMXvo-uz-KUJWDxS5pFQ_M0evdo1dKiRTjVw_x4NyqyXPM5nULPkcpU827rnpZzAJKpdhWAgqrXGKAECQH0Xt4taznjnd_zVpAmZZq60WPMBMfKcuE\",\n"
    + "   \"dq\":\"Dq0gfgJ1DdFGXiLvQEZnuKEN0UUmsJBxkjydc3j4ZYdBiMRAy86x0vHCjywcMlYYg4yoC4YZa9hNVcsjqA3FeiL19rk8g6Qn29Tt0cj8qqyFpz9vNDBUfCAiJVeESOjJDZPYHdHY8v1b-o-Z2X5tvLx-TCekf7oxyeKDUqKWjis\",\n"
    + "   \"qi\":\"VIMpMYbPf47dT1w_zDUXfPimsSegnMOA1zTaX7aGk_8urY6R8-ZW1FxU7AlWAyLWybqq6t16VFd7hQd0y6flUK4SlOydB61gwanOsXGOAOv82cHq0E3eL4HrtZkUuKvnPrMnsUUFlfUdybVzxyjz9JF_XyaY14ardLSjf4L_FNY\",\n"
    + "   \"kty\":\"RSA\",\n"
    + "   \"kid\":\"rsaKey\"\n"
    + "}";

RSAJWK rsaKey = jwkService.rsa().read(rsaJwkJSON).block();
</code></pre>
                    <p>The same rules as the ones described for the JWK builder apply. In above code the resulting <code>JWK</code> is untrusted. Assuming a <code>rsaKey</code> JWK is stored in the module's <code>JWKStore</code>, the following code shall return a workable <code>JWK</code>:</p>
                    <pre><code class="language-java">String rsaJwkJSON = "{\n"
    + "   \"kid\":\"rsaKey\"\n"
    + "}";

RSAJWK rsaKey = jwkService.rsa().read(rsaJwkJSON).block();
</code></pre>
                    <blockquote>
                        <p>Note that we did not have to specify the key type here since we are directly using the <code>RSAJWKFactory</code> to read the JSON representation. We could have invoked the <code>read()</code> method on the <code>JWKService</code> instead but the key type would then have been required in order to determine which JWK factory to use.</p>
                    </blockquote>
                    <h5 id="jwk-store">JWK Store</h5>
                    <p>The <em>security-jose</em> module uses a <code>JWKStore</code> to store and load frequently used keys. By default the module uses a no-op implementation but more effective implementations can be injected when creating the module.</p>
                    <p>The purpose of the <code>JWKStore</code> is optimize key resolution when loading keys while creating or reading JWS or JWE. As soon as a key is matched by a key id, an X.509 SHA-1 or X.509 SHA-256 thumbprint, the key shall be returned and no further processing performed, including consistency checks.</p>
                    <blockquote>
                        <p>Note that this actually goes a bit against <a href="https://datatracker.ietf.org/doc/html/rfc7517">RFC 7517</a> for which inconsistent JWK must be rejected but this is a fair optimization as the returned <code>JWK</code> shall always be consistent.</p>
                    </blockquote>
                    <p>The <code>JWKStore</code> interface exposes methods <code>getByKeyId()</code>, <code>getBy509CertificateSHA1Thumbprint()</code> and <code>getByX509CertificateSHA256Thumbprint()</code> which are respectively used by <code>JWKBuilder</code> implementation to resolve <code>JWK</code> by key id, X.509 SHA-1 and X.509 SHA-256 thumbprints. The <code>set()</code> and <code>remove()</code> methods are used to add or remove <code>JWK</code> instances.</p>
                    <p>The <code>InMemoryJWKStore</code> is a simple implementation that stores keys in concurrent hash maps, the following wrapper bean can be defined in a module to override the default no-op implementation:</p>
                    <pre><code class="language-java">@Wrapper
@Bean
public class JWKStoreWrapper implements Supplier&lt;JWKStore&gt; {

    @Override
    public JWKStore get() {
        return new InMemoryJWKStore();
    }
}
</code></pre>
                    <p>Or it can be injected directly in the module's builder if the module is created and initilized explicitly:</p>
                    <pre><code class="language-java">Jose jose = new Jose.Builder(List.of(jsonConverter, textConverter)).setJwkStore(new InMemoryJWKStore()).build();

jose.start();
...
jose.stop();
</code></pre>
                    <p>The <code>JWKStore</code> is exposed in the <code>JWKService</code>, a <code>JWK</code> can be stored as follows:</p>
                    <pre><code class="language-java">jwkService.oct().generator()
    .keyId("octKey")
    .algorithm(OCTAlgorithm.HS512.getAlgorithm())
    .generate()
    .map(JWK::trust)
    .flatMap(jwkService.store()::set)
    .block();
</code></pre>
                    <p>Since keys resolved from the <code>JWKStore</code> are usually used when validating or decrypting JWS or JWE, they should all be trusted to avoid errors.</p>
                    <blockquote>
                        <p>The <code>InMemoryJWKStore</code> is a basic implementation that does not check this condition before storing an instance but more advanced implementations should definitely consider rejecting untrusted keys. Whatever the solution, processing will eventually fail when using an untrusted key.</p>
                    </blockquote>
                    <h5 id="jwk-key-resolution">JWK Key resolution</h5>
                    <p>When building or reading a <code>JWK</code>, actual keys (secret, public and private) can be resolved by key id, X.509 SHA-1 or X.509 SHA-256 thumbprints in a <code>JWKBuilder</code> implementation using the module's <code>JWKKeyResolver</code>.</p>
                    <p>The module provides a default implementation that look up keys in a Java Key Store whose location is specified in the module's configuration. Key resolution will be disabled if the key store configuration is missing.</p>
                    <p>Let's assume we have a Java Key Store <code>keystore.jks</code> accessible with password <code>password</code>, the following configuration allows the default <code>JWKKeyResolver</code> implementation to resolve keys from that key store:</p>
                    <pre><code class="language-plaintext">### configuration.cprops
io.inverno.example.app_jose.appConfiguration {
    jose {
        key_store = "file:/path/to/keytstore.jks"
        key_store_password = "password"
    }
}
</code></pre>
                    <p>Unlike the <code>JWKStore</code>, a <code>JWKProcessingException</code> is thrown when resolved keys are not consistent with the properties specified in the JWK builder.</p>
                    <p>Custom <code>JWKKeyResolver</code> implementation can be provided to override the default behaviour by defining a bean in the module or by directly injecting the instance in the module's builder when the module is created and intilialized explicitly:</p>
                    <pre><code class="language-java">Jose jose = new Jose.Builder(List.of(jsonConverter, textConverter)).setJwkKeyResolver(new CustomJWKKeyResolver()).build();
</code></pre>
                    <h5 id="jwk-set-resolution">JWK Set resolution</h5>
                    <p>The <code>JWKService</code> can be used to resolve multiple keys from a URI pointing to a JWK Set resource as defined by <a href="https://datatracker.ietf.org/doc/html/rfc7517">RFC 7517 Section 5</a>.</p>
                    <p>For instance, the keys defined in a JWK Set at location <code>https://server.example.com/keys.jwks</code> can be resolved as follows:</p>
                    <pre><code class="language-java">Publisher&lt;? extends JWK&gt; read = jwkService.read(URI.create("https://server.example.com/keys.jwks"));
</code></pre>
                    <p>The <code>JWKService</code> delegates to the module's <code>JWKURLResolver</code> to resolve the resource as a map of properties, the default implementation uses a <code>ResourceService</code> which must be injected into the module for the feature to be activated.</p>
                    <blockquote>
                        <p>A complete <code>ResourceService</code> implementation supporting common URI schemes (<code>file:/</code>, <code>http://</code>, <code>classpath:</code>...) is provided in the <em>boot</em> module.</p>
                    </blockquote>
                    <p>JWK set resolution is also used as a last resort to resolve keys when building or reading JWS or JWE with property <code>jku</code>, this behaviour is disabled by default and must be activated explicitly in the module's configuration (<code>JOSEConfiguration</code>) by setting <code>resolve_jku</code> property to <code>true</code>:</p>
                    <pre><code>### configuration.cprops
io.inverno.example.app_jose.appConfiguration {
    jose {
        resolve_jku = true
    }
}
</code></pre>
                    <blockquote>
                        <p>Automatic resolution of JWK Set URL can be dangerous and might be considered as a threat which is why this is disable by default.</p>
                    </blockquote>
                    <p><code>JWK</code> instances obtained that way from external JWK Set resources are considered untrusted by default, and therefore cannot be used to build or read JWS or JWE, unless locations (i.e. URIs) are explicitly as a trusted listed in the module's configuration (<code>JOSEConfiguration</code>) in <code>trusted_jku</code> property.</p>
                    <p>For instance, the following configuration can be set to trust keys resolved from <code>https://server.example.com/keys.jwks</code>:</p>
                    <pre><code>### configuration.cprops
io.inverno.example.app_jose.appConfiguration {
    jose {
        trusted_jku = "https://server.example.com/keys.jwks"
    }
}
</code></pre>
                    <h5 id="certificate-path-validation">Certificate path validation</h5>
                    <p>When building or reading a <code>JWK</code> with an X.509 certificates chain or X.509 certificates chain URI, it is possible to validate the certificates chain in order to determine whether the resulting <code>JWK</code> can be trusted.</p>
                    <p>An X.509 certificate is considered trusted if any of the certificate in the chain is trusted. An <code>X509JWKCertPathValidator</code> is used in <code>JWKBuilder</code> implementations to validate resolved certificates chains.</p>
                    <p>The default implementation uses a PKIX <code>CertPathValidator</code> with <code>PKIXParameters</code> defining the trusted certificates, these parameters are provided by the <code>JWKPKIXParameters</code> wrapper bean which uses the trust store of the JDK by default. This bean is overridable and custom <code>PKIXParameters</code> can be provided as well by defining a bean in the module or by directly injecting the instance in the module's builder when the module is created and intilialized explicitly:</p>
                    <pre><code class="language-java">CertStore customTrustStore = ...

Jose jose = new Jose.Builder(List.of(jsonConverter, textConverter)).setJwkPKIXParameters(new JWKPKIXParameters(customTrustStore).get()).build();
</code></pre>
                    <p>Certificate path resolution is disabled by default and must be activated explicitly in the module's configuration (<code>JOSEConfiguration</code>) by setting <code>validate_certificate</code> property to <code>true</code>:</p>
                    <pre><code>### configuration.cprops
io.inverno.example.app_jose.appConfiguration {
    jose {
        validate_certificate = true
    }
}
</code></pre>
                    <h5 id="json-web-algorithms">JSON Web Algorithms</h5>
                    <p>The <em>security-jose</em> module fully supports algorithms specified in <a href="https://datatracker.ietf.org/doc/html/rfc7518">RFC 7518 JSON Web Algorithm (JWA)</a>, <a href="https://datatracker.ietf.org/doc/html/rfc8037">RFC 8037</a> and <a href="https://datatracker.ietf.org/doc/html/rfc8812">RFC 8812</a> and used to sign/verify, encrypt/decrypt and derive content encryption keys. They are grouped into categories with associated <code>JWK</code> implementations and <code>JWAAlgorithm</code> enum listing the algorithms and defining the parameters required to create corresponding <code>JWASigner</code>, <code>JWACipher</code> and <code>JWAKeyManager</code>.</p>
                    <p>The <code>JWA</code> interface is the base type extended by all JWA algorithms including <code>JWASigner</code> for digital signature algorithms, <code>JWACipher</code> for encryption algorithms and <code>JWAKeyManager</code> for key management algorithms.</p>
                    <p>The <code>JWASigner</code> interface exposes methods <code>sign()</code> and <code>verify()</code> used to respectively sign and verify some arbitrary data.</p>
                    <pre><code class="language-java">byte[] payload = "This is a payload".getBytes();

JWASigner signer = ...

byte[] signature = signer.sign(payload);

if(signer.verify(payload, signature)) {
    ...
}
</code></pre>
                    <p>The <code>JWACipher</code> interface exposes methods <code>encrypt()</code> and <code>decrypt()</code> to respectively encrypt and decrypt some arbitrary data. Encryption requires additional authentication data and a <code>SecureRandom</code> for random number generation and returns encrypted data composed of a cipher text, an initialization vector and an authentication tag. Decryption requires the additional authentication data, the cipher text, the initialization vector and the authentication tag (which are basically the components of a JWE).</p>
                    <pre><code class="language-java">byte[] payload = "This is a payload".getBytes();
// Specified in RFC 7516
byte[] aad = ...

JWACipher cipher = ...

JWACipher.EncryptedData encryptedData = cipher.encrypt(payload, aad);

byte[] decryptedPayload = cipher.decrypt(encryptedData.getCipherText(), aad, encryptedData.getInitializationVector(), encryptedData.getAuthenticationTag());
</code></pre>
                    <p>Key management algorithms are used to determine the Content Encryption Key (CEK) used to encrypt a JWE, they are further divided into <code>DirectJWAKeyManager</code> for algorithms that derives the content encryption key which is not encrypted, <code>EncryptingJWAKeyManager</code> for algorithms that encrypt/decrypt the content encryption key and <code>WrappingJWAKeyManager</code> for algorithms that wrap/unwrap the content encryption key.</p>
                    <p>Key management algorithm usually requires specific parameters passed in the JOSE header, as a result methods exposed by key managers usually require the algorithm and a map of parameters.</p>
                    <p>A <code>DirectJWAKeyManager</code> is used to derive the CEK on both ends using parameters specified in a JOSE header.</p>
                    <pre><code class="language-java">// e.g. Ephemeral public key (epk), Agreement PartyUInfo (apu), Agreement PartyVInfo (apv) when using ECDH-ES algorithm
Map&lt;String, Object&gt; parameters = ...

DirectJWAKeyManager directKeyManager = ...

DirectJWAKeyManager.DirectCEK directCEK = directKeyManager.deriveCEK("ECDH-ES", parameters);
OCTJWK cek = directCEK.getEncryptionKey();
</code></pre>
                    <blockquote>
                        <p>When using a direct key management algorithm, the encrypted key part of the JWE is empty since the CEK is derived and not encrypted or wrapped.</p>
                    </blockquote>
                    <p>An <code>EncryptingJWAKeyManager</code> is used to encrypt and decrypt the CEK.</p>
                    <pre><code class="language-java">// e.g. PBES2 Salt Input (p2s), PBES2 Count (p2c) when using PBES2-HS256+A128KW algorithm
Map&lt;String, Object&gt; parameters = ...
// Generated when building a JWE
JWK cek = ...

EncryptingJWAKeyManager encryptingKeyManager = ...

EncryptingJWAKeyManager.EncryptedCEK encryptedCEK = encryptingKeyManager.encryptCEK(cek, parameters);
byte[] encryptedKey = encryptedCEK.getEncryptedKey();

JWK decryptedCEK = encryptingKeyManager.decryptCEK(encryptedKey, "PBES2-HS256+A128KW", parameters);
</code></pre>
                    <p>A <code>WrappingJWAKeyManager</code> is used to wrap and unwrap the CEK.</p>
                    <pre><code class="language-java">Map&lt;String, Object&gt; parameters = ...
// Generated when building a JWE
JWK cek = ...

WrappingJWAKeyManager wrappingKeyManager = ...

WrappingJWAKeyManager.WrappedCEK wrappedCEK = wrappingKeyManager.wrapCEK(cek, parameters);
byte[] wrappedKey = wrappedCEK.getWrappedKey();

JWK unwrappedCEK = wrappingKeyManager.unwrapCEK(wrappedKey, "A192KW", parameters);
</code></pre>
                    <blockquote>
                        <p>Although signers, ciphers and key managers are usually used indirectly when building or reading JWS or JWE but they can also be used directly as shown above.</p>
                    </blockquote>
                    <h6 id="octet">Octet</h6>
                    <p>Octet algorithms are based on a shared secret key, they are listed in the <code>OCTAlgorithm</code> enum.</p>
                    <p>The following example shows how to obtain an A128GCM <code>JWACipher</code> from a generated <code>OCTJWK</code>:</p>
                    <pre><code class="language-java">JWACipher cipher = jwkService.oct().generator()
    .algorithm(OCTAlgorithm.A128GCM.getAlgorithm())
    .generate()
    .block()
    .cipher();
</code></pre>
                    <h6 id="elliptic-curve">Elliptic Curve</h6>
                    <p>Elliptic-curve algorithms are based on a public and private key pair and using a specific Elliptic curve (P-256, P-384, P-521 defined in <code>ECCurve</code> enum), they are listed in the <code>ECAlgorithm</code> enum.</p>
                    <p>Elliptic-curve cryptography has the advantage of producing smaller signatures than RSA for the same level of protection.</p>
                    <p>The following example shows how to obtain an ES384 <code>JWASigner</code> from a generated <code>ECJWK</code> using default P-256 curve:</p>
                    <pre><code class="language-java">JWAsigner signer = jwkService.ec().generator()
    .algorithm(ECAlgorithm.ES384.getAlgorithm())
    .generate()
    .block()
    .signer();
</code></pre>
                    <h6 id="rsa">RSA</h6>
                    <p>RSA algorithms are based on a public and private key pair, they are listed in the <code>RSAAlgorithm</code> enum.</p>
                    <p>The following example shows how to obtain an RSA_OAEP <code>JWAKeyManager</code> (<code>EncryptingJWAKeyManager</code>) from a generated <code>RSAWK</code>:</p>
                    <pre><code class="language-java">JWAKeyManager keyManager = jwkService.rsa().generator()
    .algorithm(RSAAlgorithm.RSA_OAEP.getAlgorithm())
    .generate()
    .block()
    .keyManager();
</code></pre>
                    <h6 id="pbes2">PBES2</h6>
                    <p>PBES2 algorithms are based on a shared secret key, namely a password, they are listed in the <code>PBES2Algorithm</code> enum.</p>
                    <p>They are usually used for the password-based encryption of the CEK in a JWE.</p>
                    <p>The following example shows how to obtain a PBES2-HS256+A128KW <code>JWAKeyManager</code> (<code>EncryptingJWAKeyManager</code>) from a generated <code>PBES2JWK</code>:</p>
                    <pre><code class="language-java">JWAKeyManager keyManager = jwkService.pbes2().generator()
    .algorithm(PBES2Algorithm.PBES2_HS256_A128KW.getAlgorithm())
    .length(32) // generate a 32 characters long password
    .generate()
    .block()
    .keyManager();
</code></pre>
                    <h6 id="edward-curve">Edward-Curve</h6>
                    <p>Edward-curve algorithms are based on a public and private key pair and using a specific Edward-curve (Ed25519, Ed448, X25519, X448 defined in <code>OKPCurve</code>), they are listed in the <code>EdECalgorithm</code> enum.</p>
                    <p>The following example shows how to obtain an Ed25519 <code>JWASigner</code> from a generated <code>EdECJWK</code>:</p>
                    <pre><code class="language-java">JWAsigner signer = jwkService.edec().generator()
    .algorithm(EdECAlgorithm.EDDSA_ED25519.getAlgorithm())
    .generate()
    .block()
    .signer();
</code></pre>
                    <h6 id="extended-elliptic-curve">Extended Elliptic Curve</h6>
                    <p>Extended elliptic-curve algorithms are based on a public and private key pair, they are listed in the <code>XECAlgorithm</code> enum.</p>
                    <p>These algorithms basically combine ECDH_ES algorithms with elliptic-curve algorithms to wrap the CEK in a JWE.</p>
                    <p>The following example shows how to obtain an ECDH-ES+A128KW <code>JWAKeyManager</code> (<code>WrappingJWAKeyManager</code>) from a generated <code>XECJWK</code>:</p>
                    <p>̀<code>java jwkService.xec().generator() .algorithm(XECAlgorithm.ECDH_ES_A128KW.getAlgorithm()) .curve(OKPCurve.X25519.getCurve()) .generate() .block() .keyManager(); ̀</code></p>
                    <h4 id="jws-service">JWS Service</h4>
                    <p>The JWS service is used to build or read JWS represented using the compact or the JSON notation as defined by <a href="https://datatracker.ietf.org/doc/html/rfc7515">RFC 7515</a>.</p>
                    <p>The <code>JWSService</code> bean is used to create <code>JWSBuilder</code> or <code>JsonJWSBuilder</code> instances to build JWS using the compact or the JSON notation and <code>JWSReader</code> or <code>JsonJWSReader</code> instances to read JWS serialized using the compact or JSON notation.</p>
                    <p>A JWS allows to communicate integrity protected content using digital signatures or message authentication codes (MACs). It is composed of three parts:</p>
                    <ul>
                        <li>a JOSE header which specifies how to understand (i.e. type, content type...), sign or verify the JWS.</li>
                        <li>a payload which is digitally signed in the JWS.</li>
                        <li>a signature which is essentially the digital signature of the concatenation of the header and the payload.</li>
                    </ul>
                    <p>A <code>JWS</code> is obtained from a <code>JWSBuilder</code> or a <code>JWSReader</code>, the <code>JWS</code> interface exposes the header, the payload and the signature. It can be serialized using the compact notation as follows:</p>
                    <pre><code class="language-java">JWS&lt;?&gt; jws = ...

// &lt;header&gt;.&lt;payload&gt;.&lt;signature&gt; 
// e.g. eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
String jwsCompact = jws.toCompact();
</code></pre>
                    <p>A <code>JsonJWS</code> is obtained from a <code>JsonJWSBuilder</code> or a <code>JsonJWSReader</code>, the <code>JsonJWS</code> interface exposes the payload and the list of signatures. It can be serialized using the JSON notation as follows:</p>
                    <pre><code class="language-java">JsonJWS&lt;?, ?&gt; jsonJWS = ...

/* 
 * RFC 7515 Appendix A.6
 * 
 * {
 *   "payload": "eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ",
 *   "signatures": [
 *     {
 *       "protected":"eyJhbGciOiJSUzI1NiJ9",
 *       "header": {
 *         "kid":"2010-12-29"
 *       },
 *       "signature": "cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZ
 *                     mh7AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjb
 *                     KBYNX4BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHl
 *                     b1L07Qe7K0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZES
 *                     c6BfI7noOPqvhJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AX
 *                     LIhWkWywlVmtVrBp0igcN_IoypGlUPQGe77Rw"
 *     },
 *     {
 *       "protected":"eyJhbGciOiJFUzI1NiJ9",
 *       "header": {
 *         "kid":"e9bc097a-ce51-4036-9562-d2ade882db0d"
 *       },
 *       "signature": "DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8IS
 *                     lSApmWQxfKTUJqPP3-Kg6NU1Q"
 *     }
 *   ]
 * }
 */
String jwsJson = jsonJWS.toJson();
</code></pre>
                    <p>The detached compact representation as specified by <a href="https://datatracker.ietf.org/doc/html/rfc7797">RFC 7797</a> is also supported and can be used when large payloads communicated by external means are considered.</p>
                    <pre><code class="language-java">JWS&lt;?&gt; jws = ...

// &lt;header&gt;..&lt;signature&gt; 
// e.g. eyJhbGciOiJFUzUxMiJ9..AdwMgeerwtHoh-l192l60hp9wAHZFVJbLfD_UxMi70cwnZOYaRI1bKPWROc-mZZqwqT2SI-KGDKB34XO0aw_7XdtAG8GaSwFKdCAPZgoXD2YBJZCPEX3xKpRwcdOO8KpEHwJjyqOgzDO7iKvU8vcnwNrmxYbSW9ERBXukOXolLzeO_Jn
String jwsDetachedCompact = jws.toDetachedCompact();
</code></pre>
                    <blockquote>
                        <p>The most common representation is by far the compact representation which can be safely used in URLs. On the other hand, the JSON notation can be used to target multiple systems with various JWKs.</p>
                    </blockquote>
                    <p>A JWS offers integrity protection of its content using a digital signature, as a result, building or reading a JWS requires a <code>JWK</code> supporting digital signature algorithms.</p>
                    <h5 id="building-jws">Building JWS</h5>
                    <p>A <code>JWSBuilder</code> is used to create <code>JWS</code>, it is obtained by invoking one of the <code>builder()</code> methods on the <code>JWSService</code> bean. The actual payload type can be specified explicitly in the method as well as the <code>JWK</code> to use to digitally sign the <code>JWS</code>.</p>
                    <p>The <code>builder()</code> method actually accepts a publisher of <code>JWK</code> which means multiple keys can be considered when building the JWS. If keys are not specified, they are resolved from the JOSE header parameters using the <a href="#jwk-service">JWK service</a>. When building a JWS, the <code>JWSBuilder</code> basically retains the first trusted <code>JWK</code> that was able to sign the JWS. The retained <code>JWK</code> is exposed in the resulting <code>JWSHeader</code>. It is important to note that untrusted <code>JWK</code> are filtered out. A <code>JOSEObjectBuildException</code> is thrown if no suitable keys could be found.</p>
                    <p>A <code>JWSbuilder</code> uses media type converters injected in the module to encode the JWS payload based on the content type which can be either specified in the JOSE header (<code>cty</code>), or when invoking the <code>build()</code> method. An explicit <code>Function&lt;T, Mono&lt;String&gt;&gt;</code> encoder can also be specified in order to bypass media type converters.</p>
                    <blockquote>
                        <p>A specific encoder basically overrides the content type specified in <code>build()</code> method which overrides the content type specified in the JOSE header.</p>
                    </blockquote>
                    <p>The digital signature is computed by applying a signature algorithm to the JWS signing input composed of the JWS header and the serialized payload.</p>
                    <p>The following example shows how to build a <code>JWS</code> with a generated <code>JWK</code> and a payload serialized as <code>application/json</code> using corresponding media type converter:</p>
                    <pre><code class="language-java">// Injected or obtained from a 'Jose' instance
JWKService jwkService = ...
JWSService jwsService = ...

Mono&lt;? extends OCTJWK&gt; key = jwkService.oct().generator()
    .keyId("keyId")
    .algorithm(OCTAlgorithm.HS256.getAlgorithm())
    .generate()
    .cache();

JWS&lt;Message&gt; jws = jwsService.builder(Message.class, key)
    .header(header -&gt; header
        .keyId("keyId")
        .algorithm(OCTAlgorithm.HS256.getAlgorithm())
    )
    .payload(new Message("John", "Hello world!"))
    .build(MediaTypes.APPLICATION_JSON)
    .block();

// eyJhbGciOiJIUzI1NiIsImtpZCI6ImtleUlkIn0.eyJhdXRob3IiOiJKb2huIiwibWVzc2FnZSI6IkhlbGxvIHdvcmxkISJ9.aSRmKH3ZiTGm2MrKBLqBJH-d-rBEt5bWPY6TEC15B7s
String jwsCompact = jws.toCompact();
</code></pre>
                    <p>Assuming the <code>JWK</code> can be resolved by the <code>JWKService</code> using the key id (from module's <code>JWKStore</code> or <code>JWKKeyResolver</code>), the key can be omitted when creating the builder:</p>
                    <pre><code class="language-java">// Using an 'InMemoryJWKStore', we can store the key so it can be resolved by key id by the 'JWKService'
key.map(JWK::trust).map(jwkService.store()::set).block();

// Key 'keyId' is then automatically resolved
JWS&lt;Message&gt; jws = jwsService.builder(Message.class)
    ...
</code></pre>
                    <p>The JWS JSON representation as defined by <a href="https://datatracker.ietf.org/doc/html/rfc7515">RFC 7515 Section 7.2</a> is a JWS representation that is neither optimized nor URL-safe. This notation can hardly be compared to the compact notation and it shall be used for very different puproses, for instance to communicate digitally signed or MACed content in JSON using different keys and algorithms to one or more recipients.</p>
                    <p>A <code>JsonJWSBuilder</code> is used to create <code>JsonJWS</code> with multiple signatures following the JSON representation specification, it is obtained by invoking one of the <code>jsonBuilder()</code> methods on the <code>JWSService</code> bean. Since a <code>JsonJWS</code> might have multiple signatures using different keys and algorithms, only the payload type can be specified when creating the builder, keys will be provided or resolved later in the process.</p>
                    <p>A <code>JsonJWS</code> is created in a similar way as for a <code>JWS</code> with one payload but multiple JOSE headers to create multiple signatures. The JOSE header is then divided into an unprotected header and a protected headers which, unlike the unprotected header, is included in the digital signature. Protected and unprotected headers must be disjoint and content related parameters such as the type (<code>typ</code>) or the content type (<code>cty</code>) must be consistent across all signature headers. Some sensitive parameters such as the algorithm (<code>alg</code>) must also be integrity protected and therefore specified exclusively in the protected header. A <code>JWSBuildException</code> shall be thrown in case of invalid or inconsistent signature headers. Keys must be provided explicitly or resolved automatically for each signature to be able to compute the digital signature.</p>
                    <p>The following example shows how to build a <code>JsonJWS</code> with two signatures using generated keys and a payload encoded using an explicit encoder:</p>
                    <pre><code class="language-java">// Injected or obtained from a 'Jose' instance
JWKService jwkService = ...
JWSService jwsService = ...

Mono&lt;? extends OCTJWK&gt; key1 = jwkService.oct().generator()
    .keyId("key1")
    .algorithm(OCTAlgorithm.HS256.getAlgorithm())
    .generate()
    .cache();

Mono&lt;? extends RSAJWK&gt; key2 = jwkService.rsa().generator()
    .keyId("key2")
    .algorithm(RSAAlgorithm.RS256.getAlgorithm())
    .generate()
    .cache();

JsonJWS&lt;Message, BuiltSignature&lt;Message&gt;&gt; jsonJWS = jwsService.jsonBuilder(Message.class)
    .signature(
        protectedHeader -&gt; protectedHeader
            .keyId("key1")
            .algorithm(OCTAlgorithm.HS256.getAlgorithm()),
        unprotectedHeader -&gt; {},
        key1
    )
    .signature(
        protectedHeader -&gt; protectedHeader
            .keyId("key2")
            .algorithm(RSAAlgorithm.RS256.getAlgorithm()),
        unprotectedHeader -&gt; {},
        key2
    )
    .payload(new Message("Alice", "Hi John!"))
    .build(message -&gt; Mono.just(message.getAuthor() + " &gt; " + message.getMessage()))
    .block();

/*
 * {
 *   "signatures": [
 *     {
 *       "header": {
 *         "kid": "key1",
 *         "cty": "text/plain"
 *       },
 *       "signature": "u38wYs0v1M-zgw0lr2Gw3PKRALPxWH6I4wfpLFF_E3I",
 *       "protected": "eyJhbGciOiJIUzI1NiJ9"
 *     },
 *     {
 *       "header": {
 *         "kid": "key2",
 *         "cty": "text/plain"
 *       },
 *       "signature": "X6J77kf7sXW_7j7tLvgwJR2hy2kvDjuEGdT-1WU_Po2Z0sMPvHJd9LRdgYWUCn10V6
 *                     xgNatDQuwEnegOrIOVTI2yN6_T74rQY1-VWO8kESg_MyGRoieC3s6beQAt0JdWKgSs
 *                     xNZjCbRLTu_bxTpIl90j2MgPNHiL8ox2uDwA3pg-6cgEzswMQx6x_KQ-e3VPuqdiSd
 *                     6PNeFNiYN-s9xBTlN_m-0k8MDHSzQ612Ms3Q1ox2gONdpVG3wcoIPX63zaRmt-a3r6
 *                     KReL9bPBs1hCRHxp6ermxwJRf0yjKfo2KH2fWV_wMiPsCdbJSlIL3MPreR0yi5iVDu
 *                     iXK-yWoJ2XOg",
 *       "protected": "eyJhbGciOiJSUzI1NiJ9"
 *     }
 *   ],
 *   "payload": "QWxpY2UgPiBIaSBKb2huIQ"
 * }
 */
String jwsJson = jsonJWS.toJson();
</code></pre>
                    <p>In above code, we can see that the payload is common to all signatures which explains why content related parameters must be consistent across all signatures and to make this clear the content type was specified in the common unprotected header. Each resulting unprotected headers then contain the key id and the JWS content type whereas protected headers, encoded in Base64, contain the algorithms that were used to digitally sign the JWS.</p>
                    <p>The <code>JsonJWS</code> interface exposes the payload as well as the <code>JWS</code> instances corresponding to each signature.</p>
                    <pre><code class="language-java">Message message = jsonJWS.getPayload();

List&lt;JWS&gt; jwsSignatures = jsonJWS.getSignatures().stream()
    .map(signature -&gt; signature.getJWS())
    .collect(Collectors.toList());
</code></pre>
                    <blockquote>
                        <p>Note that the <code>JWS</code> instances thus obtained are deduced from the JSON representation which makes a difference between protected and unprotected headers, as a result the actual header used in the signature corresponds to the protected header but the <code>JWSHeader</code> exposed in the <code>JWS</code> results from the merge of the protected and unprotected headers.</p>
                    </blockquote>
                    <h5 id="reading-jws">Reading JWS</h5>
                    <p>A <code>JWSReader</code> is used to read JWS compact representations, it is obtained by invoking one of the <code>reader()</code> methods on the <code>JWSService</code> bean. The expected payload type must be specified explicitly in the method and the <code>JWK</code> to use to verify the JWS signature can be specified as well.</p>
                    <p>As for the <code>JWSBuilder</code>, a <code>JWSReader</code> can consider multiple keys to verify a JWS signature. If keys are not specified, they are resolved from the JOSE header parameters using the <a href="#jwk-service">JWK service</a>. When reading a <code>JWS</code>, the <code>JWSReader</code> basically uses provided or resolved trusted <code>JWK</code> in sequence to verify the signature and stops when the signature could be verified. As for the <code>JWSBuilder</code>, untrusted <code>JWK</code> are filtered out and a <code>JOSEObjectReadException</code> is thrown if no suitable keys could be found. A <code>JWSReadException</code> with aggregated errors (<code>getSuppressed()</code>) is thrown when reading an invalid JWS.</p>
                    <p>A <code>JWSReader</code> also uses media type converters injected in the module to decode the JWS payload based on the JWS content type defined in the JOSE header (<code>cty</code>) or explicitly specified when invoking the <code>read()</code> method. An explicit <code>Function&lt;String, Mono&lt;T&gt;&gt;</code> decoder can also be specified in order to bypass media type converters.</p>
                    <blockquote>
                        <p>A specific decoder basically overrides the content type specified in <code>read()</code> method which overrides the content type in the JOSE header.</p>
                    </blockquote>
                    <p>The following example shows how to read a JWS compact representation by decoding the <code>application/json</code> payload as specified in the JOSE header using the corresponding media type converter:</p>
                    <pre><code class="language-java">// Injected or obtained from a 'Jose' instance
JWKService jwkService = ...
JWSService jwsService = ...

Mono&lt;? extends OCTJWK&gt; key = jwkService.oct().builder()
    .keyId("keyId")
    .algorithm(OCTAlgorithm.HS256.getAlgorithm())
    .keyValue("xqf1haCsSJGuueZivcq4YafdWw6n5CH2BTT6vDwUSaM")
    .build()
    .cache();

String jwsCompact = "eyJhbGciOiJIUzI1NiIsImtpZCI6ImtleUlkIiwiY3R5IjoiYXBwbGljYXRpb24vanNvbiJ9."
    + "eyJhdXRob3IiOiJCaWxsIiwibWVzc2FnZSI6IkhleSEifQ."
    + "pNS2tZmB20ezMA-twecOhobDk3H5AgWyh-m5eV5xE14";

JWS&lt;Message&gt; jws = jwsService.reader(Message.class, key)
    .read(jwsCompact)
    .block();

// Bill says Hey!
Message message = jws.getPayload();
</code></pre>
                    <p>Assuming the <code>JWK</code> can be resolved by the <code>JWKService</code> using the key id (from module's <code>JWKStore</code> or <code>JWKKeyResolver</code>), the key can be omitted when creating the reader:</p>
                    <pre><code class="language-java">// Using an 'InMemoryJWKStore', we can store the key so it can be resolved by key id by the 'JWKService'
key.map(JWK::trust).map(jwkService.store()::set).block();

// Key 'keyId' is then automatically resolved
JWS&lt;Message&gt; jws = jwsService.reader(Message.class)
    ...
</code></pre>
                    <p>A <code>JsonJWSReader</code> is used to read JWS JSON representations as defined by <a href="https://datatracker.ietf.org/doc/html/rfc7515">RFC 7515 Section 7.2</a>, it is obtained by invoking one of the <code>jsonReader()</code> methods on the <code>JWSService</code> bean. Since a <code>JsonJWS</code> might have multiple signatures using different keys and algorithms, only the payload type must be specified when creating the reader. A <code>JsonJWS</code> is basically read without verifying signatures which must later be verified individually, keys can then be specified explicitly or automatically resolved. A <code>JsonJWS</code> can be considered valid if one signature could be verified.</p>
                    <blockquote>
                        <p>The <code>JsonJWS</code> instance returned by a <code>JsonJWSReader</code> actually differs from the one returned by a <code>JsonJWSBuilder</code>, a built <code>JsonJWS</code> exposes <code>JsonJWS.BuiltSignature</code> which exposes a valid <code>JWS</code> whereas a read <code>JsonJWS</code> exposes <code>JsonJWS.ReadSignature</code> which exposes <code>readJWS()</code> methods to actually verify the signature and return the corresponding <code>JWS</code>.</p>
                    </blockquote>
                    <p>The following example shows how to read and verify a JWS JSON representation with two signatures, the payload being decoded using an explicit decoder:</p>
                    <pre><code class="language-java">// Injected or obtained from a 'Jose' instance
JWKService jwkService = ...
JWSService jwsService = ...

Mono&lt;? extends ECJWK&gt; key2 = jwkService.ec().builder()
    .keyId("key2")
    .algorithm(ECAlgorithm.ES256.getAlgorithm())
    .curve(ECCurve.P_256.getCurve())
    .xCoordinate("f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU")
    .yCoordinate("x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0")
    .eccPrivateKey("jpsQnnGQmL-YBIffH1136cspYG6-0iY7X1fCE9-E9LI")
    .build()
    .cache();

String jwsJson = "{"
    + "  \"signatures\": ["
    + "    {"
    + "      \"header\": {"
    + "        \"cty\": \"text/plain\","
    + "        \"kid\": \"key1\""
    + "      },"
    + "      \"signature\": \"PxhpMkmTep5obGFZv50OsRGA-e7-fxhUmWdUyLC74ms\","
    + "      \"protected\": \"eyJhbGciOiJIUzI1NiJ9\""
    + "    },"
    + "    {"
    + "      \"header\": {"
    + "        \"cty\": \"text/plain\","
    + "        \"kid\": \"key2\""
    + "      },"
    + "      \"signature\": \"KqjGSxiBD5GhwFhLs8H_RBg8nXsKtp4nj5PsdxCzd0ZqMed874ZAxTgnyd0KmQEZwmYvvgM-o8NC9VdIWalMvw\","
    + "      \"protected\": \"eyJhbGciOiJFUzI1NiJ9\""
    + "    }"
    + "  ],"
    + "  \"payload\": \"TGluZGEgPiBTaGFsbCB3ZSBiZWdpbj8\""
    + "}";   

JsonJWS&lt;Message, ReadSignature&lt;Message&gt;&gt; jsonJWS = jwsService.jsonReader(Message.class)
    .read(jwsJson, p -&gt; 
        Mono.fromSupplier(() -&gt; {
            int separatorIndex = p.indexOf("&gt;");
            return new Message(p.substring(0, separatorIndex - 1), p.substring(separatorIndex + 2));
        })
    )
    .block();

// Return as soon as one of the signatures could have been verified with key2
JWS&lt;Message&gt; verifiedJWS = Flux.fromIterable(jsonJWS.getSignatures())
    .flatMap(signature -&gt; signature.readJWS(key2).onErrorResume(e -&gt; Mono.empty()))
    .blockFirst();

if(verifiedJWS != null) {
    // Linda says Shall we begin?
    Message message = verifiedJWS.getPayload();
}
</code></pre>
                    <p>In above code, the verified <code>JWS</code> should correspond to the second signature since we used <code>key2</code> to verify the <code>JsonJWS</code> signatures.</p>
                    <p>As defined by <a href="https://datatracker.ietf.org/doc/html/rfc7515">RFC 7515</a>, custom parameters listed in the critical header parameter (<code>crit</code>) and present in the JOSE header must be fully understood by the application for the JWS to be valid. The parameters actually processed by and application and therefore understood can be specified on the <code>JWSReader</code> which throws a <code>JOSEObjectReadException</code> when encountering unknown critical parameters.</p>
                    <p>In the following example, the <code>JWSReader</code> is setup to understand custom parameter <code>http://example.com/application_parameter</code> which allows it to read the specified JWS:</p>
                    <pre><code class="language-java">Mono&lt;? extends OCTJWK&gt; key = jwkService.oct().builder()
    .keyId("keyId")
    .algorithm(OCTAlgorithm.HS256.getAlgorithm())
    .keyValue("xqf1haCsSJGuueZivcq4YafdWw6n5CH2BTT6vDwUSaM")
    .build()
    .cache();

/*
 * {
 *   "header": {
 *     "alg": "HS256",
 *     "kid": "keyId",
 *     "crit": [
 *       "http://example.com/application_parameter"
 *     ],
 *     "http://example.com/application_parameter": true
 *   },
 *   "payload": "Lorem ipsum",
 *   "signature": "aQMWohoxZWOcpYVm04FBJwGc7fBO4xzUKVJz9qfjpxc"
 * }
 */
String jwsCompact = "eyJhbGciOiJIUzI1NiIsImtpZCI6ImtleUlkIiwiY3JpdCI6WyJodHRwOi8vZXhhbXBsZS5jb20vYXBwbGljYXRpb25fcGFyYW1ldGVyIl0sImh0dHA6Ly9leGFtcGxlLmNvbS9hcHBsaWNhdGlvbl9wYXJhbWV0ZXIiOnRydWV9."
    + "TG9yZW0gaXBzdW0."
    + "aQMWohoxZWOcpYVm04FBJwGc7fBO4xzUKVJz9qfjpxc";

JWS&lt;String&gt; jws = jwsService.reader(String.class, key)
    .processedParameters("http://example.com/application_parameter")
    .read(jwsCompact, MediaTypes.TEXT_PLAIN)
    .block();
</code></pre>
                    <h4 id="jwe-service">JWE Service</h4>
                    <p>The JWE service is used to build or read JWE represented using the compact or the JSON notation as defined by <a href="https://datatracker.ietf.org/doc/html/rfc7516">RFC 7516</a>.</p>
                    <p>The <code>JWEService</code> bean is used to create <code>JWEBuilder</code> or <code>JsonJWEBuilder</code> instances to build JWE using the compact or the JSON notation and <code>JWEReader</code> or <code>JsonJWEReader</code> instances to read JWE serialized using the compact or JSON notation.</p>
                    <p>A JWE allows to communicate encrypted content using cryptographic algorithms that guarantees both integrity and confidentiality. It is composed of five parts:</p>
                    <ul>
                        <li>a JOSE header which specifies how to understand (i.e. type, content type...), encrypt or decrypt the JWE content.</li>
                        <li>an encrypted key which corresponds to the content encryption key used to encrypt the JWE content.</li>
                        <li>an initilization vector used when encrypting the JWE content.</li>
                        <li>a cipher text which results from the authenticated encryption of the JWE content.</li>
                        <li>an authentication tag which ensures the integrity of the cipher text.</li>
                    </ul>
                    <p>A <code>JWE</code> is obtained from a <code>JWEBuilder</code> or a <code>JWEReader</code>, the <code>JWE</code> interface exposes the header, the encrypted key, the initialization vector, the cipher text, the authentication tag and the payload. It can be serialized using the compact notation as follows:</p>
                    <pre><code class="language-java">JWE&lt;?&gt; jwe = ...

// &lt;header&gt;.&lt;encrypted_key&gt;.&lt;initialization_vector&gt;.&lt;cipher_text&gt;.&lt;authentication_tag&gt;
// e.g. eyJhbGciOiJBMTI4S1ciLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0.6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ.AxY8DCtDaGlsbGljb3RoZQ.KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY.U0m_YmjN04DJvceFICbCVQ
String jweCompact = jwe.toCompact();
</code></pre>
                    <p>A <code>JsonJWE</code> is obtained from a <code>JsonJWEBuilder</code> or a <code>JsonJWEReader</code>, the <code>JsonJWE</code> interface exposes protected and unprotected headers, the inialization vector, the additional authentication data, the cipher text, the authentication tag and the list of recipients. It can be serialized using the JSON notation as follows:</p>
                    <pre><code class="language-java">JsonJWE&lt;?, ?&gt; jsonJWE = ...

/* 
 * RFC 7516 Appendix A.4
 *
 * {
 *   "protected": "eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0",
 *   "unprotected": {
 *     "jku": "https://server.example.com/keys.jwks"
 *   },
 *   "recipients": [
 *     {
 *       "header": {
 *         "alg":"RSA1_5",
 *         "kid":"2011-04-29"
 *       },
 *       "encrypted_key": "UGhIOguC7IuEvf_NPVaXsGMoLOmwvc1GyqlIKOK1nN94nHPoltGRhWhw7Zx0-
 *                         kFm1NJn8LE9XShH59_i8J0PH5ZZyNfGy2xGdULU7sHNF6Gp2vPLgNZ__deLKx
 *                         GHZ7PcHALUzoOegEI-8E66jX2E4zyJKx-YxzZIItRzC5hlRirb6Y5Cl_p-ko3
 *                         YvkkysZIFNPccxRU7qve1WYPxqbb2Yw8kZqa2rMWI5ng8OtvzlV7elprCbuPh
 *                         cCdZ6XDP0_F8rkXds2vE4X-ncOIM8hAYHHi29NX0mcKiRaD0-D-ljQTP-cFPg
 *                         wCp6X-nZZd9OHBv-B3oWh2TbqmScqXMR4gp_A"
 *     },
 *     {
 *       "header": {
 *         "alg":"A128KW",
 *         "kid":"7"
 *       },
 *       "encrypted_key": "6KB707dM9YTIgHtLvtgWQ8mKwboJW3of9locizkDTHzBC2IlrT1oOQ"
 *     }
 *   ],
 *   "iv": "AxY8DCtDaGlsbGljb3RoZQ",
 *   "ciphertext": "KDlTtXchhZTGufMYmOYGS4HffxPSUrfmqCHXaI9wOGY",
 *   "tag": "Mz-VPPyU4RlcuYv1IwIvzw"
 * }
 */
String jweJson = jsonJWE.toJson();
</code></pre>
                    <blockquote>
                        <p>The most common representation is by far the compact representation which can be safely used in URLs. On the other hand, the JSON notation can be used to target multiple systems with various JWKs.</p>
                    </blockquote>
                    <p>A JWE offers integrity and confidentiality of its content using authenticated encryption, it requires two algorithms:</p>
                    <ul>
                        <li>the algorithm (<code>alg</code>) used to encrypt/decrypt, wrap/unwrap or derive a content encryption key (CEK)</li>
                        <li>the encryption algorithm used to actually encrypt/decrypt the content using the CEK.</li>
                    </ul>
                    <p>The CEK is either generated or derived when building a JWE and resolved when reading a JWE using a key management algorithm. As a result, building or reading a JWE requires a <code>JWK</code> supporting key management algorithms.</p>
                    <h5 id="building-jwe">Building JWE</h5>
                    <p>A <code>JWEBuilder</code> is used to create <code>JWE</code>, it is obtained by invoking one of the <code>builder()</code> methods on the <code>JWEService</code> bean. The actual payload type can be specified explicitly in the method as well as the <code>JWK</code> to use to encrypt, wrap or derive the content encryption key used to encrypt the <code>JWE</code>.</p>
                    <p>The <code>builder()</code> method actually accepts a publisher of <code>JWK</code> which means multiple keys can be considered when building the JWE. If keys are not specified, they are resolved from the JOSE header parameters using the <a href="#jwk-service">JWK service</a>. When building a JWE, the <code>JWEBuilder</code> basically retains the first trusted <code>JWK</code> that was able to encrypt the content encryption key. The retained <code>JWK</code> is exposed in the resulting <code>JWEHeader</code>. It is important to note that untrusted <code>JWK</code> are filtered out. A <code>JOSEObjectBuildException</code> is thrown if no suitable keys could be found.</p>
                    <p>A <code>JWEbuilder</code> uses media type converters injected in the module to encode the JWE payload based on the content type which can be either specified in the JOSE header (<code>cty</code>), or when invoking the <code>build()</code> method. An explicit <code>Function&lt;T, Mono&lt;String&gt;&gt;</code> encoder can also be specified in order to bypass media type converters.</p>
                    <blockquote>
                        <p>A specific encoder basically overrides the content type specified in <code>build()</code> method which overrides the content type specified in the JOSE header.</p>
                    </blockquote>
                    <p>The JWE content are encrypted using a generated content encryption key (CEK) or directly using the provided or resolved <code>JWK</code> in case of direct encryption (i.e. <code>alg=dir</code>). The CEK (if any) is encrypted, wrapped or derived using the provided or resolved <code>JWK</code> and included in the resulting JWE with the initialization vector that was generated and used during the authenticated encryption and the resulting authentication tag so that a recipient has all the information required to decrypt the CEK and eventually verify and decrypt the JWE.</p>
                    <p>The following example shows how to build a <code>JWE</code> with a generated <code>JWK</code> and a payload serialized as <code>application/json</code> using corresponding media type converter:</p>
                    <pre><code class="language-java">// Injected or obtained from a 'Jose' instance
JWKService jwkService = ...
JWEService jweService = ...

Mono&lt;? extends OCTJWK&gt; key = jwkService.oct().generator()
    .keyId("keyId")
    .algorithm(OCTAlgorithm.A256GCMKW.getAlgorithm())
    .generate()
    .cache();

JWE&lt;Message&gt; jwe = jweService.builder(Message.class, key)
    .header(header -&gt; header
        .keyId("keyId")
        .algorithm(OCTAlgorithm.A256GCMKW.getAlgorithm())
        .encryptionAlgorithm(OCTAlgorithm.A128CBC_HS256.getAlgorithm())
    )
    .payload(new Message("John", "Hello world!"))
    .build(MediaTypes.APPLICATION_JSON)
    .block();

// eyJlbmMiOiJBMTI4Q0JDLUhTMjU2IiwiYWxnIjoiQTI1NkdDTUtXIiwia2lkIjoia2V5SWQiLCJ0YWciOiJ3b2RKcDJSbThPOEdGWG9PUWZvaTdnIiwiaXYiOiJpYmFfakkzSDRyWUdfcUQtIn0.Barv9ju_JgIBugTD3TtKGA6OyqadZ635rkw6rfpeR7s.QH1HhZKhKWrPzJtfSLRjUQ.gUXtGvVzvwopFh0ZgUlZGB2zOdsFjUG0u2Rih_JNsryDIAkpD_LMDDNYTh2ZRgm1.EgQt9XxCfFDRho5mPAXQRQ
String jweCompact = jwe.toCompact();
</code></pre>
                    <p>Assuming the <code>JWK</code> can be resolved by the <code>JWKService</code> using the key id (from module's <code>JWKStore</code> or <code>JWKKeyResolver</code>), the key can be omitted when creating the builder:</p>
                    <pre><code class="language-java">// Using an 'InMemoryJWKStore', we can store the key so it can be resolved by key id by the 'JWKService'
key.map(JWK::trust).map(jwkService.store()::set).block();

// Key 'keyId' is then automatically resolved
JWE&lt;Message&gt; jwe = jweService.builder(Message.class)
    ...
</code></pre>
                    <p>The JWE JSON representation as defined by <a href="https://datatracker.ietf.org/doc/html/rfc7516">RFC 7516 Section 7.2</a> is a JWE representation that is neither optimized nor URL-safe. This notation can hardly be compared to the compact notation and it shall be used for very different puproses, for instance to communicate encrypted content in JSON using different keys and algorithms to one or more recipients.</p>
                    <p>A <code>JsonJWEBuilder</code> is used to create <code>JsonJWE</code> with multiple recipients following the JSON representation specification, it is obtained by invoking one of the <code>jsonBuilder()</code> methods on the <code>JWEService</code> bean. Since a <code>JsonJWE</code> might have multiple recipients with different encrypted content using different keys and algorithms, only the payload type can be specified when creating the builder, keys will be provided or resolved later in the process.</p>
                    <p>A <code>JsonJWE</code> is created from common protected and unprotected headers, one payload and multiple recipients with unportected headers used to encrypt the JWE using different keys. Unlike unprotected headers, the common protected header is included in the additional authentication data used during the authenticated encryption of the JWE. Common headers and per recipient header must be disjoint and content related parameters such as the type (<code>typ</code>) or the content type (<code>cty</code>) must be consistent across all recipient headers. A <code>JWEBuildException</code> shall be thrown in case of invalid or inconsistent recipient headers. The encryption algorithm parameter (<code>enc</code>) must also be consistent across all recipients since the cipher text, the initilization vector, the authentication tag and the content encryption key used to encrypt the JWE are common to all recipients (the JWE is actually encrypted once), it is however encrypted, wrapped or derived per recipient using different keys explicitly provided or automatically resolved for each recipient. In case of a direct encryption or direct key agreement algorithm, the algorithm paremeter (<code>alg</code>) must also be consistent across all recipients.</p>
                    <blockquote>
                        <p>In the particular case of a direct encryption, a <code>JsonJWE</code> is really not different than a regular JWE since all recipients have then to share the same encryption key.</p>
                    </blockquote>
                    <p>The following example shows how to build a <code>JsonJWE</code> with two recipients using generated keys and a payload encoded as <code>text/plain</code> using an explicit encoder:</p>
                    <pre><code class="language-java">// Injected or obtained from a 'Jose' instance
JWKService jwkService = ...
JWEService jweService = ...

Mono&lt;? extends RSAJWK&gt; key1 = jwkService.rsa().generator()
    .keyId("key1")
    .algorithm(RSAAlgorithm.RSA1_5.getAlgorithm())
    .generate()
    .cache();

Mono&lt;? extends OCTJWK&gt; key2 = jwkService.oct().generator()
    .keyId("key2")
    .algorithm(OCTAlgorithm.A128KW.getAlgorithm())
    .generate()
    .cache();

JsonJWE&lt;Message, BuiltRecipient&lt;Message&gt;&gt; jsonJWE = jweService.jsonBuilder(Message.class)
    .headers(
        protectedHeader -&gt; protectedHeader
            .encryptionAlgorithm(OCTAlgorithm.A128CBC_HS256.getAlgorithm()),
        unprotectedHeader -&gt; {}
    )
    .payload(new Message("Alice", "Hi John!"))
    .recipient(
        header -&gt; header
            .keyId("key1")
            .algorithm(RSAAlgorithm.RSA1_5.getAlgorithm()),
        key1
    )
    .recipient(
        header -&gt; header
            .keyId("key2")
            .algorithm(OCTAlgorithm.A128KW.getAlgorithm()),
        key2
    )
    .build(message -&gt; Mono.just(message.getAuthor() + " &gt; " + message.getMessage()))
    .block();

/*
 * {
 *   "unprotected": {
 *   },
 *   "ciphertext": "n8hpXBhxZ9brlm465Ipey9kpCHyOxDfR-qNzRh32KQM",
 *   "recipients": [
 *     {
 *       "header": {
 *         "alg": "RSA1_5",
 *         "kid": "key1"
 *       },
 *       "encrypted_key": "ItwxvAJqMh_kGeJ9jmHPm1NJ1Kod-TmAwsm5IbZDy54uB6U1eGQZKQzzLTMGMM
 *                         UUf6G96kT35Vv__L2fr6k8INlGOi3ae5YDnRmVwOpD74pffQn3FFcoxx68_xSu
 *                         DWDHMRbyEqHFur-DZy2O-yb0Odna7qg7kmAz0wv9VSOHpfRWj8wB4w7g4zg4jI
 *                         5IztiTX587fCtw7YuiBYnNEUzCrddUoBAAphWHiilez25lvOdhjvyyMNAT-j_5
 *                         8FDIQGgqUY0uLE48-gKF2alnrIkjk_9H9Cg_99mBEyls5EAnRq3aGiJz7wPJR3
 *                         1Qtl54c8IUDLtqNXKaB8qsk5taYV5hlQ"
 *     },
 *     {
 *       "header": {
 *         "alg": "A128KW",
 *         "kid": "key2"
 *       },
 *       "encrypted_key": "srvZC3EPaEYkfHkTp21-mzBHA17gjuof6-NTWdg7unHsPK1rnp1eFQ"
 *     }
 *   ],
 *   "iv": "bBb7jcsxoRcPpKahEPCvwA",
 *   "tag": "u7dD-MwLkfA4SfuRjvVmdQ",
 *   "protected": "eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0"
 * }
 */
String jweJson = jsonJWE.toJson();
</code></pre>
                    <p>In above code, we can see that the cipher text is common to all recipients which explains why content related parameters and the encryption algorithm must be consistent across all recipients and to make this clear the encryption algorithm was specified in the common protected header, encoded in Base64. Unprotected headers in each recipient then specify the key id and the algorithm to use to resolve the content encryption key in order to decrypt the JWE.</p>
                    <p>The <code>JsonJWE</code> interface exposes the common protected and unprotected headers, the cipher text, the initilization vector, the additional authentication data and the authentication tag as well as the <code>JWE</code> instances corresponding to each recipient.</p>
                    <pre><code class="language-java">List&lt;JWE&lt;Message&gt;&gt; jweRecipients = jsonJWE.getRecipients().stream()
    .map(recipient -&gt; recipient.getJWE())
    .collect(Collectors.toList());
</code></pre>
                    <blockquote>
                        <p>Note that the <code>JWE</code> instances thus obtained are deduced from the JSON representation which makes a difference between protected and unprotected headers, as a result the actual header used in the additional authentication data corresponds to the protected header but the <code>JWEHeader</code> exposed in the <code>JWE</code> results from the merge of the common protected and unprotected headers and the recipient unprotected header.</p>
                    </blockquote>
                    <h5 id="reading-jwe">Reading JWE</h5>
                    <p>A <code>JWEReader</code> is used to read JWE compact representations, it is obtained by invoking one of the <code>reader()</code> methods on the <code>JWEService</code> bean. The expected payload type must be specified explicitly in the method and the <code>JWK</code> to use to decrypt, unwrap or derive the content encryption key, actually used to decrypt the <code>JWE</code>, can be specified as well.</p>
                    <p>As for the <code>JWEBuilder</code>, a <code>JWEReader</code> can consider multiple keys to decrypt, unwrap or derive the content encryption key used to encrypt the JWE. If keys are not specified, they are resolved from the JOSE header parameters using the <a href="#jwk-service">JWK service</a>. When reading a <code>JWE</code>, the <code>JWEReader</code> basically uses provided or resolved trusted <code>JWK</code> in sequence to resolve the content encryption key and stops when the CEK could be resolved. As for the <code>JWEBuilder</code>, untrusted <code>JWK</code> are filtered out and a <code>JOSEObjectReadException</code> is thrown if no suitable keys could be found. A <code>JWEReadException</code> with aggregated errors (<code>getSuppressed()</code>) is thrown when reading an invalid JWE.</p>
                    <p>A <code>JWEReader</code> also uses media type converters injected in the module to decode the JWE payload based on the JWE content type defined in the JOSE header (<code>cty</code>) or explicitly specified when invoking the <code>read()</code> method. An explicit <code>Function&lt;String, Mono&lt;T&gt;&gt;</code> decoder can also be specified in order to bypass media type converters.</p>
                    <blockquote>
                        <p>A specific decoder basically overrides the content type specified in <code>read()</code> method which overrides the content type in the JOSE header.</p>
                    </blockquote>
                    <p>The following example shows how to read a JWE compact representation by decoding the <code>application/json</code> payload as specified in the JOSE header using the corresponding media type converter:</p>
                    <pre><code class="language-java">// Injected or obtained from a 'Jose' instance
JWKService jwkService = ...
JWEService jweService = ...

Mono&lt;? extends OCTJWK&gt; key = jwkService.oct().builder()
    .keyId("keyId")
    .algorithm(OCTAlgorithm.A256GCMKW.getAlgorithm())
    .keyValue("GkilETj3L4jpinuRiaNq6zd7-_1JPbfU9DY3xHl9HEE")
    .build()
    .cache();

String jweCompact = "eyJlbmMiOiJBMTI4Q0JDLUhTMjU2IiwiYWxnIjoiQTI1NkdDTUtXIiwia2lkIjoia2V5SWQiLCJjdHkiOiJhcHBsaWNhdGlvbi9qc29uIiwidGFnIjoiYUtlc2VBelZoenh5Vk9pRVNvVEdoQSIsIml2IjoieEJFSTlYeHBDVTZwcVVSaCJ9."
    + "MNYqpQCQPrUSZTwP-C7kUCGOFqFGGciUU2qW54jc3NM."
    + "_nfKSroUwjqzdJcPETt-ow."
    + "1dL8rLmhKF7hqVNzQf5oWPOSZN7Z_V46w0UvIBDuFjH5pqvhbs4ltrTsk6E_NF-y."
    + "RJ8QOGLuT2fz5VrzG1EHbg";

JWE&lt;Message&gt; jwe = jweService.reader(Message.class, key)
    .read(jweCompact)
    .block();

// Bill says Hey!
Message message = jwe.getPayload();
</code></pre>
                    <p>Assuming the <code>JWK</code> can be resolved by the <code>JWKService</code> using the key id (from module's <code>JWKStore</code> or <code>JWKKeyResolver</code>), the key can be omitted when creating the reader:</p>
                    <pre><code class="language-java">// Using an 'InMemoryJWKStore', we can store the key so it can be resolved by key id by the 'JWKService'
key.map(JWK::trust).map(jwkService.store()::set).block();

// Key 'keyId' is then automatically resolved
JWE&lt;Message&gt; jwe = jweService.reader(Message.class)
    ...
</code></pre>
                    <p>A <code>JsonJWEReader</code> is used to read JWE JSON representations as defined by <a href="https://datatracker.ietf.org/doc/html/rfc7516">RFC 7516 Section 7.2</a>, it is obtained by invoking one of the <code>jsonReader()</code> methods on the <code>JWEService</code> bean. Since a <code>JsonJWE</code> might have multiple recipients using different keys and algorithms, only the payload type must be specified when creating the reader. A <code>JsonJWE</code> is basically read without decrypting the JWE content which must be decrypted for each recipient individually, keys can then be specified explicitly or automatically resolved. A <code>JsonJWE</code> can be considered valid if the content could be verified and decrypted for at least one recipient.</p>
                    <blockquote>
                        <p>The <code>JsonJWE</code> instance returned by a <code>JsonJWEReader</code> actually differs from the one returned by a <code>JsonJWEBuilder</code>, a built <code>JsonJWE</code> exposes <code>JsonJWE.BuiltRecipient</code> which exposes a valid <code>JWE</code> whereas a read <code>JsonJWE</code> exposes <code>JsonJWE.ReadRecipient</code> which exposes <code>readJWE()</code> methods to actually verify and decrypt the JWE content and return the corresponding <code>JWE</code>.</p>
                    </blockquote>
                    <p>The following example shows how to read and decrypt a JWE JSON representation with two recipients, the payload being decoded using an explicit decoder:</p>
                    <pre><code class="language-java">// Injected or obtained from a 'Jose' instance
JWKService jwkService = ...
JWEService jweService = ...

Mono&lt;? extends OCTJWK&gt; key2 = jwkService.oct().builder()
    .keyValue("GawgguFyGrWKav7AX4VKUg")
    .build()
    .cache();

String jweJson = "{"
    + "  \"unprotected\": {"
    + "  },"
    + "  \"ciphertext\": \"2jtWSZdL-TJGyktUwldH4sphYuz2VbseUS9el_vh_tU\","
    + "  \"recipients\": ["
    + "    {"
    + "      \"header\": {"
    + "        \"alg\": \"RSA1_5\","
    + "        \"kid\": \"key1\""
    + "      },"
    + "      \"encrypted_key\": \"kIHuM-OZU1wvmb6ocdDsn1ljF11kIbfvv9y7XpTPGfdYeaz2AhJvpHfPZ6LKk5-yDfHAVWTXz_RbgjPATURNKyu0hdogfWBWXEpQEk8WaBafI8kSk0GzhJrR2tcXhrxs0xWPMthjfZ38zNql1oZuL9pzUZ3PicNhcCXD2XN52kw7VGMvPus8r89orY4q2l_xA65wkxHtG3JDG9Je_CidYuX_PXHqMkrbszsUPbyCspPIRTP5yWMeFmMp8KiEnyGaQITt0vZuea4u3tWuhX0Wa2AN74qesuArMhx81NWxaMnuDNrF6eQFIQw4QJ41MqVchHRAoXYKQvB8DYce9fHhPQ\""
    + "    },"
    + "    {"
    + "      \"header\": {"
    + "        \"alg\": \"A128KW\","
    + "        \"kid\": \"key2\""
    + "      },"
    + "      \"encrypted_key\": \"OSMIf3Elx-NmfzP1Y_aZbae6k6yU2rl7o2uHd7v3lHgS4UjJURVYTQ\""
    + "    }"
    + "  ],"
    + "  \"iv\": \"vrCX8Yr9oOs--KiBtkQ6kw\","
    + "  \"tag\": \"gHpLPXRRDjUNJ1HDivaSTg\","
    + "  \"protected\": \"eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0\""
    + "}";

JsonJWE&lt;Message, ReadRecipient&lt;Message&gt;&gt; readJsonJWE = jweService.jsonReader(Message.class)
    .read(jweJson, payload -&gt; 
        Mono.fromSupplier(() -&gt; {
            int separatorIndex = payload.indexOf("&gt;");
            return new Message(payload.substring(0, separatorIndex - 1), payload.substring(separatorIndex + 2));
        })
    )
    .block();

// Return as soon as one of the recipients could have been verified and decrypted with key2
JWE&lt;Message&gt; decryptedJWE = Flux.fromIterable(readJsonJWE.getRecipients())
    .flatMap(recipient -&gt; recipient.readJWE(key2).onErrorResume(e -&gt; Mono.empty()))
    .blockFirst();

if(decryptedJWE != null) {
    // Linda says Shall we begin?
    Message message = decryptedJWE.getPayload();
}
</code></pre>
                    <p>In above code, the decrypted <code>JWE</code> should correspond to the second recipient since we used <code>key2</code> to resolve the content encryption key.</p>
                    <p>As defined by <a href="https://datatracker.ietf.org/doc/html/rfc7516">RFC 7516</a>, custom parameters listed in the critical header parameter (<code>crit</code>) and present in the JOSE header must be fully understood by the application for the JWE to be valid. The parameters actually processed by and application and therefore understood can be specified on the <code>JWEReader</code> which throws a <code>JOSEObjectReadException</code> when encountering unknown critical parameters.</p>
                    <p>In the following example, the <code>JWEReader</code> is setup to understand custom parameter <code>http://example.com/application_parameter</code> which allows it to read the specified JWE:</p>
                    <pre><code class="language-java">Mono&lt;? extends OCTJWK&gt; key = jwkService.oct().builder()
    .keyId("keyId")
    .algorithm(OCTAlgorithm.A256GCMKW.getAlgorithm())
    .keyValue("GkilETj3L4jpinuRiaNq6zd7-_1JPbfU9DY3xHl9HEE")
    .build()
    .cache();

/* 
* {
*   "header": {
*     "enc": "A128CBC-HS256",
*     "alg": "A256GCMKW",
*     "kid": "keyId",
*     "crit": [
*       "http://example.com/application_parameter"
*     ],
*     "http://example.com/application_parameter": true,
*     "tag": "pq1OChvU6GZcMDLZqTEo0Q",
*     "iv": "VcuwU871tvGMGOHB"
*   },
*   "payload": "Lorem ipsum",
*   "initializationVector": "i1GTQ9xyOL89vza7hNCiAQ",
*   "authenticationTag": "5EiKTUS272wTHd978QOuHQ",
*   "encryptedKey": "Aq7NWm_h4LmGjJynbUYOO7O9juKlUMFWXS_HMpAAR1g",
*   "cipherText": "mDeuwt3QO199_h6diPwu_w"
* }
*/
String jweCompact = "eyJlbmMiOiJBMTI4Q0JDLUhTMjU2IiwiYWxnIjoiQTI1NkdDTUtXIiwia2lkIjoia2V5SWQiLCJjcml0IjpbImh0dHA6Ly9leGFtcGxlLmNvbS9hcHBsaWNhdGlvbl9wYXJhbWV0ZXIiXSwiaHR0cDovL2V4YW1wbGUuY29tL2FwcGxpY2F0aW9uX3BhcmFtZXRlciI6dHJ1ZSwidGFnIjoicHExT0NodlU2R1pjTURMWnFURW8wUSIsIml2IjoiVmN1d1U4NzF0dkdNR09IQiJ9."
    + "Aq7NWm_h4LmGjJynbUYOO7O9juKlUMFWXS_HMpAAR1g."
    + "i1GTQ9xyOL89vza7hNCiAQ."
    + "mDeuwt3QO199_h6diPwu_w."
    + "5EiKTUS272wTHd978QOuHQ";

JWE&lt;String&gt; jwe = jweService.reader(String.class, key)
    .processedParameters("http://example.com/application_parameter")
    .read(jweCompact, MediaTypes.TEXT_PLAIN)
    .block();
</code></pre>
                    <h4 id="jwt-service">JWT Service</h4>
                    <p>The JWT service is used to build or read JWT represented using a URL-safe compact notation as defined by <a href="https://datatracker.ietf.org/doc/html/rfc7519">RFC 7519</a>. A JSON Web Token is a particular type of JWS or JWE that is used to securely transfer claims between two parties.</p>
                    <p>In practice, a JWT is created or read just like a <code>JWS</code> or a <code>JWE</code> with type <code>JWT</code> and a JSON payload of type <code>JWTClaimsSet</code> representing a set of claims.</p>
                    <p>The <code>JWTService</code> bean is used to create specific <code>JWSBuilder</code> or <code>JWEBuilder</code> instances for building JWT as <code>JWS</code> or <code>JWE</code> and specific <code>JWSReader</code> or <code>JWEReader</code> instances for reading <code>JWS</code> and <code>JWE</code> with <code>JWTClaimsSet</code> payloads serialized using the compact notation.</p>
                    <h5 id="jwt-claims-set">JWT claims set</h5>
                    <p>A JWT claims set represents a JSON object whose members are the claims conveyed by the JWT as defined by <a href="https://datatracker.ietf.org/doc/html/rfc7519">RFC 7519</a> which also specifies registered claim names. For instance, the issuer (<code>iss</code>) claim identifies the principal that issued the JWT, the expiration time claim (<code>exp</code>) identifies the expiration time on or after which the JWT must not be accepted for processing... A JWT is therefore validated by first verifying or decrypting the enclosing JWS or JWE and then by validating the JWT claims set, a JWT must be rejected if for instance the expiration time has passed.</p>
                    <p>The <code>JWTClaimsSet</code> interface is used to represent the JWT payload in a JWS or a JWE, it exposes the registered claims and allows to specify custom claims.</p>
                    <p>The following example shows how to create a <code>JWTClaimsSet</code> with an issuer and a custom claim and which expires in a day:</p>
                    <pre><code class="language-java">JWTClaimsSet jwtClaimsSet = JWTClaimsSet.of("joe", ZonedDateTime.now().plusDays(1).toEpochSecond())
    .addCustomClaim("http://example.com/is_root", true)
    .build();
</code></pre>
                    <p>A <code>JWTClaimsSet</code> can be validated in multiple ways:</p>
                    <pre><code class="language-java">if(jwtClaimsSet.isValid()) {
			
}

// Run an action only if the JWT claims set is valid
jwtClaimsSet.ifValid(() -&gt; {
    ...
});

// Run an action the JWT claims set is valid and another action if it is not
jwtClaimsSet.ifValidOrElse(
    () -&gt; {
        // Valid
        ...
    }, 
    () -&gt; {
        // Invalid
        ...
    }
);

// Throws an InvalidJWTException if the JWT claims set is invalid
jwtClaimsSet.ifInvalidThrow();

// Throws the provided exception if the JWT claims set is invalid
jwtClaimsSet.ifInvalidThrow(() -&gt; new CustomException("Invalid credentials"));
</code></pre>
                    <p>A <code>JWTClaimsSet</code> validates expiration time and not before claims by default, additional <code>JWTClaimsSetValidator</code> can be added as well by invoking <code>validate()</code> or <code>setValidators()</code> methods.</p>
                    <p>In the following example, a validator is added to check that the issuer is <code>iss</code>, an <code>InvalidJWTException</code> is thrown if the issuer claim doe snot match:</p>
                    <pre><code class="language-java">jwtClaimsSet.validate(JWTClaimsSetValidator.issuer("iss"));

// Throws an InvalidJWTException since issuer 'joe' does not match the expected 'iss'
jwtClaimsSet.ifInvalidThrow();
</code></pre>
                    <blockquote>
                        <p>It is then possible to provide custom validation logic using multiple <code>JWTClaimsSetValidator</code>, but the <code>JWTClaimsSet</code> interface can also be itself extended to better reflect application specificities by exposing application specific claims or specific validation logic.</p>
                    </blockquote>
                    <h5 id="building-jwt">Building JWT</h5>
                    <p>The <code>JWTService</code> bean exposes <code>jwsBuilder()</code> and <code>jweBuilder()</code> methods used to obtain specific <code>JWSBuilder</code> or <code>JWEBuilder</code> for creating JWT as <code>JWS</code> or <code>JWE</code> with <code>JWTClaimsSet</code> payloads. The builders thus obtained follow the exact same rules as defined by the <a href="#jws-service">JWS service</a> and the <a href="#jwe-service">JWE service</a> with the following exceptions: the type (<code>typ</code>) and the content type (<code>cty</code>) are always considered to be <code>JWT</code> and <code>application/json</code> since the JWT claims set is defined as a JSON object. A <code>JWTBuildException</code> is thrown when a type other than <code>JWT</code> (the type can be omitted) or a content type (no content type is allowed) are specified in the JOSE header.</p>
                    <p>The following example shows how to create a JWT as a <code>JWS</code> using a generated key:</p>
                    <pre><code class="language-java">// Injected or obtained from a 'Jose' instance
JWKService jwkService = ...
JWTService jwtService = ...

Mono&lt;? extends OCTJWK&gt; key = jwkService.oct().generator()
    .generate()
    .cache();

/*
 * {
 *   "iss":"joe",
 *   "exp":1691133731,
 *   "http://example.com/is_root":true
 * }
 */
JWTClaimsSet claims = JWTClaimsSet.of("joe", ZonedDateTime.now().plusYears(1).toEpochSecond())
    .addCustomClaim("http://example.com/is_root", true)
    .build();

JWS&lt;JWTClaimsSet&gt; jwts = jwtService.jwsBuilder(key)
    .header(header -&gt; header
        .algorithm(OCTAlgorithm.HS256.getAlgorithm())
        .type("JWT")
    )
    .payload(claims)
    .build()
    .block();

// eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJqb2UiLCJleHAiOjE2OTExMzM3NzQsImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ.4fEhUpbK4aNhgZB0XL_UiJV9k5pLw35MT1zIjq4oCro
String jwtsCompact = jwts.toCompact();
</code></pre>
                    <p>The following example shows how to create a JWT as a <code>JWE</code> using a generated key:</p>
                    <pre><code class="language-java">// Injected or obtained from a 'Jose' instance
JWKService jwkService = ...
JWTService jwtService = ...

Mono&lt;? extends ECJWK&gt; key = jwkService.ec().generator()
    .keyId("keyId")
    .algorithm(ECAlgorithm.ECDH_ES.getAlgorithm())
    .curve(ECCurve.P_256.getCurve())
    .generate()
    .cache();

/*
 * {
 *   "iss":"joe",
 *   "exp":1691133731,
 *   "http://example.com/is_root":true
 * }
 */
JWTClaimsSet claims = JWTClaimsSet.of("joe", ZonedDateTime.now().plusYears(1).toEpochSecond())
    .addCustomClaim("http://example.com/is_root", true)
    .build();

JWE&lt;JWTClaimsSet&gt; jwte = jwtService.jweBuilder(key)
    .header(header -&gt; header
        .algorithm(ECAlgorithm.ECDH_ES.getAlgorithm())
        .encryptionAlgorithm(OCTAlgorithm.A256GCM.getAlgorithm())
        .type("JWT")
    )
    .payload(claims)
    .build()
    .block();

// eyJlbmMiOiJBMjU2R0NNIiwidHlwIjoiSldUIiwiYWxnIjoiRUNESC1FUyIsImVwayI6eyJjcnYiOiJQLTI1NiIsIngiOiIxdVc4VlAxVzhDazZ6dERIMWRjYnk3NzRfVXU4X1RvalNKZEJSMVpRaFRNIiwieSI6InBGRG1KZDJXTS1jZGcxVHdMR0FkaldUSURrRW1xc2lmMWJfV0tKMWRWSnciLCJrdHkiOiJFQyJ9fQ..zhhYytTdGNvPajvU.j-Edyx9DpIdHGrCYiH20cjLKORhw95bXBJSEQPVjDe7wRfYFUvfch43X4HI3fKYSxIWgjIACM3ynqQwu7Ta3cQ.3PDSOt-SdNyCEqYRD8P0hA
String jwteCompact = jwte.toCompact();
</code></pre>
                    <blockquote>
                        <p>By default, the JWT service creates <code>JWSBuilder</code> and <code>JWEBuilder</code> for building JWT with <code>JWTClaimsSet</code> payload type, in order to obtain builders for custom <code>JWTClaimsSet</code> types, the type must be explicitly specified when creating the builder.</p>
                    </blockquote>
                    <h5 id="reading-jwt">Reading JWT</h5>
                    <p>The <code>JWTService</code> bean exposes <code>jwsReader()</code> and <code>jweReader()</code> methods used to obtain specific <code>JWSReader</code> or <code>JWEReader</code> for reading JWT as <code>JWS</code> or <code>JWE</code> with <code>JWTClaimsSet</code> payloads. The builders thus obtained follow the exact same rules as defined by the <a href="#jws-service">JWS service</a> and the <a href="#jwe-service">JWE service</a> with the following exceptions: the type (<code>typ</code>) must be <code>JWT</code> and no content type (<code>cty</code>) is allowed. A <code>JWTReadException</code> is thrown when a type other than <code>JWT</code> or a content type are specified in the JOSE header.</p>
                    <p>The following example shows how to read a JWT as a <code>JWS</code>:</p>
                    <pre><code class="language-java">// Injected or obtained from a 'Jose' instance
JWKService jwkService = ...
JWTService jwtService = ...

Mono&lt;? extends OCTJWK&gt; key = jwkService.oct().builder()
    .keyId("keyId")
    .algorithm(OCTAlgorithm.HS256.getAlgorithm())
    .keyValue("xqf1haCsSJGuueZivcq4YafdWw6n5CH2BTT6vDwUSaM")
    .build()
    .cache();

String jwtsCompact = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9."
    + "eyJpc3MiOiJqb2UiLCJleHAiOjE2OTExMzMyMTMsImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ."
    + "4p0_3W8DBrjTpw2e2KI1__v-6QOT_5dWIMKbfsSvTo0";

JWTClaimsSet validClaims = jwtService.jwsReader(key)
    .read(jwtsCompact)
    .map(JWS::getPayload)
    .filter(JWTClaimsSet::isValid)
    .block();
</code></pre>
                    <p>The following example shows how to read a JWT as a <code>JWE</code>:</p>
                    <pre><code class="language-java">// Injected or obtained from a 'Jose' instance
JWKService jwkService = ...
JWTService jwtService = ...

Mono&lt;? extends ECJWK&gt; key = jwkService.ec().builder()
    .keyId("keyId")
    .algorithm(ECAlgorithm.ECDH_ES.getAlgorithm())
    .curve(ECCurve.P_256.getCurve())
    .xCoordinate("a9HrKi7kwXR0EumziK_B5ZRlsk7QbXGPJfx_c3OGoZs")
    .yCoordinate("fixJ3kr2abu0huetFyhs0OMqd3_M6xMIKE8hr3FggOM")
    .eccPrivateKey("VCSeZseVoZ1E4TyWmRqD0nt5I_ipSbKfXcRHQSTPqUw")
    .build()
    .cache();

// The encrypted key is empty since ECDH_ES is a direct key agreement
jwteCompact = "eyJlbmMiOiJBMjU2R0NNIiwidHlwIjoiSldUIiwiYWxnIjoiRUNESC1FUyIsImVwayI6eyJjcnYiOiJQLTI1NiIsIngiOiJ6bEczQzVwUEtZVG4yVHpiZlJZYm5KOTZTai0yNDJGeTlwVVRmUWN0MUlzIiwieSI6IkUyeE9hNnNlb0dJVHpkRHdxVjZlT2NIc2dzNmI2M082NlJVWXlsV2N6LTgiLCJrdHkiOiJFQyJ9fQ."
        + "."
        + "_1eQRi8ukFZDwa27."
        + "WjPLHYGHu1zpg3QSbhB9ciraoRU7UXpeJJXz76UZAkwJ-rxEXwkimnflTnEymG_oK1i7hKwCANRhqWwr22GqNg."
        + "Zos43NFBxdh_brO1ae-7vA";

JWTClaimsSet validClaims = jwtService.jweReader(key)
    .read(jwteCompact)
    .map(JWE::getPayload)
    .filter(JWTClaimsSet::isValid)
    .block();
</code></pre>
                    <blockquote>
                        <p>By default, the JWT service creates <code>JWSReader</code> and <code>JWEReader</code> for reading JWT with <code>JWTClaimsSet</code> payload type, in order to obtain readers for custom <code>JWTClaimsSet</code> types, the type must be explicitly specified when creating the reader.</p>
                    </blockquote>
                    <h4 id="jose-media-type-converters">JOSE Media Type Converters</h4>
                    <p>The module also exposes a set of <code>MediaTypeConverter&lt;String&gt;</code> for converting JOSE media types as defined by <a href="https://datatracker.ietf.org/doc/html/rfc7515">RFC 7515 Section 9.2</a>, <a href="https://datatracker.ietf.org/doc/html/rfc7517">RFC 7517 Section 8.5</a> and <a href="https://datatracker.ietf.org/doc/html/rfc7519">RFC 7519 Section 10.3</a>. It currently supports: <code>application/jose</code>, <code>application/jose+json</code>, <code>application/jwk+json</code>, <code>application/jwk-set+json</code> and <code>application/jwt</code>.</p>
                    <p>JOSE media type converters are basically used to convert JWK, JWS, JWE or JWT serialized using the compact or the JSON notation. They rely on the module's services to decode an input into corresponding JOSE object (<code>JWK</code>, <code>JWS</code>, <code>JWE</code> or <code>JWT</code>), as a result a JWS or a JWE are verified and decrypted by the converters which throw <code>ConverterException</code> in case of invalid inputs. In the specific case of a JWT, the validation of the decoded <code>JWTClaimsSet</code> is not performed and left to the application.</p>
                    <p>These media types converters are also used by module services when converting JOSE payloads. It is then possible to wrap any JOSE object in a <code>JWS</code> or a <code>JWE</code> using compact or JSON serialization. A typical use cases consist in wrapping a <code>JWK</code> or a <code>JWKSet</code> in a <code>JWE</code> to securely communicate keys.</p>
                    <p>The following example shows how to create a <code>JWE</code> conveying multiple <code>JWK</code>:</p>
                    <pre><code class="language-java">// Injected or obtained from a 'Jose' instance
JWKService jwkService = ...
JWEService jweService = ...

OCTJWK key1 = jwkService.oct().builder()
    .keyId("key1")
    .algorithm(OCTAlgorithm.A256GCMKW.getAlgorithm())
    .keyValue("GkilETj3L4jpinuRiaNq6zd7-_1JPbfU9DY3xHl9HEE")
    .build()
    .block();

OCTJWK key2 = jwkService.oct().builder()
    .keyId("key2")
    .algorithm(OCTAlgorithm.HS256.getAlgorithm())
    .keyValue("xqf1haCsSJGuueZivcq4YafdWw6n5CH2BTT6vDwUSaM")
    .build()
    .block();

JWKSet jwkSet = new JWKSet(key1, key2);

Mono&lt;? extends ECJWK&gt; key = jwkService.ec().builder()
    .keyId("keyId")
    .algorithm(ECAlgorithm.ECDH_ES.getAlgorithm())
    .curve(ECCurve.P_256.getCurve())
    .xCoordinate("a9HrKi7kwXR0EumziK_B5ZRlsk7QbXGPJfx_c3OGoZs")
    .yCoordinate("fixJ3kr2abu0huetFyhs0OMqd3_M6xMIKE8hr3FggOM")
    .eccPrivateKey("VCSeZseVoZ1E4TyWmRqD0nt5I_ipSbKfXcRHQSTPqUw")
    .build()
    .cache();

JWE&lt;JWKSet&gt; jwe = jweService.builder(JWKSet.class, key)
    .header(header -&gt; header
        .algorithm(ECAlgorithm.ECDH_ES.getAlgorithm())
        .encryptionAlgorithm(OCTAlgorithm.A128GCM.getAlgorithm())
        .contentType(MediaTypes.APPLICATION_JWK_SET_JSON)
    )
    .payload(jwkSet)
    .build()
    .block();

// eyJlbmMiOiJBMTI4R0NNIiwiY3R5IjoiYXBwbGljYXRpb24vandrLXNldCtqc29uIiwiYWxnIjoiRUNESC1FUyIsImVwayI6eyJjcnYiOiJQLTI1NiIsIngiOiJPcW5NbjBKcDNQcGZ6VlFCQW1ZanU2MVEwWUNkUHJuMkI3eW5ZdlRLN3FJIiwieSI6ImhZXzI2am9tS1QzX2QzaGQ2VVNRSm1zSjV5blBtaDN5QmRkZVdHbEs5ZDgiLCJrdHkiOiJFQyJ9fQ..XvpO0GyH44d8GeWc.5aV-epA4DaoWAD84EyYqFnaFv2HtQJlNF33jwSIuxHaMG0nK1Cm6yKcdzzC4e1pG1FNY7wg9SI_JlkFDYqjp6EuMe64vFUOiPCj28QtPaafEx7jOt5nbGNRvzBZJdDWQbhlZomXL7cKzLjfYpv8Y4SWPzcua6FJMSH7DoZwUZfKZDzDk_-2fpXvE_LLw7rTbi8Vltm9AClzmy2QS1tu5R4hY5E9Ew5QIWC06IErtldHF_y_oZIy7iSxf55GjgBVs0roFkA.OujlTScT9qOM6wWsFJMUlA
String jweCompact = jwe.toCompact();
</code></pre>
                    <p>The resulting compact JWE containing encrypted keys can then be conveyed to a recipient which can decrypt the keys with the shared secret key.</p>
                    <pre><code class="language-java">// Injected or obtained from a 'Jose' instance
JWEService jweService = ...

jweCompact = "eyJlbmMiOiJBMTI4R0NNIiwiY3R5IjoiYXBwbGljYXRpb24vandrLXNldCtqc29uIiwiYWxnIjoiRUNESC1FUyIsImVwayI6eyJjcnYiOiJQLTI1NiIsIngiOiJPcW5NbjBKcDNQcGZ6VlFCQW1ZanU2MVEwWUNkUHJuMkI3eW5ZdlRLN3FJIiwieSI6ImhZXzI2am9tS1QzX2QzaGQ2VVNRSm1zSjV5blBtaDN5QmRkZVdHbEs5ZDgiLCJrdHkiOiJFQyJ9fQ."
    + "."
    + "XvpO0GyH44d8GeWc."
    + "5aV-epA4DaoWAD84EyYqFnaFv2HtQJlNF33jwSIuxHaMG0nK1Cm6yKcdzzC4e1pG1FNY7wg9SI_JlkFDYqjp6EuMe64vFUOiPCj28QtPaafEx7jOt5nbGNRvzBZJdDWQbhlZomXL7cKzLjfYpv8Y4SWPzcua6FJMSH7DoZwUZfKZDzDk_-2fpXvE_LLw7rTbi8Vltm9AClzmy2QS1tu5R4hY5E9Ew5QIWC06IErtldHF_y_oZIy7iSxf55GjgBVs0roFkA."
    + "OujlTScT9qOM6wWsFJMUlA";

jwkSet = jweService.reader(JWKSet.class, key)
    .read(jweCompact)
    .map(JWE::getPayload)
    .block();
</code></pre>
                    <p>The following example shows how to wrap a received <code>JWS</code> in a <code>JWE</code> in order to add confidentiality protection:</p>
                    <pre><code class="language-java">// Injected or obtained from a 'Jose' instance
JWKService jwkService = null;
JWSService jwsService = null;
JWEService jweService = null;

jwkService.oct().builder()
    .keyId("jwsKey")
    .algorithm(OCTAlgorithm.HS256.getAlgorithm())
    .keyValue("xqf1haCsSJGuueZivcq4YafdWw6n5CH2BTT6vDwUSaM")
    .build()
    .map(JWK::trust)
    .flatMap(jwkService.store()::set)
    .block();

jwkService.oct().builder()
    .keyId("jweKey")
    .algorithm(OCTAlgorithm.A256GCMKW.getAlgorithm())
    .keyValue("GkilETj3L4jpinuRiaNq6zd7-_1JPbfU9DY3xHl9HEE")
    .build()
    .map(JWK::trust)
    .flatMap(jwkService.store()::set)
    .block();

String jwsCompact = "eyJhbGciOiJIUzI1NiIsImtpZCI6Imp3c0tleSIsImN0eSI6ImFwcGxpY2F0aW9uL2pzb24ifQ."
    + "eyJhdXRob3IiOiJNYXJjZWwiLCJtZXNzYWdlIjoiRmluYWxseSEifQ."
    + "wjnBucCNvQXHtL8QBWuXbutRECtIhazISQhR0NfYOQs";

JWS&lt;Message&gt; block = jwsService.reader(Message.class)
    .read(jwsCompact)
    .block();

JWE&lt;JWS&lt;Message&gt;&gt; jwe = jwsService.reader(Message.class)
    .read(jwsCompact)
    .flatMap(jws -&gt; jweService.&lt;JWS&lt;Message&gt;&gt;builder(Types.type(JWS.class).type(Message.class).and().build())
        .header(header -&gt; header
            .keyId("jweKey")
            .algorithm(OCTAlgorithm.A256GCMKW.getAlgorithm())
            .encryptionAlgorithm(OCTAlgorithm.A128CBC_HS256.getAlgorithm())
            .contentType(MediaTypes.APPLICATION_JOSE)
        )
        .payload(jws)
        .build()
    )
    .block();

// eyJlbmMiOiJBMTI4Q0JDLUhTMjU2IiwiYWxnIjoiQTI1NkdDTUtXIiwia2lkIjoiandlS2V5IiwiY3R5IjoiYXBwbGljYXRpb24vam9zZSIsInRhZyI6IlBjT2tjZWNsNUswaW92a2hnMEhwUEEiLCJpdiI6InFNMUtfeHhIcmZocXFuRFMifQ.LLn2scpDiAdRRSFIrvTXTXsVwQp9mSH4dPv1I-IruFM.LfCNkDe5r3eE2Kjadmpkww.5AjCbDExRhRsLy-iXX2RAavfXVWFEcinKcXu3t_BObnC4mzgxmaqvfwUC8QMu8KM8C3gjt36Qa89nqajVYmJwRrZ0ZMoH68JgXvp2npIEdJSruL3CqTHm3ObK5-7TbYLP1K3t9v995wOIAajUsXaHfpNODqAsFlc83A6wwxv37WVq4mWy-WZ7ZwIpwHY5semqMxv0FbpNMPtkLaG0JzqYLnzH7yaT2DSBQKIxlCZ0hc.ZML3thQjah7dtXdv17LJXA
String jweCompact = jwe.toCompact();
</code></pre>
                    <p>In above example, we choose to store the <code>jwsKey</code> and <code>jweKey</code> in the module's <code>JWKStore</code>, although we could have specified keys explicitly to read the JWS and build the JWE, converters can only rely on key resolution based on the JOSE header parameters and as a result a recipient which would like to decode above compact JWE must make sure keys can be resolved using the <code>JWKStore</code>, the <code>JWKKeyResolver</code> or the <code>JWKURLResolver</code>.</p>
                    <pre><code class="language-java">// Injected or obtained from a 'Jose' instance
JWSService jwsService = null;
JWEService jweService = null;

jweCompact = "eyJlbmMiOiJBMTI4Q0JDLUhTMjU2IiwiYWxnIjoiQTI1NkdDTUtXIiwia2lkIjoiandlS2V5IiwiY3R5IjoiYXBwbGljYXRpb24vam9zZSIsInRhZyI6IlBjT2tjZWNsNUswaW92a2hnMEhwUEEiLCJpdiI6InFNMUtfeHhIcmZocXFuRFMifQ."
    + "LLn2scpDiAdRRSFIrvTXTXsVwQp9mSH4dPv1I-IruFM."
    + "LfCNkDe5r3eE2Kjadmpkww."
    + "5AjCbDExRhRsLy-iXX2RAavfXVWFEcinKcXu3t_BObnC4mzgxmaqvfwUC8QMu8KM8C3gjt36Qa89nqajVYmJwRrZ0ZMoH68JgXvp2npIEdJSruL3CqTHm3ObK5-7TbYLP1K3t9v995wOIAajUsXaHfpNODqAsFlc83A6wwxv37WVq4mWy-WZ7ZwIpwHY5semqMxv0FbpNMPtkLaG0JzqYLnzH7yaT2DSBQKIxlCZ0hc."
    + "ZML3thQjah7dtXdv17LJXA";

/// Here we assume keys 'jwsKey' and 'jweKey' can be resolved by the 'JWSService' and the 'JWEService'

// Marcel says Finally!
Message message = jweService.&lt;JWS&lt;Message&gt;&gt;reader(Types.type(JWS.class).type(Message.class).and().build())
    .read(jweCompact)
    .map(JWE::getPayload)
    .map(JWS::getPayload)
    .block();
</code></pre>
                    <h2 id="inverno-maven-plugin-1">Inverno Maven Plugin</h2>
                    <p>The Inverno Maven Plugin is used to run, package and distribute modular applications and Inverno applications in particular. It relies on a set of Java tools to build native runtime or application images as well as Docker or OCI images for modular Java projects.</p>
                    <h3 id="usage">Usage</h3>
                    <p>The Inverno Maven plugin can be used to run a modular application project or build an image for a modular project. There are three types of images that can be build using the plugin:</p>
                    <ul>
                        <li><strong>runtime image</strong> is a custom Java runtime containing a set of modules and their dependencies.</li>
                        <li><strong>application image</strong> is a native self-contained Java application including all the necessary dependencies to run the application without the need of a Java runtime.</li>
                        <li><strong>container image</strong> is a Docker or CLI container image that can be packaged as a TAR archive or directly deployed on a Docker daemon or container registry.</li>
                    </ul>
                    <h4 id="run-a-module-application-project">Run a module application project</h4>
                    <p>The <code>inverno:run</code> goal is used to execute the modular application defined in the project from the command line.</p>
                    <pre><code class="language-plaintext">$ mvn inverno:run
</code></pre>
                    <p>The application is first <em>modularized</em> which means that any non-modular dependency is modularized by generating an appropriate module descriptor using the <code>jdeps</code> tool in order for the application to be run with a module path and not a class path (and certainly not both).</p>
                    <p>The application is executed in a forked process, application arguments can be passed on the command line:</p>
                    <pre><code class="language-plaintext">$ mvn inverno:run -Dinverno.run.arguments='--some.configuration=\"hello\"'
</code></pre>
                    <blockquote>
                        <p>Actual arguments are determined by splitting the parameter value around spaces. There are several options to declare an argument which contains spaces:</p>
                        <ul>
                            <li>it can be escaped: <code>Hello\ World</code></li>
                            <li>it can be quoted: <code>"Hello World"</code> or <code>'Hello World'</code></li>
                        </ul>
                        <p>Since quotes or double quotes are used as delimiters, they might need to be escaped as well to declare an argument that contains some: <code>I\'m\ happy</code>, <code>"I'm happy"</code>, <code>'I\'m happy'</code>.</p>
                    </blockquote>
                    <p>In order to debug the application, we need to specify the appropriate options to the JVM:</p>
                    <pre><code class="language-plaintext">$ mvn inverno:run -Dinverno.exec.vmOptions="-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000"
</code></pre>
                    <p>By default the plugin will detect the main class of the application, but it is also possible to specify it explicitly in case multiple main classes exist in the project module.</p>
                    <pre><code class="language-plaintext">$ mvn inverno:run -Dinverno.exec.mainClass=io.inverno.example.Main
</code></pre>
                    <p>A pidfile is created when the application is started under <code>${project.build.directory}/maven-inverno</code> directory, it indicates the pid of the process running the application. If the build exits while the application is still running or if the pidfile was not properly removed after the application has exited, it might be necessary to manually kill the process and/or remove the pidfile.</p>
                    <h4 id="start-and-stop-the-application-for-integration-testing">Start and stop the application for integration testing</h4>
                    <p>The <code>inverno:start</code> and <code>inverno:stop</code> goals are used together to start and stop the application while not blocking the Maven build process which can then execute other goals targeting the running application such as integration tests.</p>
                    <p>They are bound to the <code>pre-integration-test</code> and <code>pre-integration-test</code> phases respectively:</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;io.inverno.tool&lt;/groupId&gt;
                &lt;artifactId&gt;inverno-maven-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;start&lt;/id&gt;
                        &lt;phase&gt;pre-integration-test&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;start&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                    &lt;execution&gt;
                        &lt;id&gt;stop&lt;/id&gt;
                        &lt;phase&gt;post-integration-test&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;stop&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
                    <h4 id="build-a-runtime-image">Build a runtime image</h4>
                    <p>A runtime image is a custom Java runtime distribution containing specific modules and their dependencies. Such image is used as a base for generating application image but it can also be distributed as a lightweight Java runtime.</p>
                    <p>The <code>inverno:build-runtime</code> goal uses <code>jlink</code> tool to assemble the project module and its dependencies.</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;io.inverno.tool&lt;/groupId&gt;
                &lt;artifactId&gt;inverno-maven-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;build-project-runtime&lt;/id&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;build-runtime&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;vm&gt;server&lt;/vm&gt;
                            &lt;addModules&gt;jdk.jdwp.agent,jdk.crypto.ec&lt;/addModules&gt;
                            &lt;vmOptions&gt;-Xms2G -Xmx2G -XX:+UseNUMA -XX:+UseParallelGC&lt;/vmOptions&gt;
                            &lt;formats&gt;
                                &lt;format&gt;zip&lt;/format&gt;
                                &lt;format&gt;tar.gz&lt;/format&gt;
                                &lt;format&gt;tar.bz2&lt;/format&gt;
                            &lt;/formats&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
                    <p>By default, the project module and its dependencies are included in the resulting image, this include JDK's modules such as <code>java.base</code>, in the previous example we've also explicitly added the <code>jdk.jdwp.agent</code> to support remote debugging and <code>jdk.crypto.ec</code> to support TLS communications.</p>
                    <p>The resulting image is packaged to the formats defined in the configuration and attached, by default, to the Maven project.</p>
                    <h4 id="build-an-application-image">Build an application image</h4>
                    <p>An application image is built using the <code>inverno:build-app</code> goal which basically generates a runtime image and uses <code>jpackage</code> tool to generate a native platform-specific application package.</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;io.inverno.tool&lt;/groupId&gt;
                &lt;artifactId&gt;inverno-maven-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;build-application&lt;/id&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;build-app&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;vm&gt;server&lt;/vm&gt;
                            &lt;addModules&gt;jdk.jdwp.agent,jdk.crypto.ec&lt;/addModules&gt;
                            &lt;launchers&gt;
                                &lt;launcher&gt;
                                    &lt;name&gt;app&lt;/name&gt;
                                    &lt;vmOptions&gt;-Xms2G -Xmx2G -XX:+UseNUMA -XX:+UseParallelGC&lt;/vmOptions&gt;
                                &lt;/launcher&gt;
                            &lt;/launchers&gt;
                            &lt;formats&gt;
                                &lt;format&gt;zip&lt;/format&gt;
                                &lt;format&gt;deb&lt;/format&gt;
                            &lt;/formats&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
                    <p>The <code>inverno:build-app</code> goal is very similar to the <code>inverno:build-runtime</code> goal except that the resulting image provides an application launcher and it can be packaged in a platform-specific format. For instance, we can generate a <code>.deb</code> on a Linux platform or a <code>.exe</code> or <code>.msi</code> on a Windows platform or a <code>.dmg</code> on a MacOS platform. The resulting package can be installed on these platforms in a standard way.</p>
                    <blockquote>
                        <p>This goal uses <code>jpackage</code> tool which is an incubating feature in JDK&lt;16, if you intend to build an application image with an old JDK, you'll need to explicitly add the <code>jdk.incubator.jpackage</code> module in <code>MAVEN_OPTS</code>:</p>
                        <pre><code class="language-plaintext">$ export MAVEN_OPTS="--add-modules jdk.incubator.jpackage"
</code></pre>
                    </blockquote>
                    <h4 id="build-a-container-image-tarball">Build a container image tarball</h4>
                    <p>A container image can be built in a TAR archive using the <code>inverno:build-image-tar</code> goal which basically build an application package and package it in a container image.</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;io.inverno.tool&lt;/groupId&gt;
                &lt;artifactId&gt;inverno-maven-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;build-image-tar&lt;/id&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;build-image-tar&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;vm&gt;server&lt;/vm&gt;
                            &lt;addModules&gt;jdk.jdwp.agent,jdk.crypto.ec&lt;/addModules&gt;
                            &lt;executable&gt;app&lt;/executable&gt;
                            &lt;launchers&gt;
                                &lt;launcher&gt;
                                    &lt;name&gt;app&lt;/name&gt;
                                    &lt;vmOptions&gt;-Xms2G -Xmx2G -XX:+UseNUMA -XX:+UseParallelGC&lt;/vmOptions&gt;
                                &lt;/launcher&gt;
                            &lt;/launchers&gt;
                            &lt;repository&gt;example&lt;/repository&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
                    <p>The resulting image reference is defined by <code>${registry}/${repository}/${name}:${project.version}</code>, the registry and the repository are optional and the name default to the project artifact id.</p>
                    <p>The resulting image can then be loaded in a docker daemon:</p>
                    <pre><code class="language-plaintext">$ docker load --input target/example-1.0.0-SNAPSHOT-container_linux_amd64.tar
</code></pre>
                    <blockquote>
                        <p>As for <code>build-app</code> goal, this goal uses <code>jpackage</code> tool so if you intend to use a JDK&lt;16 you'll need to explicitly add the <code>jdk.incubator.jpackage</code> module in <code>MAVEN_OPTS</code>:</p>
                        <pre><code class="language-plaintext">$ export MAVEN_OPTS="--add-modules jdk.incubator.jpackage"
</code></pre>
                    </blockquote>
                    <h4 id="build-and-deploy-a-container-image-to-a-docker-daemon">Build and deploy a container image to a Docker daemon</h4>
                    <p>The <code>inverno:build-image-docker</code> goal is used to build a container image and deploy it to a Docker daemon using the Docker CLI.</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;io.inverno.tool&lt;/groupId&gt;
                &lt;artifactId&gt;inverno-maven-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;build-image-docker&lt;/id&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;build-image-docker&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;vm&gt;server&lt;/vm&gt;
                            &lt;addModules&gt;jdk.jdwp.agent,jdk.crypto.ec&lt;/addModules&gt;
                            &lt;executable&gt;app&lt;/executable&gt;
                            &lt;launchers&gt;
                                &lt;launcher&gt;
                                    &lt;name&gt;app&lt;/name&gt;
                                    &lt;vmOptions&gt;-Xms2G -Xmx2G -XX:+UseNUMA -XX:+UseParallelGC&lt;/vmOptions&gt;
                                &lt;/launcher&gt;
                            &lt;/launchers&gt;
                            &lt;repository&gt;example&lt;/repository&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
                    <p>By default the <code>docker</code> command is used but it is possible to specify the path to the Docker CLI in the <code>inverno.container.docker.executable</code> parameter.</p>
                    <blockquote>
                        <p>As for <code>build-app</code> goal, this goal uses <code>jpackage</code> tool so if you intend to use a JDK&lt;16 you'll need to explicitly add the <code>jdk.incubator.jpackage</code> module in <code>MAVEN_OPTS</code>:</p>
                        <pre><code class="language-plaintext">$ export MAVEN_OPTS="--add-modules jdk.incubator.jpackage"
</code></pre>
                    </blockquote>
                    <h4 id="build-and-deploy-a-container-image-to-a-remote-repository">Build and deploy a container image to a remote repository</h4>
                    <p>The <code>inverno:build-image</code> goal builds a container image and deploy it to a remote repository.</p>
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;io.inverno.tool&lt;/groupId&gt;
                &lt;artifactId&gt;inverno-maven-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;build-image-docker&lt;/id&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;build-image-docker&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;vm&gt;server&lt;/vm&gt;
                            &lt;addModules&gt;jdk.jdwp.agent,jdk.crypto.ec&lt;/addModules&gt;
                            &lt;executable&gt;app&lt;/executable&gt;
                            &lt;launchers&gt;
                                &lt;launcher&gt;
                                    &lt;name&gt;app&lt;/name&gt;
                                    &lt;vmOptions&gt;-Xms2G -Xmx2G -XX:+UseNUMA -XX:+UseParallelGC&lt;/vmOptions&gt;
                                &lt;/launcher&gt;
                            &lt;/launchers&gt;
                            &lt;registryUsername&gt;user&lt;/registryUsername&gt;
                            &lt;registryPassword&gt;password&lt;/registryPassword&gt;
                            &lt;registry&gt;gcr.io&lt;/registry&gt;
                            &lt;repository&gt;example&lt;/repository&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
                    <p>By default the registry points to the Docker hub <code>registry-1.docker.io</code> but another registry can be specified, <code>gcr.io</code> in our example.</p>
                    <blockquote>
                        <p>As for <code>build-app</code> goal, this goal uses <code>jpackage</code> tool so if you intend to use a JDK&lt;16 you'll need to explicitly add the <code>jdk.incubator.jpackage</code> module in <code>MAVEN_OPTS</code>:</p>
                        <pre><code class="language-plaintext">$ export MAVEN_OPTS="--add-modules jdk.incubator.jpackage"
</code></pre>
                    </blockquote>
                    <h3 id="goals">Goals</h3>
                    <h4 id="overview-3">Overview</h4>
                    <ul>
                        <li><a href="#invernobuild-app">inverno:build-app</a> Builds the project application package.</li>
                        <li><a href="#invernobuild-image">inverno:build-image</a> Builds a container image and publishes it to a registry.</li>
                        <li><a href="#invernobuild-image-docker">inverno:build-image-docker</a> Builds a Docker container image to a local Docker daemon.</li>
                        <li><a href="#invernobuild-image-tar">inverno:build-image-tar</a> Builds a container image to a TAR archive that can be later loaded into Docker:</li>
                        <li><a href="#invernobuild-runtime">inverno:build-runtime</a> Builds the project runtime image.</li>
                        <li><a href="#invernohelp">inverno:help</a> Display help information on inverno-maven-plugin.</li>
                        <li><a href="#invernorun">inverno:run</a> Runs the project application.</li>
                        <li><a href="#invernostart">inverno:start</a> Starts the project application without blocking the Maven build.</li>
                        <li><a href="#invernostop">inverno:stop</a> Stops the project application that has been previously started using the start goal.</li>
                    </ul>
                    <h4 id="invernobuild-app">inverno:build-app</h4>
                    <p><strong>Full name:</strong></p>
                    <p>io.inverno.tool:inverno-maven-plugin:1.3.1:build-app</p>
                    <p><strong>Description:</strong></p>
                    <p>Builds the project application package.</p>
                    <p>A project application package is a native self-contained Java application including all the necessary dependencies. It can be used to distribute a complete application.</p>
                    <p><strong>Attributes:</strong></p>
                    <ul>
                        <li>Requires a Maven project to be executed.</li>
                        <li>Requires dependency resolution of artifacts in scope: compile+runtime.</li>
                        <li>Requires dependency collection of artifacts in scope: compile+runtime.</li>
                        <li>Since version: 1.0.</li>
                        <li>Binds by default to the lifecycle phase: package.</li>
                    </ul>
                    <h5 id="required-parameters">Required parameters</h5>
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered ">
                            <tbody>
                              <tr>
                              <th>Name</th>
                              <th>Type</th>
                              <th>Description</th>
                              </tr>
                              <tr>
                              <td><a href="#attach">attach</a></td>
                              <td>boolean</td>
                              <td>Attach the resulting image archives to the project to install them in the local Maven repository and deploy them to remote repositories. 
                              <ul>
                              <li><em>User property</em> : inverno.image.attach</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#formats">formats</a></td>
                              <td>Set</td>
                              <td>A list of archive formats to generate (eg. zip, tar.gz...) 
                              <ul>
                              <li><em>Default</em> : zip</li>
                              </ul></td>
                              </tr>
                            </tbody>
                        </table>
                    </div>
                    <h5 id="optional-parameters">Optional parameters</h5>
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered ">
                            <tbody>
                              <tr>
                              <th>Name</th>
                              <th>Type</th>
                              <th>Description</th>
                              </tr>
                              <tr>
                              <td><a href="#addModules">addModules</a></td>
                              <td>String</td>
                              <td>The modules to add to the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.addModules</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#addOptions">addOptions</a></td>
                              <td>String</td>
                              <td>The options to prepend before any other options when invoking the JVM in the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.addOptions</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#automaticLaunchers">automaticLaunchers</a></td>
                              <td>boolean</td>
                              <td>Enables the automatic generation of launchers based on the main classes extracted from the application module. If enabled, a launcher is generated for all main classes other than the main launcher. 
                              <ul>
                              <li><em>User property</em> : inverno.app.automaticLaunchers</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#bindServices">bindServices</a></td>
                              <td>boolean</td>
                              <td>Link in service provider modules and their dependencies. 
                              <ul>
                              <li><em>User property</em> : inverno.image.bindServices</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#compress">compress</a></td>
                              <td>String</td>
                              <td>The compress level of the resulting image: 0=No compression, 1=constant string sharing, 2=ZIP. 
                              <ul>
                              <li><em>User property</em> : inverno.image.compress</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#configurationDirectory">configurationDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing user-editable configuration files that will be copied to the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.configurationDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/main/conf/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#copyright">copyright</a></td>
                              <td>String</td>
                              <td>The application copyright. 
                              <ul>
                              <li><em>User property</em> : inverno.app.copyright</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#description">description</a></td>
                              <td>String</td>
                              <td>The description of the application. 
                              <ul>
                              <li><em>User property</em> : inverno.app.description</li>
                              <li><em>Default</em> : ${project.description}</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#excludeArtifactIds">excludeArtifactIds</a></td>
                              <td>String</td>
                              <td>Comma separated list of Artifact names to exclude. 
                              <ul>
                              <li><em>User property</em> : inverno.image.excludeArtifactIds</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#excludeClassifiers">excludeClassifiers</a></td>
                              <td>String</td>
                              <td>Comma Separated list of Classifiers to exclude. Empty String indicates don't exclude anything (default). 
                              <ul>
                              <li><em>User property</em> : excludeClassifiers</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#excludeGroupIds">excludeGroupIds</a></td>
                              <td>String</td>
                              <td>Comma separated list of GroupId Names to exclude. 
                              <ul>
                              <li><em>User property</em> : inverno.image.excludeGroupIds</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#excludeScope">excludeScope</a></td>
                              <td>String</td>
                              <td>Scope to exclude. An Empty string indicates no scopes (default). 
                              <ul>
                              <li><em>User property</em> : inverno.image.excludeScope</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#ignoreSigningInformation">ignoreSigningInformation</a></td>
                              <td>boolean</td>
                              <td>Suppress a fatal error when signed modular JARs are linked in the image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.ignoreSigningInformation</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#includeArtifactIds">includeArtifactIds</a></td>
                              <td>String</td>
                              <td>Comma separated list of Artifact names to include. Empty String indicates include everything (default). 
                              <ul>
                              <li><em>User property</em> : inverno.image.includeArtifactIds</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#includeClassifiers">includeClassifiers</a></td>
                              <td>String</td>
                              <td>Comma Separated list of Classifiers to include. Empty String indicates include everything (default). 
                              <ul>
                              <li><em>User property</em> : inverno.image.includeClassifiers</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#includeGroupIds">includeGroupIds</a></td>
                              <td>String</td>
                              <td>Comma separated list of GroupIds to include. Empty String indicates include everything (default). 
                              <ul>
                              <li><em>User property</em> : inverno.image.includeGroupIds</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#includeScope">includeScope</a></td>
                              <td>String</td>
                              <td>Scope to include. An Empty string indicates all scopes (default). The scopes being interpreted are the scopes as Maven sees them, not as specified in the pom. In summary: 
                              <ul>
                              <li><em>User property</em> : inverno.image.includeScope</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#installDirectory">installDirectory</a></td>
                              <td>String</td>
                              <td>Absolute path of the installation directory of the application on OS X or Linux. Relative sub-path of the installation location of the application such as 'Program Files' or 'AppData' on Windows. 
                              <ul>
                              <li><em>User property</em> : inverno.app.installDirectory</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#jmodsOverrideDirectory">jmodsOverrideDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated. 
                              <ul>
                              <li><em>User property</em> : inverno.image.jmodsOverrideDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/jmods/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#launchers">launchers</a></td>
                              <td>List</td>
                              <td>A list of extra launchers to include in the resulting application. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#legalDirectory">legalDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing legal notices that will be copied to the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.legalDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/main/legal/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#licenseFile">licenseFile</a></td>
                              <td>File</td>
                              <td>The path to the application license file. 
                              <ul>
                              <li><em>User property</em> : inverno.app.licenseFile</li>
                              <li><em>Default</em> : ${project.basedir}/LICENSE</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#linuxConfiguration">linuxConfiguration</a></td>
                              <td>LinuxConfiguration</td>
                              <td>Linux specific configuration. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#macOSConfiguration">macOSConfiguration</a></td>
                              <td>MacOSConfiguration</td>
                              <td>MacOS specific configuration. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#manDirectory">manDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing man pages that will be copied to the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.manDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/main/man/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#overWriteIfNewer">overWriteIfNewer</a></td>
                              <td>boolean</td>
                              <td>Overwrite dependencies that don't exist or are older than the source. 
                              <ul>
                              <li><em>User property</em> : inverno.image.overWriteIfNewer</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#projectMainClass">projectMainClass</a></td>
                              <td>String</td>
                              <td>The main class in the project module to use when building the project JMOD package. 
                              <ul>
                              <li><em>User property</em> : inverno.runtime.projectMainClass</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#resolveProjectMainClass">resolveProjectMainClass</a></td>
                              <td>boolean</td>
                              <td>Resolve the project main class when not specified explicitly. 
                              <ul>
                              <li><em>User property</em> : inverno.runtime.projectMainClass</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#resourceDirectory">resourceDirectory</a></td>
                              <td>File</td>
                              <td>The path to resources that override resulting package resources. 
                              <ul>
                              <li><em>User property</em> : inverno.app.resourceDirectory</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#skip">skip</a></td>
                              <td>boolean</td>
                              <td>Skips the generation of the application. 
                              <ul>
                              <li><em>User property</em> : inverno.app.skip</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#stripDebug">stripDebug</a></td>
                              <td>boolean</td>
                              <td>Strip debug information from the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.stripDebug</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#stripNativeCommands">stripNativeCommands</a></td>
                              <td>boolean</td>
                              <td>Strip native command (eg. java...) from the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.stripNativeCommands</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#vendor">vendor</a></td>
                              <td>String</td>
                              <td>The application vendor. 
                              <ul>
                              <li><em>User property</em> : inverno.app.vendor</li>
                              <li><em>Default</em> : ${project.organization.name}</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#verbose">verbose</a></td>
                              <td>boolean</td>
                              <td>Enables verbose logging. 
                              <ul>
                              <li><em>User property</em> : inverno.verbose</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#vm">vm</a></td>
                              <td>String</td>
                              <td>Select the HotSpot VM in the output image defined as: 'client' / 'server' / 'minimal' / 'all' 
                              <ul>
                              <li><em>User property</em> : inverno.image.vm</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#windowsConfiguration">windowsConfiguration</a></td>
                              <td>WindowsConfiguration</td>
                              <td>Windows specific configuration. 
                              <ul></ul></td>
                              </tr>
                            </tbody>
                        </table>
                    </div>
                    <h5 id="parameter-details">Parameter details</h5>
                    <h6 id="addmodules">&lt;addModules&gt;</h6>
                    <p>The modules to add to the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.addModules</li>
                    </ul>
                    <h6 id="addoptions">&lt;addOptions&gt;</h6>
                    <p>The options to prepend before any other options when invoking the JVM in the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.addOptions</li>
                    </ul>
                    <h6 id="attach">&lt;attach&gt;</h6>
                    <p>Attach the resulting image archives to the project to install them in the local Maven repository and deploy them to remote repositories.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: yes</li>
                        <li><strong>User property</strong>: inverno.image.attach</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="automaticlaunchers">&lt;automaticLaunchers&gt;</h6>
                    <p>Enables the automatic generation of launchers based on the main classes extracted from the application module. If enabled, a launcher is generated for all main classes other than the main launcher.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.automaticLaunchers</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="bindservices">&lt;bindServices&gt;</h6>
                    <p>Link in service provider modules and their dependencies.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.bindServices</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="compress">&lt;compress&gt;</h6>
                    <p>The compress level of the resulting image: 0=No compression, 1=constant string sharing, 2=ZIP.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.compress</li>
                    </ul>
                    <h6 id="configurationdirectory">&lt;configurationDirectory&gt;</h6>
                    <p>A directory containing user-editable configuration files that will be copied to the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.configurationDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/main/conf/</li>
                    </ul>
                    <h6 id="copyright">&lt;copyright&gt;</h6>
                    <p>The application copyright.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.copyright</li>
                    </ul>
                    <h6 id="description">&lt;description&gt;</h6>
                    <p>The description of the application.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.description</li>
                        <li><strong>Default</strong>: ${project.description}</li>
                    </ul>
                    <h6 id="excludeartifactids">&lt;excludeArtifactIds&gt;</h6>
                    <p>Comma separated list of Artifact names to exclude.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.excludeArtifactIds</li>
                    </ul>
                    <h6 id="excludeclassifiers">&lt;excludeClassifiers&gt;</h6>
                    <p>Comma Separated list of Classifiers to exclude. Empty String indicates don't exclude anything (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: excludeClassifiers</li>
                    </ul>
                    <h6 id="excludegroupids">&lt;excludeGroupIds&gt;</h6>
                    <p>Comma separated list of GroupId Names to exclude.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.excludeGroupIds</li>
                    </ul>
                    <h6 id="excludescope">&lt;excludeScope&gt;</h6>
                    <p>Scope to exclude. An Empty string indicates no scopes (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.excludeScope</li>
                    </ul>
                    <h6 id="formats">&lt;formats&gt;</h6>
                    <p>A list of archive formats to generate (eg. zip, tar.gz...)</p>
                    <ul>
                        <li><strong>Type</strong>: java.util.Set</li>
                        <li><strong>Required</strong>: yes</li>
                        <li><strong>Default</strong>: zip</li>
                    </ul>
                    <h6 id="ignoresigninginformation">&lt;ignoreSigningInformation&gt;</h6>
                    <p>Suppress a fatal error when signed modular JARs are linked in the image.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.ignoreSigningInformation</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="includeartifactids">&lt;includeArtifactIds&gt;</h6>
                    <p>Comma separated list of Artifact names to include. Empty String indicates include everything (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.includeArtifactIds</li>
                    </ul>
                    <h6 id="includeclassifiers">&lt;includeClassifiers&gt;</h6>
                    <p>Comma Separated list of Classifiers to include. Empty String indicates include everything (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.includeClassifiers</li>
                    </ul>
                    <h6 id="includegroupids">&lt;includeGroupIds&gt;</h6>
                    <p>Comma separated list of GroupIds to include. Empty String indicates include everything (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.includeGroupIds</li>
                    </ul>
                    <h6 id="includescope">&lt;includeScope&gt;</h6>
                    <p>Scope to include. An Empty string indicates all scopes (default). The scopes being interpreted are the scopes as Maven sees them, not as specified in the pom. In summary:</p>
                    <ul>
                        <li><p>runtime scope gives runtime and compile dependencies,</p></li>
                        <li><p>compile scope gives compile, provided, and system dependencies,</p></li>
                        <li><p>test (default) scope gives all dependencies,</p></li>
                        <li><p>provided scope just gives provided dependencies,</p></li>
                        <li><p>system scope just gives system dependencies.</p></li>
                        <li><p><strong>Type</strong>: java.lang.String</p></li>
                        <li><p><strong>Required</strong>: no</p></li>
                        <li><p><strong>User property</strong>: inverno.image.includeScope</p></li>
                    </ul>
                    <h6 id="installdirectory">&lt;installDirectory&gt;</h6>
                    <p>Absolute path of the installation directory of the application on OS X or Linux. Relative sub-path of the installation location of the application such as 'Program Files' or 'AppData' on Windows.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.installDirectory</li>
                    </ul>
                    <h6 id="jmodsoverridedirectory">&lt;jmodsOverrideDirectory&gt;</h6>
                    <p>A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.jmodsOverrideDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/jmods/</li>
                    </ul>
                    <h6 id="launchers">&lt;launchers&gt;</h6>
                    <p>A list of extra launchers to include in the resulting application.</p>
                    <ul>
                        <li><strong>Type</strong>: java.util.List</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="legaldirectory">&lt;legalDirectory&gt;</h6>
                    <p>A directory containing legal notices that will be copied to the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.legalDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/main/legal/</li>
                    </ul>
                    <h6 id="licensefile">&lt;licenseFile&gt;</h6>
                    <p>The path to the application license file.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.licenseFile</li>
                        <li><strong>Default</strong>: ${project.basedir}/LICENSE</li>
                    </ul>
                    <h6 id="linuxconfiguration">&lt;linuxConfiguration&gt;</h6>
                    <p>Linux specific configuration.</p>
                    <ul>
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$LinuxConfiguration</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="macosconfiguration">&lt;macOSConfiguration&gt;</h6>
                    <p>MacOS specific configuration.</p>
                    <ul>
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$MacOSConfiguration</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="mandirectory">&lt;manDirectory&gt;</h6>
                    <p>A directory containing man pages that will be copied to the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.manDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/main/man/</li>
                    </ul>
                    <h6 id="overwriteifnewer">&lt;overWriteIfNewer&gt;</h6>
                    <p>Overwrite dependencies that don't exist or are older than the source.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.overWriteIfNewer</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="projectmainclass">&lt;projectMainClass&gt;</h6>
                    <p>The main class in the project module to use when building the project JMOD package.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.runtime.projectMainClass</li>
                    </ul>
                    <h6 id="resolveprojectmainclass">&lt;resolveProjectMainClass&gt;</h6>
                    <p>Resolve the project main class when not specified explicitly.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.runtime.projectMainClass</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="resourcedirectory">&lt;resourceDirectory&gt;</h6>
                    <p>The path to resources that override resulting package resources.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.resourceDirectory</li>
                    </ul>
                    <h6 id="skip">&lt;skip&gt;</h6>
                    <p>Skips the generation of the application.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.skip</li>
                    </ul>
                    <h6 id="stripdebug">&lt;stripDebug&gt;</h6>
                    <p>Strip debug information from the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.stripDebug</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="stripnativecommands">&lt;stripNativeCommands&gt;</h6>
                    <p>Strip native command (eg. java...) from the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.stripNativeCommands</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="vendor">&lt;vendor&gt;</h6>
                    <p>The application vendor.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.vendor</li>
                        <li><strong>Default</strong>: ${project.organization.name}</li>
                    </ul>
                    <h6 id="verbose">&lt;verbose&gt;</h6>
                    <p>Enables verbose logging.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.verbose</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="vm">&lt;vm&gt;</h6>
                    <p>Select the HotSpot VM in the output image defined as: 'client' / 'server' / 'minimal' / 'all'</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.vm</li>
                    </ul>
                    <h6 id="windowsconfiguration">&lt;windowsConfiguration&gt;</h6>
                    <p>Windows specific configuration.</p>
                    <ul>
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$WindowsConfiguration</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h4 id="invernobuild-image">inverno:build-image</h4>
                    <p><strong>Full name:</strong></p>
                    <p>io.inverno.tool:inverno-maven-plugin:1.3.1:build-image</p>
                    <p><strong>Description:</strong></p>
                    <p>Builds a container image and publishes it to a registry.</p>
                    <p><strong>Attributes:</strong></p>
                    <ul>
                        <li>Requires a Maven project to be executed.</li>
                        <li>Requires dependency resolution of artifacts in scope: compile+runtime.</li>
                        <li>Requires dependency collection of artifacts in scope: compile+runtime.</li>
                        <li>Since version: 1.0.</li>
                        <li>Binds by default to the lifecycle phase: install.</li>
                    </ul>
                    <h5 id="required-parameters-1">Required parameters</h5>
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered ">
                            <tbody>
                              <tr>
                              <th>Name</th>
                              <th>Type</th>
                              <th>Description</th>
                              </tr>
                              <tr>
                              <td><a href="#attach1">attach</a></td>
                              <td>boolean</td>
                              <td>Attach the resulting image archives to the project to install them in the local Maven repository and deploy them to remote repositories. 
                              <ul>
                              <li><em>User property</em> : inverno.image.attach</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#executable">executable</a></td>
                              <td>String</td>
                              <td>The executable in the application image to use as image entry point. The specified name should correspond to a declared application image launchers or the project artifact id if no launcher was specified. 
                              <ul>
                              <li><em>User property</em> : inverno.app.executable</li>
                              <li><em>Default</em> : ${project.artifactId}</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#formats1">formats</a></td>
                              <td>Set</td>
                              <td>A list of archive formats to generate (eg. zip, tar.gz...) 
                              <ul>
                              <li><em>Default</em> : zip</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#from">from</a></td>
                              <td>String</td>
                              <td>The base container image. 
                              <ul>
                              <li><em>User property</em> : inverno.container.from</li>
                              <li><em>Default</em> : debian:buster-slim</li>
                              </ul></td>
                              </tr>
                            </tbody>
                        </table>
                    </div>
                    <h5 id="optional-parameters-1">Optional parameters</h5>
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered ">
                            <tbody>
                              <tr>
                              <th>Name</th>
                              <th>Type</th>
                              <th>Description</th>
                              </tr>
                              <tr>
                              <td><a href="#addModules1">addModules</a></td>
                              <td>String</td>
                              <td>The modules to add to the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.addModules</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#addOptions1">addOptions</a></td>
                              <td>String</td>
                              <td>The options to prepend before any other options when invoking the JVM in the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.addOptions</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#automaticLaunchers1">automaticLaunchers</a></td>
                              <td>boolean</td>
                              <td>Enables the automatic generation of launchers based on the main classes extracted from the application module. If enabled, a launcher is generated for all main classes other than the main launcher. 
                              <ul>
                              <li><em>User property</em> : inverno.app.automaticLaunchers</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#bindServices1">bindServices</a></td>
                              <td>boolean</td>
                              <td>Link in service provider modules and their dependencies. 
                              <ul>
                              <li><em>User property</em> : inverno.image.bindServices</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#compress1">compress</a></td>
                              <td>String</td>
                              <td>The compress level of the resulting image: 0=No compression, 1=constant string sharing, 2=ZIP. 
                              <ul>
                              <li><em>User property</em> : inverno.image.compress</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#configurationDirectory1">configurationDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing user-editable configuration files that will be copied to the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.configurationDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/main/conf/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#copyright1">copyright</a></td>
                              <td>String</td>
                              <td>The application copyright. 
                              <ul>
                              <li><em>User property</em> : inverno.app.copyright</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#description1">description</a></td>
                              <td>String</td>
                              <td>The description of the application. 
                              <ul>
                              <li><em>User property</em> : inverno.app.description</li>
                              <li><em>Default</em> : ${project.description}</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#environment">environment</a></td>
                              <td>Map</td>
                              <td>The container's environment variables. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#excludeArtifactIds1">excludeArtifactIds</a></td>
                              <td>String</td>
                              <td>Comma separated list of Artifact names to exclude. 
                              <ul>
                              <li><em>User property</em> : inverno.image.excludeArtifactIds</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#excludeClassifiers1">excludeClassifiers</a></td>
                              <td>String</td>
                              <td>Comma Separated list of Classifiers to exclude. Empty String indicates don't exclude anything (default). 
                              <ul>
                              <li><em>User property</em> : excludeClassifiers</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#excludeGroupIds1">excludeGroupIds</a></td>
                              <td>String</td>
                              <td>Comma separated list of GroupId Names to exclude. 
                              <ul>
                              <li><em>User property</em> : inverno.image.excludeGroupIds</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#excludeScope1">excludeScope</a></td>
                              <td>String</td>
                              <td>Scope to exclude. An Empty string indicates no scopes (default). 
                              <ul>
                              <li><em>User property</em> : inverno.image.excludeScope</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#ignoreSigningInformation1">ignoreSigningInformation</a></td>
                              <td>boolean</td>
                              <td>Suppress a fatal error when signed modular JARs are linked in the image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.ignoreSigningInformation</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#imageFormat">imageFormat</a></td>
                              <td>ImageFormat</td>
                              <td>The format of the container image. 
                              <ul>
                              <li><em>User property</em> : inverno.container.imageFormat</li>
                              <li><em>Default</em> : Docker</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#includeArtifactIds1">includeArtifactIds</a></td>
                              <td>String</td>
                              <td>Comma separated list of Artifact names to include. Empty String indicates include everything (default). 
                              <ul>
                              <li><em>User property</em> : inverno.image.includeArtifactIds</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#includeClassifiers1">includeClassifiers</a></td>
                              <td>String</td>
                              <td>Comma Separated list of Classifiers to include. Empty String indicates include everything (default). 
                              <ul>
                              <li><em>User property</em> : inverno.image.includeClassifiers</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#includeGroupIds1">includeGroupIds</a></td>
                              <td>String</td>
                              <td>Comma separated list of GroupIds to include. Empty String indicates include everything (default). 
                              <ul>
                              <li><em>User property</em> : inverno.image.includeGroupIds</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#includeScope1">includeScope</a></td>
                              <td>String</td>
                              <td>Scope to include. An Empty string indicates all scopes (default). The scopes being interpreted are the scopes as Maven sees them, not as specified in the pom. In summary: 
                              <ul>
                              <li><em>User property</em> : inverno.image.includeScope</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#installDirectory1">installDirectory</a></td>
                              <td>String</td>
                              <td>Absolute path of the installation directory of the application on OS X or Linux. Relative sub-path of the installation location of the application such as 'Program Files' or 'AppData' on Windows. 
                              <ul>
                              <li><em>User property</em> : inverno.app.installDirectory</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#jmodsOverrideDirectory1">jmodsOverrideDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated. 
                              <ul>
                              <li><em>User property</em> : inverno.image.jmodsOverrideDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/jmods/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#labels">labels</a></td>
                              <td>Map</td>
                              <td>The labels to apply to the container image. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#launchers1">launchers</a></td>
                              <td>List</td>
                              <td>A list of extra launchers to include in the resulting application. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#legalDirectory1">legalDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing legal notices that will be copied to the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.legalDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/main/legal/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#licenseFile1">licenseFile</a></td>
                              <td>File</td>
                              <td>The path to the application license file. 
                              <ul>
                              <li><em>User property</em> : inverno.app.licenseFile</li>
                              <li><em>Default</em> : ${project.basedir}/LICENSE</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#linuxConfiguration1">linuxConfiguration</a></td>
                              <td>LinuxConfiguration</td>
                              <td>Linux specific configuration. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#macOSConfiguration1">macOSConfiguration</a></td>
                              <td>MacOSConfiguration</td>
                              <td>MacOS specific configuration. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#manDirectory1">manDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing man pages that will be copied to the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.manDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/main/man/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#overWriteIfNewer1">overWriteIfNewer</a></td>
                              <td>boolean</td>
                              <td>Overwrite dependencies that don't exist or are older than the source. 
                              <ul>
                              <li><em>User property</em> : inverno.image.overWriteIfNewer</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#ports">ports</a></td>
                              <td>Set</td>
                              <td>The ports exposed by the container at runtime defined as: port_number [ '/' udp/tcp ] 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#projectMainClass1">projectMainClass</a></td>
                              <td>String</td>
                              <td>The main class in the project module to use when building the project JMOD package. 
                              <ul>
                              <li><em>User property</em> : inverno.runtime.projectMainClass</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#registry">registry</a></td>
                              <td>String</td>
                              <td>The registry part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version} 
                              <ul>
                              <li><em>User property</em> : inverno.container.registry</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#registryPassword">registryPassword</a></td>
                              <td>String</td>
                              <td>The password to use to authenticate to the registry. 
                              <ul>
                              <li><em>User property</em> : inverno.container.registry.password</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#registryUsername">registryUsername</a></td>
                              <td>String</td>
                              <td>The user name to use to authenticate to the registry. 
                              <ul>
                              <li><em>User property</em> : inverno.container.registry.username</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#repository">repository</a></td>
                              <td>String</td>
                              <td>The repository part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version} 
                              <ul>
                              <li><em>User property</em> : inverno.container.repository</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#resolveProjectMainClass1">resolveProjectMainClass</a></td>
                              <td>boolean</td>
                              <td>Resolve the project main class when not specified explicitly. 
                              <ul>
                              <li><em>User property</em> : inverno.runtime.projectMainClass</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#resourceDirectory1">resourceDirectory</a></td>
                              <td>File</td>
                              <td>The path to resources that override resulting package resources. 
                              <ul>
                              <li><em>User property</em> : inverno.app.resourceDirectory</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#skip1">skip</a></td>
                              <td>boolean</td>
                              <td>Skips the generation of the application. 
                              <ul>
                              <li><em>User property</em> : inverno.app.skip</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#stripDebug1">stripDebug</a></td>
                              <td>boolean</td>
                              <td>Strip debug information from the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.stripDebug</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#stripNativeCommands1">stripNativeCommands</a></td>
                              <td>boolean</td>
                              <td>Strip native command (eg. java...) from the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.stripNativeCommands</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#user">user</a></td>
                              <td>String</td>
                              <td>The user and group used to run the container defined as: user / uid [ ':' group / gid ] 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#vendor1">vendor</a></td>
                              <td>String</td>
                              <td>The application vendor. 
                              <ul>
                              <li><em>User property</em> : inverno.app.vendor</li>
                              <li><em>Default</em> : ${project.organization.name}</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#verbose1">verbose</a></td>
                              <td>boolean</td>
                              <td>Enables verbose logging. 
                              <ul>
                              <li><em>User property</em> : inverno.verbose</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#vm1">vm</a></td>
                              <td>String</td>
                              <td>Select the HotSpot VM in the output image defined as: 'client' / 'server' / 'minimal' / 'all' 
                              <ul>
                              <li><em>User property</em> : inverno.image.vm</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#volumes">volumes</a></td>
                              <td>Set</td>
                              <td>The container's mount points. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#windowsConfiguration1">windowsConfiguration</a></td>
                              <td>WindowsConfiguration</td>
                              <td>Windows specific configuration. 
                              <ul></ul></td>
                              </tr>
                            </tbody>
                        </table>
                    </div>
                    <h5 id="parameter-details-1">Parameter details</h5>
                    <h6 id="addmodules-1">&lt;addModules&gt;</h6>
                    <p>The modules to add to the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.addModules</li>
                    </ul>
                    <h6 id="addoptions-1">&lt;addOptions&gt;</h6>
                    <p>The options to prepend before any other options when invoking the JVM in the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.addOptions</li>
                    </ul>
                    <h6 id="attach-1">&lt;attach&gt;</h6>
                    <p>Attach the resulting image archives to the project to install them in the local Maven repository and deploy them to remote repositories.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: yes</li>
                        <li><strong>User property</strong>: inverno.image.attach</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="automaticlaunchers-1">&lt;automaticLaunchers&gt;</h6>
                    <p>Enables the automatic generation of launchers based on the main classes extracted from the application module. If enabled, a launcher is generated for all main classes other than the main launcher.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.automaticLaunchers</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="bindservices-1">&lt;bindServices&gt;</h6>
                    <p>Link in service provider modules and their dependencies.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.bindServices</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="compress-1">&lt;compress&gt;</h6>
                    <p>The compress level of the resulting image: 0=No compression, 1=constant string sharing, 2=ZIP.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.compress</li>
                    </ul>
                    <h6 id="configurationdirectory-1">&lt;configurationDirectory&gt;</h6>
                    <p>A directory containing user-editable configuration files that will be copied to the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.configurationDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/main/conf/</li>
                    </ul>
                    <h6 id="copyright-1">&lt;copyright&gt;</h6>
                    <p>The application copyright.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.copyright</li>
                    </ul>
                    <h6 id="description-1">&lt;description&gt;</h6>
                    <p>The description of the application.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.description</li>
                        <li><strong>Default</strong>: ${project.description}</li>
                    </ul>
                    <h6 id="environment">&lt;environment&gt;</h6>
                    <p>The container's environment variables.</p>
                    <ul>
                        <li><strong>Type</strong>: java.util.Map</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="excludeartifactids-1">&lt;excludeArtifactIds&gt;</h6>
                    <p>Comma separated list of Artifact names to exclude.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.excludeArtifactIds</li>
                    </ul>
                    <h6 id="excludeclassifiers-1">&lt;excludeClassifiers&gt;</h6>
                    <p>Comma Separated list of Classifiers to exclude. Empty String indicates don't exclude anything (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: excludeClassifiers</li>
                    </ul>
                    <h6 id="excludegroupids-1">&lt;excludeGroupIds&gt;</h6>
                    <p>Comma separated list of GroupId Names to exclude.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.excludeGroupIds</li>
                    </ul>
                    <h6 id="excludescope-1">&lt;excludeScope&gt;</h6>
                    <p>Scope to exclude. An Empty string indicates no scopes (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.excludeScope</li>
                    </ul>
                    <h6 id="executable">&lt;executable&gt;</h6>
                    <p>The executable in the application image to use as image entry point. The specified name should correspond to a declared application image launchers or the project artifact id if no launcher was specified.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: yes</li>
                        <li><strong>User property</strong>: inverno.app.executable</li>
                        <li><strong>Default</strong>: ${project.artifactId}</li>
                    </ul>
                    <h6 id="formats-1">&lt;formats&gt;</h6>
                    <p>A list of archive formats to generate (eg. zip, tar.gz...)</p>
                    <ul>
                        <li><strong>Type</strong>: java.util.Set</li>
                        <li><strong>Required</strong>: yes</li>
                        <li><strong>Default</strong>: zip</li>
                    </ul>
                    <h6 id="from">&lt;from&gt;</h6>
                    <p>The base container image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: yes</li>
                        <li><strong>User property</strong>: inverno.container.from</li>
                        <li><strong>Default</strong>: debian:buster-slim</li>
                    </ul>
                    <h6 id="ignoresigninginformation-1">&lt;ignoreSigningInformation&gt;</h6>
                    <p>Suppress a fatal error when signed modular JARs are linked in the image.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.ignoreSigningInformation</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="imageformat">&lt;imageFormat&gt;</h6>
                    <p>The format of the container image.</p>
                    <ul>
                        <li><strong>Type</strong>: com.google.cloud.tools.jib.api.buildplan.ImageFormat</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.container.imageFormat</li>
                        <li><strong>Default</strong>: Docker</li>
                    </ul>
                    <h6 id="includeartifactids-1">&lt;includeArtifactIds&gt;</h6>
                    <p>Comma separated list of Artifact names to include. Empty String indicates include everything (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.includeArtifactIds</li>
                    </ul>
                    <h6 id="includeclassifiers-1">&lt;includeClassifiers&gt;</h6>
                    <p>Comma Separated list of Classifiers to include. Empty String indicates include everything (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.includeClassifiers</li>
                    </ul>
                    <h6 id="includegroupids-1">&lt;includeGroupIds&gt;</h6>
                    <p>Comma separated list of GroupIds to include. Empty String indicates include everything (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.includeGroupIds</li>
                    </ul>
                    <h6 id="includescope-1">&lt;includeScope&gt;</h6>
                    <p>Scope to include. An Empty string indicates all scopes (default). The scopes being interpreted are the scopes as Maven sees them, not as specified in the pom. In summary:</p>
                    <ul>
                        <li><p>runtime scope gives runtime and compile dependencies,</p></li>
                        <li><p>compile scope gives compile, provided, and system dependencies,</p></li>
                        <li><p>test (default) scope gives all dependencies,</p></li>
                        <li><p>provided scope just gives provided dependencies,</p></li>
                        <li><p>system scope just gives system dependencies.</p></li>
                        <li><p><strong>Type</strong>: java.lang.String</p></li>
                        <li><p><strong>Required</strong>: no</p></li>
                        <li><p><strong>User property</strong>: inverno.image.includeScope</p></li>
                    </ul>
                    <h6 id="installdirectory-1">&lt;installDirectory&gt;</h6>
                    <p>Absolute path of the installation directory of the application on OS X or Linux. Relative sub-path of the installation location of the application such as 'Program Files' or 'AppData' on Windows.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.installDirectory</li>
                    </ul>
                    <h6 id="jmodsoverridedirectory-1">&lt;jmodsOverrideDirectory&gt;</h6>
                    <p>A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.jmodsOverrideDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/jmods/</li>
                    </ul>
                    <h6 id="labels">&lt;labels&gt;</h6>
                    <p>The labels to apply to the container image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.util.Map</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="launchers-1">&lt;launchers&gt;</h6>
                    <p>A list of extra launchers to include in the resulting application.</p>
                    <ul>
                        <li><strong>Type</strong>: java.util.List</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="legaldirectory-1">&lt;legalDirectory&gt;</h6>
                    <p>A directory containing legal notices that will be copied to the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.legalDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/main/legal/</li>
                    </ul>
                    <h6 id="licensefile-1">&lt;licenseFile&gt;</h6>
                    <p>The path to the application license file.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.licenseFile</li>
                        <li><strong>Default</strong>: ${project.basedir}/LICENSE</li>
                    </ul>
                    <h6 id="linuxconfiguration-1">&lt;linuxConfiguration&gt;</h6>
                    <p>Linux specific configuration.</p>
                    <ul>
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$LinuxConfiguration</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="macosconfiguration-1">&lt;macOSConfiguration&gt;</h6>
                    <p>MacOS specific configuration.</p>
                    <ul>
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$MacOSConfiguration</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="mandirectory-1">&lt;manDirectory&gt;</h6>
                    <p>A directory containing man pages that will be copied to the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.manDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/main/man/</li>
                    </ul>
                    <h6 id="overwriteifnewer-1">&lt;overWriteIfNewer&gt;</h6>
                    <p>Overwrite dependencies that don't exist or are older than the source.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.overWriteIfNewer</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="ports">&lt;ports&gt;</h6>
                    <p>The ports exposed by the container at runtime defined as: port_number [ '/' udp/tcp ]</p>
                    <ul>
                        <li><strong>Type</strong>: java.util.Set</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="projectmainclass-1">&lt;projectMainClass&gt;</h6>
                    <p>The main class in the project module to use when building the project JMOD package.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.runtime.projectMainClass</li>
                    </ul>
                    <h6 id="registry">&lt;registry&gt;</h6>
                    <p>The registry part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version}</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.container.registry</li>
                    </ul>
                    <h6 id="registrypassword">&lt;registryPassword&gt;</h6>
                    <p>The password to use to authenticate to the registry.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.container.registry.password</li>
                    </ul>
                    <h6 id="registryusername">&lt;registryUsername&gt;</h6>
                    <p>The user name to use to authenticate to the registry.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.container.registry.username</li>
                    </ul>
                    <h6 id="repository">&lt;repository&gt;</h6>
                    <p>The repository part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version}</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.container.repository</li>
                    </ul>
                    <h6 id="resolveprojectmainclass-1">&lt;resolveProjectMainClass&gt;</h6>
                    <p>Resolve the project main class when not specified explicitly.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.runtime.projectMainClass</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="resourcedirectory-1">&lt;resourceDirectory&gt;</h6>
                    <p>The path to resources that override resulting package resources.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.resourceDirectory</li>
                    </ul>
                    <h6 id="skip-1">&lt;skip&gt;</h6>
                    <p>Skips the generation of the application.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.skip</li>
                    </ul>
                    <h6 id="stripdebug-1">&lt;stripDebug&gt;</h6>
                    <p>Strip debug information from the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.stripDebug</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="stripnativecommands-1">&lt;stripNativeCommands&gt;</h6>
                    <p>Strip native command (eg. java...) from the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.stripNativeCommands</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="user">&lt;user&gt;</h6>
                    <p>The user and group used to run the container defined as: user / uid [ ':' group / gid ]</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="vendor-1">&lt;vendor&gt;</h6>
                    <p>The application vendor.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.vendor</li>
                        <li><strong>Default</strong>: ${project.organization.name}</li>
                    </ul>
                    <h6 id="verbose-1">&lt;verbose&gt;</h6>
                    <p>Enables verbose logging.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.verbose</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="vm-1">&lt;vm&gt;</h6>
                    <p>Select the HotSpot VM in the output image defined as: 'client' / 'server' / 'minimal' / 'all'</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.vm</li>
                    </ul>
                    <h6 id="volumes">&lt;volumes&gt;</h6>
                    <p>The container's mount points.</p>
                    <ul>
                        <li><strong>Type</strong>: java.util.Set</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="windowsconfiguration-1">&lt;windowsConfiguration&gt;</h6>
                    <p>Windows specific configuration.</p>
                    <ul>
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$WindowsConfiguration</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h4 id="invernobuild-image-docker">inverno:build-image-docker</h4>
                    <p><strong>Full name:</strong></p>
                    <p>io.inverno.tool:inverno-maven-plugin:1.3.1:build-image-docker</p>
                    <p><strong>Description:</strong></p>
                    <p>Builds a Docker container image to a local Docker daemon.</p>
                    <p><strong>Attributes:</strong></p>
                    <ul>
                        <li>Requires a Maven project to be executed.</li>
                        <li>Requires dependency resolution of artifacts in scope: compile+runtime.</li>
                        <li>Requires dependency collection of artifacts in scope: compile+runtime.</li>
                        <li>Since version: 1.0.</li>
                        <li>Binds by default to the lifecycle phase: install.</li>
                    </ul>
                    <h5 id="required-parameters-2">Required parameters</h5>
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered ">
                            <tbody>
                              <tr>
                              <th>Name</th>
                              <th>Type</th>
                              <th>Description</th>
                              </tr>
                              <tr>
                              <td><a href="#attach2">attach</a></td>
                              <td>boolean</td>
                              <td>Attach the resulting image archives to the project to install them in the local Maven repository and deploy them to remote repositories. 
                              <ul>
                              <li><em>User property</em> : inverno.image.attach</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#executable1">executable</a></td>
                              <td>String</td>
                              <td>The executable in the application image to use as image entry point. The specified name should correspond to a declared application image launchers or the project artifact id if no launcher was specified. 
                              <ul>
                              <li><em>User property</em> : inverno.app.executable</li>
                              <li><em>Default</em> : ${project.artifactId}</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#formats2">formats</a></td>
                              <td>Set</td>
                              <td>A list of archive formats to generate (eg. zip, tar.gz...) 
                              <ul>
                              <li><em>Default</em> : zip</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#from1">from</a></td>
                              <td>String</td>
                              <td>The base container image. 
                              <ul>
                              <li><em>User property</em> : inverno.container.from</li>
                              <li><em>Default</em> : debian:buster-slim</li>
                              </ul></td>
                              </tr>
                            </tbody>
                        </table>
                    </div>
                    <h5 id="optional-parameters-2">Optional parameters</h5>
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered ">
                            <tbody>
                              <tr>
                              <th>Name</th>
                              <th>Type</th>
                              <th>Description</th>
                              </tr>
                              <tr>
                              <td><a href="#addModules2">addModules</a></td>
                              <td>String</td>
                              <td>The modules to add to the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.addModules</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#addOptions2">addOptions</a></td>
                              <td>String</td>
                              <td>The options to prepend before any other options when invoking the JVM in the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.addOptions</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#automaticLaunchers2">automaticLaunchers</a></td>
                              <td>boolean</td>
                              <td>Enables the automatic generation of launchers based on the main classes extracted from the application module. If enabled, a launcher is generated for all main classes other than the main launcher. 
                              <ul>
                              <li><em>User property</em> : inverno.app.automaticLaunchers</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#bindServices2">bindServices</a></td>
                              <td>boolean</td>
                              <td>Link in service provider modules and their dependencies. 
                              <ul>
                              <li><em>User property</em> : inverno.image.bindServices</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#compress2">compress</a></td>
                              <td>String</td>
                              <td>The compress level of the resulting image: 0=No compression, 1=constant string sharing, 2=ZIP. 
                              <ul>
                              <li><em>User property</em> : inverno.image.compress</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#configurationDirectory2">configurationDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing user-editable configuration files that will be copied to the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.configurationDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/main/conf/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#copyright2">copyright</a></td>
                              <td>String</td>
                              <td>The application copyright. 
                              <ul>
                              <li><em>User property</em> : inverno.app.copyright</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#description2">description</a></td>
                              <td>String</td>
                              <td>The description of the application. 
                              <ul>
                              <li><em>User property</em> : inverno.app.description</li>
                              <li><em>Default</em> : ${project.description}</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#dockerEnvironment">dockerEnvironment</a></td>
                              <td>Map</td>
                              <td>The Docker environment variables used by the Docker CLI executable. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#dockerExecutable">dockerExecutable</a></td>
                              <td>File</td>
                              <td>The path to the Docker CLI executable used to load the image in the Docker daemon. 
                              <ul>
                              <li><em>User property</em> : inverno.container.docker.executable</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#environment1">environment</a></td>
                              <td>Map</td>
                              <td>The container's environment variables. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#excludeArtifactIds2">excludeArtifactIds</a></td>
                              <td>String</td>
                              <td>Comma separated list of Artifact names to exclude. 
                              <ul>
                              <li><em>User property</em> : inverno.image.excludeArtifactIds</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#excludeClassifiers2">excludeClassifiers</a></td>
                              <td>String</td>
                              <td>Comma Separated list of Classifiers to exclude. Empty String indicates don't exclude anything (default). 
                              <ul>
                              <li><em>User property</em> : excludeClassifiers</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#excludeGroupIds2">excludeGroupIds</a></td>
                              <td>String</td>
                              <td>Comma separated list of GroupId Names to exclude. 
                              <ul>
                              <li><em>User property</em> : inverno.image.excludeGroupIds</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#excludeScope2">excludeScope</a></td>
                              <td>String</td>
                              <td>Scope to exclude. An Empty string indicates no scopes (default). 
                              <ul>
                              <li><em>User property</em> : inverno.image.excludeScope</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#ignoreSigningInformation2">ignoreSigningInformation</a></td>
                              <td>boolean</td>
                              <td>Suppress a fatal error when signed modular JARs are linked in the image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.ignoreSigningInformation</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#imageFormat1">imageFormat</a></td>
                              <td>ImageFormat</td>
                              <td>The format of the container image. 
                              <ul>
                              <li><em>User property</em> : inverno.container.imageFormat</li>
                              <li><em>Default</em> : Docker</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#includeArtifactIds2">includeArtifactIds</a></td>
                              <td>String</td>
                              <td>Comma separated list of Artifact names to include. Empty String indicates include everything (default). 
                              <ul>
                              <li><em>User property</em> : inverno.image.includeArtifactIds</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#includeClassifiers2">includeClassifiers</a></td>
                              <td>String</td>
                              <td>Comma Separated list of Classifiers to include. Empty String indicates include everything (default). 
                              <ul>
                              <li><em>User property</em> : inverno.image.includeClassifiers</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#includeGroupIds2">includeGroupIds</a></td>
                              <td>String</td>
                              <td>Comma separated list of GroupIds to include. Empty String indicates include everything (default). 
                              <ul>
                              <li><em>User property</em> : inverno.image.includeGroupIds</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#includeScope2">includeScope</a></td>
                              <td>String</td>
                              <td>Scope to include. An Empty string indicates all scopes (default). The scopes being interpreted are the scopes as Maven sees them, not as specified in the pom. In summary: 
                              <ul>
                              <li><em>User property</em> : inverno.image.includeScope</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#installDirectory2">installDirectory</a></td>
                              <td>String</td>
                              <td>Absolute path of the installation directory of the application on OS X or Linux. Relative sub-path of the installation location of the application such as 'Program Files' or 'AppData' on Windows. 
                              <ul>
                              <li><em>User property</em> : inverno.app.installDirectory</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#jmodsOverrideDirectory2">jmodsOverrideDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated. 
                              <ul>
                              <li><em>User property</em> : inverno.image.jmodsOverrideDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/jmods/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#labels1">labels</a></td>
                              <td>Map</td>
                              <td>The labels to apply to the container image. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#launchers2">launchers</a></td>
                              <td>List</td>
                              <td>A list of extra launchers to include in the resulting application. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#legalDirectory2">legalDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing legal notices that will be copied to the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.legalDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/main/legal/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#licenseFile2">licenseFile</a></td>
                              <td>File</td>
                              <td>The path to the application license file. 
                              <ul>
                              <li><em>User property</em> : inverno.app.licenseFile</li>
                              <li><em>Default</em> : ${project.basedir}/LICENSE</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#linuxConfiguration2">linuxConfiguration</a></td>
                              <td>LinuxConfiguration</td>
                              <td>Linux specific configuration. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#macOSConfiguration2">macOSConfiguration</a></td>
                              <td>MacOSConfiguration</td>
                              <td>MacOS specific configuration. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#manDirectory2">manDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing man pages that will be copied to the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.manDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/main/man/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#overWriteIfNewer2">overWriteIfNewer</a></td>
                              <td>boolean</td>
                              <td>Overwrite dependencies that don't exist or are older than the source. 
                              <ul>
                              <li><em>User property</em> : inverno.image.overWriteIfNewer</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#ports1">ports</a></td>
                              <td>Set</td>
                              <td>The ports exposed by the container at runtime defined as: port_number [ '/' udp/tcp ] 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#projectMainClass2">projectMainClass</a></td>
                              <td>String</td>
                              <td>The main class in the project module to use when building the project JMOD package. 
                              <ul>
                              <li><em>User property</em> : inverno.runtime.projectMainClass</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#registry1">registry</a></td>
                              <td>String</td>
                              <td>The registry part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version} 
                              <ul>
                              <li><em>User property</em> : inverno.container.registry</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#repository1">repository</a></td>
                              <td>String</td>
                              <td>The repository part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version} 
                              <ul>
                              <li><em>User property</em> : inverno.container.repository</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#resolveProjectMainClass2">resolveProjectMainClass</a></td>
                              <td>boolean</td>
                              <td>Resolve the project main class when not specified explicitly. 
                              <ul>
                              <li><em>User property</em> : inverno.runtime.projectMainClass</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#resourceDirectory2">resourceDirectory</a></td>
                              <td>File</td>
                              <td>The path to resources that override resulting package resources. 
                              <ul>
                              <li><em>User property</em> : inverno.app.resourceDirectory</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#skip2">skip</a></td>
                              <td>boolean</td>
                              <td>Skips the generation of the application. 
                              <ul>
                              <li><em>User property</em> : inverno.app.skip</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#stripDebug2">stripDebug</a></td>
                              <td>boolean</td>
                              <td>Strip debug information from the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.stripDebug</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#stripNativeCommands2">stripNativeCommands</a></td>
                              <td>boolean</td>
                              <td>Strip native command (eg. java...) from the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.stripNativeCommands</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#user1">user</a></td>
                              <td>String</td>
                              <td>The user and group used to run the container defined as: user / uid [ ':' group / gid ] 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#vendor2">vendor</a></td>
                              <td>String</td>
                              <td>The application vendor. 
                              <ul>
                              <li><em>User property</em> : inverno.app.vendor</li>
                              <li><em>Default</em> : ${project.organization.name}</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#verbose2">verbose</a></td>
                              <td>boolean</td>
                              <td>Enables verbose logging. 
                              <ul>
                              <li><em>User property</em> : inverno.verbose</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#vm2">vm</a></td>
                              <td>String</td>
                              <td>Select the HotSpot VM in the output image defined as: 'client' / 'server' / 'minimal' / 'all' 
                              <ul>
                              <li><em>User property</em> : inverno.image.vm</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#volumes1">volumes</a></td>
                              <td>Set</td>
                              <td>The container's mount points. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#windowsConfiguration2">windowsConfiguration</a></td>
                              <td>WindowsConfiguration</td>
                              <td>Windows specific configuration. 
                              <ul></ul></td>
                              </tr>
                            </tbody>
                        </table>
                    </div>
                    <h5 id="parameter-details-2">Parameter details</h5>
                    <h6 id="addmodules-2">&lt;addModules&gt;</h6>
                    <p>The modules to add to the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.addModules</li>
                    </ul>
                    <h6 id="addoptions-2">&lt;addOptions&gt;</h6>
                    <p>The options to prepend before any other options when invoking the JVM in the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.addOptions</li>
                    </ul>
                    <h6 id="attach-2">&lt;attach&gt;</h6>
                    <p>Attach the resulting image archives to the project to install them in the local Maven repository and deploy them to remote repositories.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: yes</li>
                        <li><strong>User property</strong>: inverno.image.attach</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="automaticlaunchers-2">&lt;automaticLaunchers&gt;</h6>
                    <p>Enables the automatic generation of launchers based on the main classes extracted from the application module. If enabled, a launcher is generated for all main classes other than the main launcher.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.automaticLaunchers</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="bindservices-2">&lt;bindServices&gt;</h6>
                    <p>Link in service provider modules and their dependencies.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.bindServices</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="compress-2">&lt;compress&gt;</h6>
                    <p>The compress level of the resulting image: 0=No compression, 1=constant string sharing, 2=ZIP.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.compress</li>
                    </ul>
                    <h6 id="configurationdirectory-2">&lt;configurationDirectory&gt;</h6>
                    <p>A directory containing user-editable configuration files that will be copied to the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.configurationDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/main/conf/</li>
                    </ul>
                    <h6 id="copyright-2">&lt;copyright&gt;</h6>
                    <p>The application copyright.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.copyright</li>
                    </ul>
                    <h6 id="description-2">&lt;description&gt;</h6>
                    <p>The description of the application.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.description</li>
                        <li><strong>Default</strong>: ${project.description}</li>
                    </ul>
                    <h6 id="dockerenvironment">&lt;dockerEnvironment&gt;</h6>
                    <p>The Docker environment variables used by the Docker CLI executable.</p>
                    <ul>
                        <li><strong>Type</strong>: java.util.Map</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="dockerexecutable">&lt;dockerExecutable&gt;</h6>
                    <p>The path to the Docker CLI executable used to load the image in the Docker daemon.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.container.docker.executable</li>
                    </ul>
                    <h6 id="environment-1">&lt;environment&gt;</h6>
                    <p>The container's environment variables.</p>
                    <ul>
                        <li><strong>Type</strong>: java.util.Map</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="excludeartifactids-2">&lt;excludeArtifactIds&gt;</h6>
                    <p>Comma separated list of Artifact names to exclude.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.excludeArtifactIds</li>
                    </ul>
                    <h6 id="excludeclassifiers-2">&lt;excludeClassifiers&gt;</h6>
                    <p>Comma Separated list of Classifiers to exclude. Empty String indicates don't exclude anything (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: excludeClassifiers</li>
                    </ul>
                    <h6 id="excludegroupids-2">&lt;excludeGroupIds&gt;</h6>
                    <p>Comma separated list of GroupId Names to exclude.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.excludeGroupIds</li>
                    </ul>
                    <h6 id="excludescope-2">&lt;excludeScope&gt;</h6>
                    <p>Scope to exclude. An Empty string indicates no scopes (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.excludeScope</li>
                    </ul>
                    <h6 id="executable-1">&lt;executable&gt;</h6>
                    <p>The executable in the application image to use as image entry point. The specified name should correspond to a declared application image launchers or the project artifact id if no launcher was specified.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: yes</li>
                        <li><strong>User property</strong>: inverno.app.executable</li>
                        <li><strong>Default</strong>: ${project.artifactId}</li>
                    </ul>
                    <h6 id="formats-2">&lt;formats&gt;</h6>
                    <p>A list of archive formats to generate (eg. zip, tar.gz...)</p>
                    <ul>
                        <li><strong>Type</strong>: java.util.Set</li>
                        <li><strong>Required</strong>: yes</li>
                        <li><strong>Default</strong>: zip</li>
                    </ul>
                    <h6 id="from-1">&lt;from&gt;</h6>
                    <p>The base container image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: yes</li>
                        <li><strong>User property</strong>: inverno.container.from</li>
                        <li><strong>Default</strong>: debian:buster-slim</li>
                    </ul>
                    <h6 id="ignoresigninginformation-2">&lt;ignoreSigningInformation&gt;</h6>
                    <p>Suppress a fatal error when signed modular JARs are linked in the image.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.ignoreSigningInformation</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="imageformat-1">&lt;imageFormat&gt;</h6>
                    <p>The format of the container image.</p>
                    <ul>
                        <li><strong>Type</strong>: com.google.cloud.tools.jib.api.buildplan.ImageFormat</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.container.imageFormat</li>
                        <li><strong>Default</strong>: Docker</li>
                    </ul>
                    <h6 id="includeartifactids-2">&lt;includeArtifactIds&gt;</h6>
                    <p>Comma separated list of Artifact names to include. Empty String indicates include everything (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.includeArtifactIds</li>
                    </ul>
                    <h6 id="includeclassifiers-2">&lt;includeClassifiers&gt;</h6>
                    <p>Comma Separated list of Classifiers to include. Empty String indicates include everything (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.includeClassifiers</li>
                    </ul>
                    <h6 id="includegroupids-2">&lt;includeGroupIds&gt;</h6>
                    <p>Comma separated list of GroupIds to include. Empty String indicates include everything (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.includeGroupIds</li>
                    </ul>
                    <h6 id="includescope-2">&lt;includeScope&gt;</h6>
                    <p>Scope to include. An Empty string indicates all scopes (default). The scopes being interpreted are the scopes as Maven sees them, not as specified in the pom. In summary:</p>
                    <ul>
                        <li><p>runtime scope gives runtime and compile dependencies,</p></li>
                        <li><p>compile scope gives compile, provided, and system dependencies,</p></li>
                        <li><p>test (default) scope gives all dependencies,</p></li>
                        <li><p>provided scope just gives provided dependencies,</p></li>
                        <li><p>system scope just gives system dependencies.</p></li>
                        <li><p><strong>Type</strong>: java.lang.String</p></li>
                        <li><p><strong>Required</strong>: no</p></li>
                        <li><p><strong>User property</strong>: inverno.image.includeScope</p></li>
                    </ul>
                    <h6 id="installdirectory-2">&lt;installDirectory&gt;</h6>
                    <p>Absolute path of the installation directory of the application on OS X or Linux. Relative sub-path of the installation location of the application such as 'Program Files' or 'AppData' on Windows.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.installDirectory</li>
                    </ul>
                    <h6 id="jmodsoverridedirectory-2">&lt;jmodsOverrideDirectory&gt;</h6>
                    <p>A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.jmodsOverrideDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/jmods/</li>
                    </ul>
                    <h6 id="labels-1">&lt;labels&gt;</h6>
                    <p>The labels to apply to the container image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.util.Map</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="launchers-2">&lt;launchers&gt;</h6>
                    <p>A list of extra launchers to include in the resulting application.</p>
                    <ul>
                        <li><strong>Type</strong>: java.util.List</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="legaldirectory-2">&lt;legalDirectory&gt;</h6>
                    <p>A directory containing legal notices that will be copied to the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.legalDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/main/legal/</li>
                    </ul>
                    <h6 id="licensefile-2">&lt;licenseFile&gt;</h6>
                    <p>The path to the application license file.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.licenseFile</li>
                        <li><strong>Default</strong>: ${project.basedir}/LICENSE</li>
                    </ul>
                    <h6 id="linuxconfiguration-2">&lt;linuxConfiguration&gt;</h6>
                    <p>Linux specific configuration.</p>
                    <ul>
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$LinuxConfiguration</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="macosconfiguration-2">&lt;macOSConfiguration&gt;</h6>
                    <p>MacOS specific configuration.</p>
                    <ul>
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$MacOSConfiguration</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="mandirectory-2">&lt;manDirectory&gt;</h6>
                    <p>A directory containing man pages that will be copied to the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.manDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/main/man/</li>
                    </ul>
                    <h6 id="overwriteifnewer-2">&lt;overWriteIfNewer&gt;</h6>
                    <p>Overwrite dependencies that don't exist or are older than the source.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.overWriteIfNewer</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="ports-1">&lt;ports&gt;</h6>
                    <p>The ports exposed by the container at runtime defined as: port_number [ '/' udp/tcp ]</p>
                    <ul>
                        <li><strong>Type</strong>: java.util.Set</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="projectmainclass-2">&lt;projectMainClass&gt;</h6>
                    <p>The main class in the project module to use when building the project JMOD package.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.runtime.projectMainClass</li>
                    </ul>
                    <h6 id="registry-1">&lt;registry&gt;</h6>
                    <p>The registry part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version}</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.container.registry</li>
                    </ul>
                    <h6 id="repository-1">&lt;repository&gt;</h6>
                    <p>The repository part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version}</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.container.repository</li>
                    </ul>
                    <h6 id="resolveprojectmainclass-2">&lt;resolveProjectMainClass&gt;</h6>
                    <p>Resolve the project main class when not specified explicitly.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.runtime.projectMainClass</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="resourcedirectory-2">&lt;resourceDirectory&gt;</h6>
                    <p>The path to resources that override resulting package resources.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.resourceDirectory</li>
                    </ul>
                    <h6 id="skip-2">&lt;skip&gt;</h6>
                    <p>Skips the generation of the application.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.skip</li>
                    </ul>
                    <h6 id="stripdebug-2">&lt;stripDebug&gt;</h6>
                    <p>Strip debug information from the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.stripDebug</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="stripnativecommands-2">&lt;stripNativeCommands&gt;</h6>
                    <p>Strip native command (eg. java...) from the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.stripNativeCommands</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="user-1">&lt;user&gt;</h6>
                    <p>The user and group used to run the container defined as: user / uid [ ':' group / gid ]</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="vendor-2">&lt;vendor&gt;</h6>
                    <p>The application vendor.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.vendor</li>
                        <li><strong>Default</strong>: ${project.organization.name}</li>
                    </ul>
                    <h6 id="verbose-2">&lt;verbose&gt;</h6>
                    <p>Enables verbose logging.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.verbose</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="vm-2">&lt;vm&gt;</h6>
                    <p>Select the HotSpot VM in the output image defined as: 'client' / 'server' / 'minimal' / 'all'</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.vm</li>
                    </ul>
                    <h6 id="volumes-1">&lt;volumes&gt;</h6>
                    <p>The container's mount points.</p>
                    <ul>
                        <li><strong>Type</strong>: java.util.Set</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="windowsconfiguration-2">&lt;windowsConfiguration&gt;</h6>
                    <p>Windows specific configuration.</p>
                    <ul>
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$WindowsConfiguration</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h4 id="invernobuild-image-tar">inverno:build-image-tar</h4>
                    <p><strong>Full name:</strong></p>
                    <p>io.inverno.tool:inverno-maven-plugin:1.3.1:build-image-tar</p>
                    <p><strong>Description:</strong></p>
                    <p>Builds a container image to a TAR archive that can be later loaded into Docker:</p>
                    <p>$ docker load --input target/{@literal&lt;image&gt;.tar }</p>
                    <p><strong>Attributes:</strong></p>
                    <ul>
                        <li>Requires a Maven project to be executed.</li>
                        <li>Requires dependency resolution of artifacts in scope: compile+runtime.</li>
                        <li>Requires dependency collection of artifacts in scope: compile+runtime.</li>
                        <li>Since version: 1.0.</li>
                        <li>Binds by default to the lifecycle phase: package.</li>
                    </ul>
                    <h5 id="required-parameters-3">Required parameters</h5>
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered ">
                            <tbody>
                              <tr>
                              <th>Name</th>
                              <th>Type</th>
                              <th>Description</th>
                              </tr>
                              <tr>
                              <td><a href="#attach3">attach</a></td>
                              <td>boolean</td>
                              <td>Attach the resulting image archives to the project to install them in the local Maven repository and deploy them to remote repositories. 
                              <ul>
                              <li><em>User property</em> : inverno.image.attach</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#executable2">executable</a></td>
                              <td>String</td>
                              <td>The executable in the application image to use as image entry point. The specified name should correspond to a declared application image launchers or the project artifact id if no launcher was specified. 
                              <ul>
                              <li><em>User property</em> : inverno.app.executable</li>
                              <li><em>Default</em> : ${project.artifactId}</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#formats3">formats</a></td>
                              <td>Set</td>
                              <td>A list of archive formats to generate (eg. zip, tar.gz...) 
                              <ul>
                              <li><em>Default</em> : zip</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#from2">from</a></td>
                              <td>String</td>
                              <td>The base container image. 
                              <ul>
                              <li><em>User property</em> : inverno.container.from</li>
                              <li><em>Default</em> : debian:buster-slim</li>
                              </ul></td>
                              </tr>
                            </tbody>
                        </table>
                    </div>
                    <h5 id="optional-parameters-3">Optional parameters</h5>
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered ">
                            <tbody>
                              <tr>
                              <th>Name</th>
                              <th>Type</th>
                              <th>Description</th>
                              </tr>
                              <tr>
                              <td><a href="#addModules3">addModules</a></td>
                              <td>String</td>
                              <td>The modules to add to the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.addModules</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#addOptions3">addOptions</a></td>
                              <td>String</td>
                              <td>The options to prepend before any other options when invoking the JVM in the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.addOptions</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#automaticLaunchers3">automaticLaunchers</a></td>
                              <td>boolean</td>
                              <td>Enables the automatic generation of launchers based on the main classes extracted from the application module. If enabled, a launcher is generated for all main classes other than the main launcher. 
                              <ul>
                              <li><em>User property</em> : inverno.app.automaticLaunchers</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#bindServices3">bindServices</a></td>
                              <td>boolean</td>
                              <td>Link in service provider modules and their dependencies. 
                              <ul>
                              <li><em>User property</em> : inverno.image.bindServices</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#compress3">compress</a></td>
                              <td>String</td>
                              <td>The compress level of the resulting image: 0=No compression, 1=constant string sharing, 2=ZIP. 
                              <ul>
                              <li><em>User property</em> : inverno.image.compress</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#configurationDirectory3">configurationDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing user-editable configuration files that will be copied to the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.configurationDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/main/conf/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#copyright3">copyright</a></td>
                              <td>String</td>
                              <td>The application copyright. 
                              <ul>
                              <li><em>User property</em> : inverno.app.copyright</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#description3">description</a></td>
                              <td>String</td>
                              <td>The description of the application. 
                              <ul>
                              <li><em>User property</em> : inverno.app.description</li>
                              <li><em>Default</em> : ${project.description}</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#environment2">environment</a></td>
                              <td>Map</td>
                              <td>The container's environment variables. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#excludeArtifactIds3">excludeArtifactIds</a></td>
                              <td>String</td>
                              <td>Comma separated list of Artifact names to exclude. 
                              <ul>
                              <li><em>User property</em> : inverno.image.excludeArtifactIds</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#excludeClassifiers3">excludeClassifiers</a></td>
                              <td>String</td>
                              <td>Comma Separated list of Classifiers to exclude. Empty String indicates don't exclude anything (default). 
                              <ul>
                              <li><em>User property</em> : excludeClassifiers</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#excludeGroupIds3">excludeGroupIds</a></td>
                              <td>String</td>
                              <td>Comma separated list of GroupId Names to exclude. 
                              <ul>
                              <li><em>User property</em> : inverno.image.excludeGroupIds</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#excludeScope3">excludeScope</a></td>
                              <td>String</td>
                              <td>Scope to exclude. An Empty string indicates no scopes (default). 
                              <ul>
                              <li><em>User property</em> : inverno.image.excludeScope</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#ignoreSigningInformation3">ignoreSigningInformation</a></td>
                              <td>boolean</td>
                              <td>Suppress a fatal error when signed modular JARs are linked in the image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.ignoreSigningInformation</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#imageFormat2">imageFormat</a></td>
                              <td>ImageFormat</td>
                              <td>The format of the container image. 
                              <ul>
                              <li><em>User property</em> : inverno.container.imageFormat</li>
                              <li><em>Default</em> : Docker</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#includeArtifactIds3">includeArtifactIds</a></td>
                              <td>String</td>
                              <td>Comma separated list of Artifact names to include. Empty String indicates include everything (default). 
                              <ul>
                              <li><em>User property</em> : inverno.image.includeArtifactIds</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#includeClassifiers3">includeClassifiers</a></td>
                              <td>String</td>
                              <td>Comma Separated list of Classifiers to include. Empty String indicates include everything (default). 
                              <ul>
                              <li><em>User property</em> : inverno.image.includeClassifiers</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#includeGroupIds3">includeGroupIds</a></td>
                              <td>String</td>
                              <td>Comma separated list of GroupIds to include. Empty String indicates include everything (default). 
                              <ul>
                              <li><em>User property</em> : inverno.image.includeGroupIds</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#includeScope3">includeScope</a></td>
                              <td>String</td>
                              <td>Scope to include. An Empty string indicates all scopes (default). The scopes being interpreted are the scopes as Maven sees them, not as specified in the pom. In summary: 
                              <ul>
                              <li><em>User property</em> : inverno.image.includeScope</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#installDirectory3">installDirectory</a></td>
                              <td>String</td>
                              <td>Absolute path of the installation directory of the application on OS X or Linux. Relative sub-path of the installation location of the application such as 'Program Files' or 'AppData' on Windows. 
                              <ul>
                              <li><em>User property</em> : inverno.app.installDirectory</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#jmodsOverrideDirectory3">jmodsOverrideDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated. 
                              <ul>
                              <li><em>User property</em> : inverno.image.jmodsOverrideDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/jmods/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#labels2">labels</a></td>
                              <td>Map</td>
                              <td>The labels to apply to the container image. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#launchers3">launchers</a></td>
                              <td>List</td>
                              <td>A list of extra launchers to include in the resulting application. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#legalDirectory3">legalDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing legal notices that will be copied to the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.legalDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/main/legal/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#licenseFile3">licenseFile</a></td>
                              <td>File</td>
                              <td>The path to the application license file. 
                              <ul>
                              <li><em>User property</em> : inverno.app.licenseFile</li>
                              <li><em>Default</em> : ${project.basedir}/LICENSE</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#linuxConfiguration3">linuxConfiguration</a></td>
                              <td>LinuxConfiguration</td>
                              <td>Linux specific configuration. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#macOSConfiguration3">macOSConfiguration</a></td>
                              <td>MacOSConfiguration</td>
                              <td>MacOS specific configuration. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#manDirectory3">manDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing man pages that will be copied to the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.manDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/main/man/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#overWriteIfNewer3">overWriteIfNewer</a></td>
                              <td>boolean</td>
                              <td>Overwrite dependencies that don't exist or are older than the source. 
                              <ul>
                              <li><em>User property</em> : inverno.image.overWriteIfNewer</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#ports2">ports</a></td>
                              <td>Set</td>
                              <td>The ports exposed by the container at runtime defined as: port_number [ '/' udp/tcp ] 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#projectMainClass3">projectMainClass</a></td>
                              <td>String</td>
                              <td>The main class in the project module to use when building the project JMOD package. 
                              <ul>
                              <li><em>User property</em> : inverno.runtime.projectMainClass</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#registry2">registry</a></td>
                              <td>String</td>
                              <td>The registry part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version} 
                              <ul>
                              <li><em>User property</em> : inverno.container.registry</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#repository2">repository</a></td>
                              <td>String</td>
                              <td>The repository part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version} 
                              <ul>
                              <li><em>User property</em> : inverno.container.repository</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#resolveProjectMainClass3">resolveProjectMainClass</a></td>
                              <td>boolean</td>
                              <td>Resolve the project main class when not specified explicitly. 
                              <ul>
                              <li><em>User property</em> : inverno.runtime.projectMainClass</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#resourceDirectory3">resourceDirectory</a></td>
                              <td>File</td>
                              <td>The path to resources that override resulting package resources. 
                              <ul>
                              <li><em>User property</em> : inverno.app.resourceDirectory</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#skip3">skip</a></td>
                              <td>boolean</td>
                              <td>Skips the generation of the application. 
                              <ul>
                              <li><em>User property</em> : inverno.app.skip</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#stripDebug3">stripDebug</a></td>
                              <td>boolean</td>
                              <td>Strip debug information from the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.stripDebug</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#stripNativeCommands3">stripNativeCommands</a></td>
                              <td>boolean</td>
                              <td>Strip native command (eg. java...) from the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.stripNativeCommands</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#user2">user</a></td>
                              <td>String</td>
                              <td>The user and group used to run the container defined as: user / uid [ ':' group / gid ] 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#vendor3">vendor</a></td>
                              <td>String</td>
                              <td>The application vendor. 
                              <ul>
                              <li><em>User property</em> : inverno.app.vendor</li>
                              <li><em>Default</em> : ${project.organization.name}</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#verbose3">verbose</a></td>
                              <td>boolean</td>
                              <td>Enables verbose logging. 
                              <ul>
                              <li><em>User property</em> : inverno.verbose</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#vm3">vm</a></td>
                              <td>String</td>
                              <td>Select the HotSpot VM in the output image defined as: 'client' / 'server' / 'minimal' / 'all' 
                              <ul>
                              <li><em>User property</em> : inverno.image.vm</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#volumes2">volumes</a></td>
                              <td>Set</td>
                              <td>The container's mount points. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#windowsConfiguration3">windowsConfiguration</a></td>
                              <td>WindowsConfiguration</td>
                              <td>Windows specific configuration. 
                              <ul></ul></td>
                              </tr>
                            </tbody>
                        </table>
                    </div>
                    <h5 id="parameter-details-3">Parameter details</h5>
                    <h6 id="addmodules-3">&lt;addModules&gt;</h6>
                    <p>The modules to add to the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.addModules</li>
                    </ul>
                    <h6 id="addoptions-3">&lt;addOptions&gt;</h6>
                    <p>The options to prepend before any other options when invoking the JVM in the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.addOptions</li>
                    </ul>
                    <h6 id="attach-3">&lt;attach&gt;</h6>
                    <p>Attach the resulting image archives to the project to install them in the local Maven repository and deploy them to remote repositories.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: yes</li>
                        <li><strong>User property</strong>: inverno.image.attach</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="automaticlaunchers-3">&lt;automaticLaunchers&gt;</h6>
                    <p>Enables the automatic generation of launchers based on the main classes extracted from the application module. If enabled, a launcher is generated for all main classes other than the main launcher.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.automaticLaunchers</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="bindservices-3">&lt;bindServices&gt;</h6>
                    <p>Link in service provider modules and their dependencies.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.bindServices</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="compress-3">&lt;compress&gt;</h6>
                    <p>The compress level of the resulting image: 0=No compression, 1=constant string sharing, 2=ZIP.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.compress</li>
                    </ul>
                    <h6 id="configurationdirectory-3">&lt;configurationDirectory&gt;</h6>
                    <p>A directory containing user-editable configuration files that will be copied to the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.configurationDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/main/conf/</li>
                    </ul>
                    <h6 id="copyright-3">&lt;copyright&gt;</h6>
                    <p>The application copyright.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.copyright</li>
                    </ul>
                    <h6 id="description-3">&lt;description&gt;</h6>
                    <p>The description of the application.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.description</li>
                        <li><strong>Default</strong>: ${project.description}</li>
                    </ul>
                    <h6 id="environment-2">&lt;environment&gt;</h6>
                    <p>The container's environment variables.</p>
                    <ul>
                        <li><strong>Type</strong>: java.util.Map</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="excludeartifactids-3">&lt;excludeArtifactIds&gt;</h6>
                    <p>Comma separated list of Artifact names to exclude.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.excludeArtifactIds</li>
                    </ul>
                    <h6 id="excludeclassifiers-3">&lt;excludeClassifiers&gt;</h6>
                    <p>Comma Separated list of Classifiers to exclude. Empty String indicates don't exclude anything (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: excludeClassifiers</li>
                    </ul>
                    <h6 id="excludegroupids-3">&lt;excludeGroupIds&gt;</h6>
                    <p>Comma separated list of GroupId Names to exclude.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.excludeGroupIds</li>
                    </ul>
                    <h6 id="excludescope-3">&lt;excludeScope&gt;</h6>
                    <p>Scope to exclude. An Empty string indicates no scopes (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.excludeScope</li>
                    </ul>
                    <h6 id="executable-2">&lt;executable&gt;</h6>
                    <p>The executable in the application image to use as image entry point. The specified name should correspond to a declared application image launchers or the project artifact id if no launcher was specified.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: yes</li>
                        <li><strong>User property</strong>: inverno.app.executable</li>
                        <li><strong>Default</strong>: ${project.artifactId}</li>
                    </ul>
                    <h6 id="formats-3">&lt;formats&gt;</h6>
                    <p>A list of archive formats to generate (eg. zip, tar.gz...)</p>
                    <ul>
                        <li><strong>Type</strong>: java.util.Set</li>
                        <li><strong>Required</strong>: yes</li>
                        <li><strong>Default</strong>: zip</li>
                    </ul>
                    <h6 id="from-2">&lt;from&gt;</h6>
                    <p>The base container image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: yes</li>
                        <li><strong>User property</strong>: inverno.container.from</li>
                        <li><strong>Default</strong>: debian:buster-slim</li>
                    </ul>
                    <h6 id="ignoresigninginformation-3">&lt;ignoreSigningInformation&gt;</h6>
                    <p>Suppress a fatal error when signed modular JARs are linked in the image.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.ignoreSigningInformation</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="imageformat-2">&lt;imageFormat&gt;</h6>
                    <p>The format of the container image.</p>
                    <ul>
                        <li><strong>Type</strong>: com.google.cloud.tools.jib.api.buildplan.ImageFormat</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.container.imageFormat</li>
                        <li><strong>Default</strong>: Docker</li>
                    </ul>
                    <h6 id="includeartifactids-3">&lt;includeArtifactIds&gt;</h6>
                    <p>Comma separated list of Artifact names to include. Empty String indicates include everything (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.includeArtifactIds</li>
                    </ul>
                    <h6 id="includeclassifiers-3">&lt;includeClassifiers&gt;</h6>
                    <p>Comma Separated list of Classifiers to include. Empty String indicates include everything (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.includeClassifiers</li>
                    </ul>
                    <h6 id="includegroupids-3">&lt;includeGroupIds&gt;</h6>
                    <p>Comma separated list of GroupIds to include. Empty String indicates include everything (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.includeGroupIds</li>
                    </ul>
                    <h6 id="includescope-3">&lt;includeScope&gt;</h6>
                    <p>Scope to include. An Empty string indicates all scopes (default). The scopes being interpreted are the scopes as Maven sees them, not as specified in the pom. In summary:</p>
                    <ul>
                        <li><p>runtime scope gives runtime and compile dependencies,</p></li>
                        <li><p>compile scope gives compile, provided, and system dependencies,</p></li>
                        <li><p>test (default) scope gives all dependencies,</p></li>
                        <li><p>provided scope just gives provided dependencies,</p></li>
                        <li><p>system scope just gives system dependencies.</p></li>
                        <li><p><strong>Type</strong>: java.lang.String</p></li>
                        <li><p><strong>Required</strong>: no</p></li>
                        <li><p><strong>User property</strong>: inverno.image.includeScope</p></li>
                    </ul>
                    <h6 id="installdirectory-3">&lt;installDirectory&gt;</h6>
                    <p>Absolute path of the installation directory of the application on OS X or Linux. Relative sub-path of the installation location of the application such as 'Program Files' or 'AppData' on Windows.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.installDirectory</li>
                    </ul>
                    <h6 id="jmodsoverridedirectory-3">&lt;jmodsOverrideDirectory&gt;</h6>
                    <p>A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.jmodsOverrideDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/jmods/</li>
                    </ul>
                    <h6 id="labels-2">&lt;labels&gt;</h6>
                    <p>The labels to apply to the container image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.util.Map</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="launchers-3">&lt;launchers&gt;</h6>
                    <p>A list of extra launchers to include in the resulting application.</p>
                    <ul>
                        <li><strong>Type</strong>: java.util.List</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="legaldirectory-3">&lt;legalDirectory&gt;</h6>
                    <p>A directory containing legal notices that will be copied to the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.legalDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/main/legal/</li>
                    </ul>
                    <h6 id="licensefile-3">&lt;licenseFile&gt;</h6>
                    <p>The path to the application license file.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.licenseFile</li>
                        <li><strong>Default</strong>: ${project.basedir}/LICENSE</li>
                    </ul>
                    <h6 id="linuxconfiguration-3">&lt;linuxConfiguration&gt;</h6>
                    <p>Linux specific configuration.</p>
                    <ul>
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$LinuxConfiguration</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="macosconfiguration-3">&lt;macOSConfiguration&gt;</h6>
                    <p>MacOS specific configuration.</p>
                    <ul>
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$MacOSConfiguration</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="mandirectory-3">&lt;manDirectory&gt;</h6>
                    <p>A directory containing man pages that will be copied to the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.manDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/main/man/</li>
                    </ul>
                    <h6 id="overwriteifnewer-3">&lt;overWriteIfNewer&gt;</h6>
                    <p>Overwrite dependencies that don't exist or are older than the source.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.overWriteIfNewer</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="ports-2">&lt;ports&gt;</h6>
                    <p>The ports exposed by the container at runtime defined as: port_number [ '/' udp/tcp ]</p>
                    <ul>
                        <li><strong>Type</strong>: java.util.Set</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="projectmainclass-3">&lt;projectMainClass&gt;</h6>
                    <p>The main class in the project module to use when building the project JMOD package.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.runtime.projectMainClass</li>
                    </ul>
                    <h6 id="registry-2">&lt;registry&gt;</h6>
                    <p>The registry part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version}</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.container.registry</li>
                    </ul>
                    <h6 id="repository-2">&lt;repository&gt;</h6>
                    <p>The repository part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version}</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.container.repository</li>
                    </ul>
                    <h6 id="resolveprojectmainclass-3">&lt;resolveProjectMainClass&gt;</h6>
                    <p>Resolve the project main class when not specified explicitly.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.runtime.projectMainClass</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="resourcedirectory-3">&lt;resourceDirectory&gt;</h6>
                    <p>The path to resources that override resulting package resources.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.resourceDirectory</li>
                    </ul>
                    <h6 id="skip-3">&lt;skip&gt;</h6>
                    <p>Skips the generation of the application.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.skip</li>
                    </ul>
                    <h6 id="stripdebug-3">&lt;stripDebug&gt;</h6>
                    <p>Strip debug information from the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.stripDebug</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="stripnativecommands-3">&lt;stripNativeCommands&gt;</h6>
                    <p>Strip native command (eg. java...) from the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.stripNativeCommands</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="user-2">&lt;user&gt;</h6>
                    <p>The user and group used to run the container defined as: user / uid [ ':' group / gid ]</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="vendor-3">&lt;vendor&gt;</h6>
                    <p>The application vendor.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.app.vendor</li>
                        <li><strong>Default</strong>: ${project.organization.name}</li>
                    </ul>
                    <h6 id="verbose-3">&lt;verbose&gt;</h6>
                    <p>Enables verbose logging.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.verbose</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="vm-3">&lt;vm&gt;</h6>
                    <p>Select the HotSpot VM in the output image defined as: 'client' / 'server' / 'minimal' / 'all'</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.vm</li>
                    </ul>
                    <h6 id="volumes-2">&lt;volumes&gt;</h6>
                    <p>The container's mount points.</p>
                    <ul>
                        <li><strong>Type</strong>: java.util.Set</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="windowsconfiguration-3">&lt;windowsConfiguration&gt;</h6>
                    <p>Windows specific configuration.</p>
                    <ul>
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$WindowsConfiguration</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h4 id="invernobuild-runtime">inverno:build-runtime</h4>
                    <p><strong>Full name:</strong></p>
                    <p>io.inverno.tool:inverno-maven-plugin:1.3.1:build-runtime</p>
                    <p><strong>Description:</strong></p>
                    <p>Builds the project runtime image.</p>
                    <p>A runtime image is a custom Java runtime containing a set of modules and their dependencies.</p>
                    <p><strong>Attributes:</strong></p>
                    <ul>
                        <li>Requires a Maven project to be executed.</li>
                        <li>Requires dependency resolution of artifacts in scope: compile+runtime.</li>
                        <li>Requires dependency collection of artifacts in scope: compile+runtime.</li>
                        <li>Since version: 1.0.</li>
                        <li>Binds by default to the lifecycle phase: package.</li>
                    </ul>
                    <h5 id="required-parameters-4">Required parameters</h5>
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered ">
                            <tbody>
                              <tr>
                              <th>Name</th>
                              <th>Type</th>
                              <th>Description</th>
                              </tr>
                              <tr>
                              <td><a href="#attach4">attach</a></td>
                              <td>boolean</td>
                              <td>Attach the resulting image archives to the project to install them in the local Maven repository and deploy them to remote repositories. 
                              <ul>
                              <li><em>User property</em> : inverno.image.attach</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#formats4">formats</a></td>
                              <td>Set</td>
                              <td>A list of archive formats to generate (eg. zip, tar.gz...) 
                              <ul>
                              <li><em>Default</em> : zip</li>
                              </ul></td>
                              </tr>
                            </tbody>
                        </table>
                    </div>
                    <h5 id="optional-parameters-4">Optional parameters</h5>
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered ">
                            <tbody>
                              <tr>
                              <th>Name</th>
                              <th>Type</th>
                              <th>Description</th>
                              </tr>
                              <tr>
                              <td><a href="#addModules4">addModules</a></td>
                              <td>String</td>
                              <td>The modules to add to the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.addModules</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#addOptions4">addOptions</a></td>
                              <td>String</td>
                              <td>The options to prepend before any other options when invoking the JVM in the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.addOptions</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#bindServices4">bindServices</a></td>
                              <td>boolean</td>
                              <td>Link in service provider modules and their dependencies. 
                              <ul>
                              <li><em>User property</em> : inverno.image.bindServices</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#compress4">compress</a></td>
                              <td>String</td>
                              <td>The compress level of the resulting image: 0=No compression, 1=constant string sharing, 2=ZIP. 
                              <ul>
                              <li><em>User property</em> : inverno.image.compress</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#configurationDirectory4">configurationDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing user-editable configuration files that will be copied to the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.configurationDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/main/conf/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#excludeArtifactIds4">excludeArtifactIds</a></td>
                              <td>String</td>
                              <td>Comma separated list of Artifact names to exclude. 
                              <ul>
                              <li><em>User property</em> : inverno.image.excludeArtifactIds</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#excludeClassifiers4">excludeClassifiers</a></td>
                              <td>String</td>
                              <td>Comma Separated list of Classifiers to exclude. Empty String indicates don't exclude anything (default). 
                              <ul>
                              <li><em>User property</em> : excludeClassifiers</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#excludeGroupIds4">excludeGroupIds</a></td>
                              <td>String</td>
                              <td>Comma separated list of GroupId Names to exclude. 
                              <ul>
                              <li><em>User property</em> : inverno.image.excludeGroupIds</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#excludeScope4">excludeScope</a></td>
                              <td>String</td>
                              <td>Scope to exclude. An Empty string indicates no scopes (default). 
                              <ul>
                              <li><em>User property</em> : inverno.image.excludeScope</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#ignoreSigningInformation4">ignoreSigningInformation</a></td>
                              <td>boolean</td>
                              <td>Suppress a fatal error when signed modular JARs are linked in the image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.ignoreSigningInformation</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#includeArtifactIds4">includeArtifactIds</a></td>
                              <td>String</td>
                              <td>Comma separated list of Artifact names to include. Empty String indicates include everything (default). 
                              <ul>
                              <li><em>User property</em> : inverno.image.includeArtifactIds</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#includeClassifiers4">includeClassifiers</a></td>
                              <td>String</td>
                              <td>Comma Separated list of Classifiers to include. Empty String indicates include everything (default). 
                              <ul>
                              <li><em>User property</em> : inverno.image.includeClassifiers</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#includeGroupIds4">includeGroupIds</a></td>
                              <td>String</td>
                              <td>Comma separated list of GroupIds to include. Empty String indicates include everything (default). 
                              <ul>
                              <li><em>User property</em> : inverno.image.includeGroupIds</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#includeScope4">includeScope</a></td>
                              <td>String</td>
                              <td>Scope to include. An Empty string indicates all scopes (default). The scopes being interpreted are the scopes as Maven sees them, not as specified in the pom. In summary: 
                              <ul>
                              <li><em>User property</em> : inverno.image.includeScope</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#jmodsOverrideDirectory4">jmodsOverrideDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated. 
                              <ul>
                              <li><em>User property</em> : inverno.image.jmodsOverrideDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/jmods/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#launchers4">launchers</a></td>
                              <td>List</td>
                              <td>A list of launchers to include in the resulting runtime. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#legalDirectory4">legalDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing legal notices that will be copied to the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.legalDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/main/legal/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#manDirectory4">manDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing man pages that will be copied to the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.manDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/main/man/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#overWriteIfNewer4">overWriteIfNewer</a></td>
                              <td>boolean</td>
                              <td>Overwrite dependencies that don't exist or are older than the source. 
                              <ul>
                              <li><em>User property</em> : inverno.image.overWriteIfNewer</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#projectMainClass4">projectMainClass</a></td>
                              <td>String</td>
                              <td>The main class in the project module to use when building the project JMOD package. 
                              <ul>
                              <li><em>User property</em> : inverno.runtime.projectMainClass</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#resolveProjectMainClass4">resolveProjectMainClass</a></td>
                              <td>boolean</td>
                              <td>Resolve the project main class when not specified explicitly. 
                              <ul>
                              <li><em>User property</em> : inverno.runtime.projectMainClass</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#skip4">skip</a></td>
                              <td>boolean</td>
                              <td>Skips the generation of the runtime. 
                              <ul>
                              <li><em>User property</em> : inverno.runtime.skip</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#stripDebug4">stripDebug</a></td>
                              <td>boolean</td>
                              <td>Strip debug information from the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.stripDebug</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#stripNativeCommands4">stripNativeCommands</a></td>
                              <td>boolean</td>
                              <td>Strip native command (eg. java...) from the resulting image. 
                              <ul>
                              <li><em>User property</em> : inverno.image.stripNativeCommands</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#verbose4">verbose</a></td>
                              <td>boolean</td>
                              <td>Enables verbose logging. 
                              <ul>
                              <li><em>User property</em> : inverno.verbose</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#vm4">vm</a></td>
                              <td>String</td>
                              <td>Select the HotSpot VM in the output image defined as: 'client' / 'server' / 'minimal' / 'all' 
                              <ul>
                              <li><em>User property</em> : inverno.image.vm</li>
                              </ul></td>
                              </tr>
                            </tbody>
                        </table>
                    </div>
                    <h5 id="parameter-details-4">Parameter details</h5>
                    <h6 id="addmodules-4">&lt;addModules&gt;</h6>
                    <p>The modules to add to the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.addModules</li>
                    </ul>
                    <h6 id="addoptions-4">&lt;addOptions&gt;</h6>
                    <p>The options to prepend before any other options when invoking the JVM in the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.addOptions</li>
                    </ul>
                    <h6 id="attach-4">&lt;attach&gt;</h6>
                    <p>Attach the resulting image archives to the project to install them in the local Maven repository and deploy them to remote repositories.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: yes</li>
                        <li><strong>User property</strong>: inverno.image.attach</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="bindservices-4">&lt;bindServices&gt;</h6>
                    <p>Link in service provider modules and their dependencies.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.bindServices</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="compress-4">&lt;compress&gt;</h6>
                    <p>The compress level of the resulting image: 0=No compression, 1=constant string sharing, 2=ZIP.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.compress</li>
                    </ul>
                    <h6 id="configurationdirectory-4">&lt;configurationDirectory&gt;</h6>
                    <p>A directory containing user-editable configuration files that will be copied to the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.configurationDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/main/conf/</li>
                    </ul>
                    <h6 id="excludeartifactids-4">&lt;excludeArtifactIds&gt;</h6>
                    <p>Comma separated list of Artifact names to exclude.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.excludeArtifactIds</li>
                    </ul>
                    <h6 id="excludeclassifiers-4">&lt;excludeClassifiers&gt;</h6>
                    <p>Comma Separated list of Classifiers to exclude. Empty String indicates don't exclude anything (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: excludeClassifiers</li>
                    </ul>
                    <h6 id="excludegroupids-4">&lt;excludeGroupIds&gt;</h6>
                    <p>Comma separated list of GroupId Names to exclude.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.excludeGroupIds</li>
                    </ul>
                    <h6 id="excludescope-4">&lt;excludeScope&gt;</h6>
                    <p>Scope to exclude. An Empty string indicates no scopes (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.excludeScope</li>
                    </ul>
                    <h6 id="formats-4">&lt;formats&gt;</h6>
                    <p>A list of archive formats to generate (eg. zip, tar.gz...)</p>
                    <ul>
                        <li><strong>Type</strong>: java.util.Set</li>
                        <li><strong>Required</strong>: yes</li>
                        <li><strong>Default</strong>: zip</li>
                    </ul>
                    <h6 id="ignoresigninginformation-4">&lt;ignoreSigningInformation&gt;</h6>
                    <p>Suppress a fatal error when signed modular JARs are linked in the image.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.ignoreSigningInformation</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="includeartifactids-4">&lt;includeArtifactIds&gt;</h6>
                    <p>Comma separated list of Artifact names to include. Empty String indicates include everything (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.includeArtifactIds</li>
                    </ul>
                    <h6 id="includeclassifiers-4">&lt;includeClassifiers&gt;</h6>
                    <p>Comma Separated list of Classifiers to include. Empty String indicates include everything (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.includeClassifiers</li>
                    </ul>
                    <h6 id="includegroupids-4">&lt;includeGroupIds&gt;</h6>
                    <p>Comma separated list of GroupIds to include. Empty String indicates include everything (default).</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.includeGroupIds</li>
                    </ul>
                    <h6 id="includescope-4">&lt;includeScope&gt;</h6>
                    <p>Scope to include. An Empty string indicates all scopes (default). The scopes being interpreted are the scopes as Maven sees them, not as specified in the pom. In summary:</p>
                    <ul>
                        <li><p>runtime scope gives runtime and compile dependencies,</p></li>
                        <li><p>compile scope gives compile, provided, and system dependencies,</p></li>
                        <li><p>test (default) scope gives all dependencies,</p></li>
                        <li><p>provided scope just gives provided dependencies,</p></li>
                        <li><p>system scope just gives system dependencies.</p></li>
                        <li><p><strong>Type</strong>: java.lang.String</p></li>
                        <li><p><strong>Required</strong>: no</p></li>
                        <li><p><strong>User property</strong>: inverno.image.includeScope</p></li>
                    </ul>
                    <h6 id="jmodsoverridedirectory-4">&lt;jmodsOverrideDirectory&gt;</h6>
                    <p>A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.jmodsOverrideDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/jmods/</li>
                    </ul>
                    <h6 id="launchers-4">&lt;launchers&gt;</h6>
                    <p>A list of launchers to include in the resulting runtime.</p>
                    <ul>
                        <li><strong>Type</strong>: java.util.List</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="legaldirectory-4">&lt;legalDirectory&gt;</h6>
                    <p>A directory containing legal notices that will be copied to the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.legalDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/main/legal/</li>
                    </ul>
                    <h6 id="mandirectory-4">&lt;manDirectory&gt;</h6>
                    <p>A directory containing man pages that will be copied to the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.manDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/main/man/</li>
                    </ul>
                    <h6 id="overwriteifnewer-4">&lt;overWriteIfNewer&gt;</h6>
                    <p>Overwrite dependencies that don't exist or are older than the source.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.overWriteIfNewer</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="projectmainclass-4">&lt;projectMainClass&gt;</h6>
                    <p>The main class in the project module to use when building the project JMOD package.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.runtime.projectMainClass</li>
                    </ul>
                    <h6 id="resolveprojectmainclass-4">&lt;resolveProjectMainClass&gt;</h6>
                    <p>Resolve the project main class when not specified explicitly.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.runtime.projectMainClass</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="skip-4">&lt;skip&gt;</h6>
                    <p>Skips the generation of the runtime.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.runtime.skip</li>
                    </ul>
                    <h6 id="stripdebug-4">&lt;stripDebug&gt;</h6>
                    <p>Strip debug information from the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.stripDebug</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="stripnativecommands-4">&lt;stripNativeCommands&gt;</h6>
                    <p>Strip native command (eg. java...) from the resulting image.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.stripNativeCommands</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="verbose-4">&lt;verbose&gt;</h6>
                    <p>Enables verbose logging.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.verbose</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="vm-4">&lt;vm&gt;</h6>
                    <p>Select the HotSpot VM in the output image defined as: 'client' / 'server' / 'minimal' / 'all'</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.image.vm</li>
                    </ul>
                    <h4 id="invernohelp">inverno:help</h4>
                    <p><strong>Full name:</strong></p>
                    <p>io.inverno.tool:inverno-maven-plugin:1.3.1:help</p>
                    <p><strong>Description:</strong></p>
                    <p>Display help information on inverno-maven-plugin. Call mvn inverno:help -Ddetail=true -Dgoal=&lt;goal-name&gt; to display parameter details.</p>
                    <p><strong>Attributes:</strong></p>
                    <h5 id="optional-parameters-5">Optional parameters</h5>
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered ">
                            <tbody>
                              <tr>
                              <th>Name</th>
                              <th>Type</th>
                              <th>Description</th>
                              </tr>
                              <tr>
                              <td><a href="#detail">detail</a></td>
                              <td>boolean</td>
                              <td>If true, display all settable properties for each goal. 
                              <ul>
                              <li><em>User property</em> : detail</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#goal">goal</a></td>
                              <td>String</td>
                              <td>The name of the goal for which to show help. If unspecified, all goals will be displayed. 
                              <ul>
                              <li><em>User property</em> : goal</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#indentSize">indentSize</a></td>
                              <td>int</td>
                              <td>The number of spaces per indentation level, should be positive. 
                              <ul>
                              <li><em>User property</em> : indentSize</li>
                              <li><em>Default</em> : 2</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#lineLength">lineLength</a></td>
                              <td>int</td>
                              <td>The maximum length of a display line, should be positive. 
                              <ul>
                              <li><em>User property</em> : lineLength</li>
                              <li><em>Default</em> : 80</li>
                              </ul></td>
                              </tr>
                            </tbody>
                        </table>
                    </div>
                    <h5 id="parameter-details-5">Parameter details</h5>
                    <h6 id="detail">&lt;detail&gt;</h6>
                    <p>If true, display all settable properties for each goal.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: detail</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="goal">&lt;goal&gt;</h6>
                    <p>The name of the goal for which to show help. If unspecified, all goals will be displayed.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: goal</li>
                    </ul>
                    <h6 id="indentsize">&lt;indentSize&gt;</h6>
                    <p>The number of spaces per indentation level, should be positive.</p>
                    <ul>
                        <li><strong>Type</strong>: int</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: indentSize</li>
                        <li><strong>Default</strong>: 2</li>
                    </ul>
                    <h6 id="linelength">&lt;lineLength&gt;</h6>
                    <p>The maximum length of a display line, should be positive.</p>
                    <ul>
                        <li><strong>Type</strong>: int</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: lineLength</li>
                        <li><strong>Default</strong>: 80</li>
                    </ul>
                    <h4 id="invernorun">inverno:run</h4>
                    <p><strong>Full name:</strong></p>
                    <p>io.inverno.tool:inverno-maven-plugin:1.3.1:run</p>
                    <p><strong>Description:</strong></p>
                    <p>Runs the project application.</p>
                    <p><strong>Attributes:</strong></p>
                    <ul>
                        <li>Requires a Maven project to be executed.</li>
                        <li>Requires dependency resolution of artifacts in scope: compile+runtime.</li>
                        <li>Requires dependency collection of artifacts in scope: compile+runtime.</li>
                        <li>Since version: 1.0.</li>
                        <li>Binds by default to the lifecycle phase: validate.</li>
                    </ul>
                    <h5 id="optional-parameters-6">Optional parameters</h5>
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered ">
                            <tbody>
                              <tr>
                              <th>Name</th>
                              <th>Type</th>
                              <th>Description</th>
                              </tr>
                              <tr>
                              <td><a href="#addUnnamedModules">addUnnamedModules</a></td>
                              <td>boolean</td>
                              <td>Adds the unnamed modules when executing the application. 
                              <ul>
                              <li><em>User property</em> : inverno.exec.addUnnamedModules</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#arguments">arguments</a></td>
                              <td>String</td>
                              <td>The arguments to pass to the application. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#commandLineArguments">commandLineArguments</a></td>
                              <td>String</td>
                              <td>The command line arguments to pass to the application. This parameter overrides AbstractExecMojo.arguments when specified. 
                              <ul>
                              <li><em>User property</em> : inverno.run.arguments</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#configurationDirectory5">configurationDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing user-editable configuration files that will be copied to the image to execute. 
                              <ul>
                              <li><em>User property</em> : inverno.exec.configurationDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/main/conf/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#jmodsOverrideDirectory5">jmodsOverrideDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated. 
                              <ul>
                              <li><em>User property</em> : inverno.exec.jmodsOverrideDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/jmods/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#mainClass">mainClass</a></td>
                              <td>String</td>
                              <td>The main class to use to run the application. If not specified, a main class is automatically selected. 
                              <ul>
                              <li><em>User property</em> : inverno.exec.mainClass</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#overWriteIfNewer5">overWriteIfNewer</a></td>
                              <td>boolean</td>
                              <td>Overwrites dependencies that don't exist or are older than the source. 
                              <ul>
                              <li><em>User property</em> : inverno.exec.overWriteIfNewer</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#skip5">skip</a></td>
                              <td>boolean</td>
                              <td>Skips the execution. 
                              <ul>
                              <li><em>User property</em> : inverno.exec.skip</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#verbose5">verbose</a></td>
                              <td>boolean</td>
                              <td>Enables verbose logging. 
                              <ul>
                              <li><em>User property</em> : inverno.verbose</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#vmOptions">vmOptions</a></td>
                              <td>String</td>
                              <td>The VM options to use when executing the application. 
                              <ul>
                              <li><em>User property</em> : inverno.exec.vmOptions</li>
                              <li><em>Default</em> : -Dorg.apache.logging.log4j.simplelog.level=INFO -Dorg.apache.logging.log4j.level=INFO</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#workingDirectory">workingDirectory</a></td>
                              <td>File</td>
                              <td>The working directory of the application. 
                              <ul>
                              <li><em>User property</em> : inverno.run.workingDirectory</li>
                              <li><em>Default</em> : ${project.build.directory}/maven-inverno/working</li>
                              </ul></td>
                              </tr>
                            </tbody>
                        </table>
                    </div>
                    <h5 id="parameter-details-6">Parameter details</h5>
                    <h6 id="addunnamedmodules">&lt;addUnnamedModules&gt;</h6>
                    <p>Adds the unnamed modules when executing the application.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.exec.addUnnamedModules</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="arguments">&lt;arguments&gt;</h6>
                    <p>The arguments to pass to the application.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="commandlinearguments">&lt;commandLineArguments&gt;</h6>
                    <p>The command line arguments to pass to the application. This parameter overrides AbstractExecMojo.arguments when specified.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.run.arguments</li>
                    </ul>
                    <h6 id="configurationdirectory-5">&lt;configurationDirectory&gt;</h6>
                    <p>A directory containing user-editable configuration files that will be copied to the image to execute.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.exec.configurationDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/main/conf/</li>
                    </ul>
                    <h6 id="jmodsoverridedirectory-5">&lt;jmodsOverrideDirectory&gt;</h6>
                    <p>A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.exec.jmodsOverrideDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/jmods/</li>
                    </ul>
                    <h6 id="mainclass">&lt;mainClass&gt;</h6>
                    <p>The main class to use to run the application. If not specified, a main class is automatically selected.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.exec.mainClass</li>
                    </ul>
                    <h6 id="overwriteifnewer-5">&lt;overWriteIfNewer&gt;</h6>
                    <p>Overwrites dependencies that don't exist or are older than the source.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.exec.overWriteIfNewer</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="skip-5">&lt;skip&gt;</h6>
                    <p>Skips the execution.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.exec.skip</li>
                    </ul>
                    <h6 id="verbose-5">&lt;verbose&gt;</h6>
                    <p>Enables verbose logging.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.verbose</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="vmoptions">&lt;vmOptions&gt;</h6>
                    <p>The VM options to use when executing the application.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.exec.vmOptions</li>
                        <li><strong>Default</strong>: -Dorg.apache.logging.log4j.simplelog.level=INFO -Dorg.apache.logging.log4j.level=INFO</li>
                    </ul>
                    <h6 id="workingdirectory">&lt;workingDirectory&gt;</h6>
                    <p>The working directory of the application.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.run.workingDirectory</li>
                        <li><strong>Default</strong>: ${project.build.directory}/maven-inverno/working</li>
                    </ul>
                    <h4 id="invernostart">inverno:start</h4>
                    <p><strong>Full name:</strong></p>
                    <p>io.inverno.tool:inverno-maven-plugin:1.3.1:start</p>
                    <p><strong>Description:</strong></p>
                    <p>Starts the project application without blocking the Maven build.</p>
                    <p>This goal is used together with the stop goal in the pre-integration-test and post-integration-test phases to run integration tests.</p>
                    <p><strong>Attributes:</strong></p>
                    <ul>
                        <li>Requires a Maven project to be executed.</li>
                        <li>Requires dependency resolution of artifacts in scope: compile+runtime.</li>
                        <li>Requires dependency collection of artifacts in scope: compile+runtime.</li>
                        <li>Since version: 1.0.</li>
                        <li>Binds by default to the lifecycle phase: pre-integration-test.</li>
                    </ul>
                    <h5 id="optional-parameters-7">Optional parameters</h5>
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered ">
                            <tbody>
                              <tr>
                              <th>Name</th>
                              <th>Type</th>
                              <th>Description</th>
                              </tr>
                              <tr>
                              <td><a href="#addUnnamedModules1">addUnnamedModules</a></td>
                              <td>boolean</td>
                              <td>Adds the unnamed modules when executing the application. 
                              <ul>
                              <li><em>User property</em> : inverno.exec.addUnnamedModules</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#arguments1">arguments</a></td>
                              <td>String</td>
                              <td>The arguments to pass to the application. 
                              <ul></ul></td>
                              </tr>
                              <tr>
                              <td><a href="#configurationDirectory6">configurationDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing user-editable configuration files that will be copied to the image to execute. 
                              <ul>
                              <li><em>User property</em> : inverno.exec.configurationDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/main/conf/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#jmodsOverrideDirectory6">jmodsOverrideDirectory</a></td>
                              <td>File</td>
                              <td>A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated. 
                              <ul>
                              <li><em>User property</em> : inverno.exec.jmodsOverrideDirectory</li>
                              <li><em>Default</em> : ${project.basedir}/src/jmods/</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#mainClass1">mainClass</a></td>
                              <td>String</td>
                              <td>The main class to use to run the application. If not specified, a main class is automatically selected. 
                              <ul>
                              <li><em>User property</em> : inverno.exec.mainClass</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#overWriteIfNewer6">overWriteIfNewer</a></td>
                              <td>boolean</td>
                              <td>Overwrites dependencies that don't exist or are older than the source. 
                              <ul>
                              <li><em>User property</em> : inverno.exec.overWriteIfNewer</li>
                              <li><em>Default</em> : true</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#skip6">skip</a></td>
                              <td>boolean</td>
                              <td>Skips the execution. 
                              <ul>
                              <li><em>User property</em> : inverno.exec.skip</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#timeout">timeout</a></td>
                              <td>long</td>
                              <td>The amount of time in milliseconds to wait for the application to start. 
                              <ul>
                              <li><em>User property</em> : inverno.start.timeout</li>
                              <li><em>Default</em> : 60000</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#verbose6">verbose</a></td>
                              <td>boolean</td>
                              <td>Enables verbose logging. 
                              <ul>
                              <li><em>User property</em> : inverno.verbose</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#vmOptions1">vmOptions</a></td>
                              <td>String</td>
                              <td>The VM options to use when executing the application. 
                              <ul>
                              <li><em>User property</em> : inverno.exec.vmOptions</li>
                              <li><em>Default</em> : -Dorg.apache.logging.log4j.simplelog.level=INFO -Dorg.apache.logging.log4j.level=INFO</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#workingDirectory1">workingDirectory</a></td>
                              <td>File</td>
                              <td>The working directory of the application. 
                              <ul>
                              <li><em>User property</em> : inverno.run.workingDirectory</li>
                              <li><em>Default</em> : ${project.build.directory}/maven-inverno/working</li>
                              </ul></td>
                              </tr>
                            </tbody>
                        </table>
                    </div>
                    <h5 id="parameter-details-7">Parameter details</h5>
                    <h6 id="addunnamedmodules-1">&lt;addUnnamedModules&gt;</h6>
                    <p>Adds the unnamed modules when executing the application.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.exec.addUnnamedModules</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="arguments-1">&lt;arguments&gt;</h6>
                    <p>The arguments to pass to the application.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                    </ul>
                    <h6 id="configurationdirectory-6">&lt;configurationDirectory&gt;</h6>
                    <p>A directory containing user-editable configuration files that will be copied to the image to execute.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.exec.configurationDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/main/conf/</li>
                    </ul>
                    <h6 id="jmodsoverridedirectory-6">&lt;jmodsOverrideDirectory&gt;</h6>
                    <p>A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.exec.jmodsOverrideDirectory</li>
                        <li><strong>Default</strong>: ${project.basedir}/src/jmods/</li>
                    </ul>
                    <h6 id="mainclass-1">&lt;mainClass&gt;</h6>
                    <p>The main class to use to run the application. If not specified, a main class is automatically selected.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.exec.mainClass</li>
                    </ul>
                    <h6 id="overwriteifnewer-6">&lt;overWriteIfNewer&gt;</h6>
                    <p>Overwrites dependencies that don't exist or are older than the source.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.exec.overWriteIfNewer</li>
                        <li><strong>Default</strong>: true</li>
                    </ul>
                    <h6 id="skip-6">&lt;skip&gt;</h6>
                    <p>Skips the execution.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.exec.skip</li>
                    </ul>
                    <h6 id="timeout">&lt;timeout&gt;</h6>
                    <p>The amount of time in milliseconds to wait for the application to start.</p>
                    <ul>
                        <li><strong>Type</strong>: long</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.start.timeout</li>
                        <li><strong>Default</strong>: 60000</li>
                    </ul>
                    <h6 id="verbose-6">&lt;verbose&gt;</h6>
                    <p>Enables verbose logging.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.verbose</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h6 id="vmoptions-1">&lt;vmOptions&gt;</h6>
                    <p>The VM options to use when executing the application.</p>
                    <ul>
                        <li><strong>Type</strong>: java.lang.String</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.exec.vmOptions</li>
                        <li><strong>Default</strong>: -Dorg.apache.logging.log4j.simplelog.level=INFO -Dorg.apache.logging.log4j.level=INFO</li>
                    </ul>
                    <h6 id="workingdirectory-1">&lt;workingDirectory&gt;</h6>
                    <p>The working directory of the application.</p>
                    <ul>
                        <li><strong>Type</strong>: java.io.File</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.run.workingDirectory</li>
                        <li><strong>Default</strong>: ${project.build.directory}/maven-inverno/working</li>
                    </ul>
                    <h4 id="invernostop">inverno:stop</h4>
                    <p><strong>Full name:</strong></p>
                    <p>io.inverno.tool:inverno-maven-plugin:1.3.1:stop</p>
                    <p><strong>Description:</strong></p>
                    <p>Stops the project application that has been previously started using the start goal.</p>
                    <p>This goal is used together with the start goal in the pre-integration-test and post-integration-test phases to run integration tests.</p>
                    <p><strong>Attributes:</strong></p>
                    <ul>
                        <li>Requires a Maven project to be executed.</li>
                        <li>Since version: 1.0.</li>
                        <li>Binds by default to the lifecycle phase: post-integration-test.</li>
                    </ul>
                    <h5 id="optional-parameters-8">Optional parameters</h5>
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered ">
                            <tbody>
                              <tr>
                              <th>Name</th>
                              <th>Type</th>
                              <th>Description</th>
                              </tr>
                              <tr>
                              <td><a href="#skip7">skip</a></td>
                              <td>boolean</td>
                              <td>Skips the execution. 
                              <ul>
                              <li><em>User property</em> : inverno.stop.skip</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#timeout1">timeout</a></td>
                              <td>long</td>
                              <td>The amount of time in milliseconds to wait for the application to stop. 
                              <ul>
                              <li><em>User property</em> : inverno.stop.timeout</li>
                              <li><em>Default</em> : 60000</li>
                              </ul></td>
                              </tr>
                              <tr>
                              <td><a href="#verbose7">verbose</a></td>
                              <td>boolean</td>
                              <td>Enables verbose logging. 
                              <ul>
                              <li><em>User property</em> : inverno.verbose</li>
                              <li><em>Default</em> : false</li>
                              </ul></td>
                              </tr>
                            </tbody>
                        </table>
                    </div>
                    <h5 id="parameter-details-8">Parameter details</h5>
                    <h6 id="skip-7">&lt;skip&gt;</h6>
                    <p>Skips the execution.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.stop.skip</li>
                    </ul>
                    <h6 id="timeout-1">&lt;timeout&gt;</h6>
                    <p>The amount of time in milliseconds to wait for the application to stop.</p>
                    <ul>
                        <li><strong>Type</strong>: long</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.stop.timeout</li>
                        <li><strong>Default</strong>: 60000</li>
                    </ul>
                    <h6 id="verbose-7">&lt;verbose&gt;</h6>
                    <p>Enables verbose logging.</p>
                    <ul>
                        <li><strong>Type</strong>: boolean</li>
                        <li><strong>Required</strong>: no</li>
                        <li><strong>User property</strong>: inverno.verbose</li>
                        <li><strong>Default</strong>: false</li>
                    </ul>
                    <h2 id="inverno-oss-parent">Inverno OSS Parent</h2>
                    <p><a href="https://github.com/inverno-io/inverno-oss-parent/actions/workflows/maven.yml"><img src="https://github.com/inverno-io/inverno-oss-parent/actions/workflows/maven.yml/badge.svg" alt="CI/C" /></a></p>
                    <p>The Inverno OSS parent POM provides OSS dependencies and plugin management to Inverno components and applications.</p>
                    <h3 id="dependencies">Dependencies</h3>
                    <div class="overflow-auto">
                        <table style="margin: auto;" class="table table-striped table-bordered ">
                            <tbody>
                              <tr>
                              <th>GroupId</th>
                              <th>ArtifactId</th>
                              <th>Version</th>
                              </tr>
                              <tr>
                              <td>com.aayushatharva.brotli4j</td>
                              <td>brotli4j</td>
                              <td>1.7.1</td>
                              </tr>
                              <tr>
                              <td>com.aayushatharva.brotli4j</td>
                              <td>native-linux-x86_64</td>
                              <td>1.7.1</td>
                              </tr>
                              <tr>
                              <td>com.aayushatharva.brotli4j</td>
                              <td>native-osx-x86_64</td>
                              <td>1.7.1</td>
                              </tr>
                              <tr>
                              <td>com.aayushatharva.brotli4j</td>
                              <td>native-windows-x86_64</td>
                              <td>1.7.1</td>
                              </tr>
                              <tr>
                              <td>com.fasterxml.jackson.core</td>
                              <td>jackson-core</td>
                              <td>2.13.3</td>
                              </tr>
                              <tr>
                              <td>com.fasterxml.jackson.core</td>
                              <td>jackson-databind</td>
                              <td>2.13.3</td>
                              </tr>
                              <tr>
                              <td>com.fasterxml.jackson.datatype</td>
                              <td>jackson-datatype-jsr310</td>
                              <td>2.13.3</td>
                              </tr>
                              <tr>
                              <td>com.google.cloud.tools</td>
                              <td>jib-core</td>
                              <td>0.21.0</td>
                              </tr>
                              <tr>
                              <td>commons-codec</td>
                              <td>commons-codec</td>
                              <td>1.15</td>
                              </tr>
                              <tr>
                              <td>io.lettuce</td>
                              <td>lettuce-core</td>
                              <td>6.2.0.RELEASE</td>
                              </tr>
                              <tr>
                              <td>io.netty</td>
                              <td>netty-all</td>
                              <td>4.1.79.Final</td>
                              </tr>
                              <tr>
                              <td>io.netty</td>
                              <td>netty-buffer</td>
                              <td>4.1.79.Final</td>
                              </tr>
                              <tr>
                              <td>io.netty</td>
                              <td>netty-codec-http</td>
                              <td>4.1.79.Final</td>
                              </tr>
                              <tr>
                              <td>io.netty</td>
                              <td>netty-codec-http2</td>
                              <td>4.1.79.Final</td>
                              </tr>
                              <tr>
                              <td>io.netty</td>
                              <td>netty-common</td>
                              <td>4.1.79.Final</td>
                              </tr>
                              <tr>
                              <td>io.netty</td>
                              <td>netty-handler</td>
                              <td>4.1.79.Final</td>
                              </tr>
                              <tr>
                              <td>io.netty</td>
                              <td>netty-handler-proxy</td>
                              <td>4.1.79.Final</td>
                              </tr>
                              <tr>
                              <td>io.netty</td>
                              <td>netty-resolver</td>
                              <td>4.1.79.Final</td>
                              </tr>
                              <tr>
                              <td>io.netty</td>
                              <td>netty-resolver-dns</td>
                              <td>4.1.79.Final</td>
                              </tr>
                              <tr>
                              <td>io.netty</td>
                              <td>netty-tcnative-boringssl-static</td>
                              <td>2.0.54.Final</td>
                              </tr>
                              <tr>
                              <td>io.netty</td>
                              <td>netty-transport</td>
                              <td>4.1.79.Final</td>
                              </tr>
                              <tr>
                              <td>io.netty</td>
                              <td>netty-transport-classes-epoll</td>
                              <td>4.1.79.Final</td>
                              </tr>
                              <tr>
                              <td>io.netty</td>
                              <td>netty-transport-classes-kqueue</td>
                              <td>4.1.79.Final</td>
                              </tr>
                              <tr>
                              <td>io.netty</td>
                              <td>netty-transport-native-epoll</td>
                              <td>4.1.79.Final</td>
                              </tr>
                              <tr>
                              <td>io.netty</td>
                              <td>netty-transport-native-epoll</td>
                              <td>4.1.79.Final</td>
                              </tr>
                              <tr>
                              <td>io.netty</td>
                              <td>netty-transport-native-epoll</td>
                              <td>4.1.79.Final</td>
                              </tr>
                              <tr>
                              <td>io.netty</td>
                              <td>netty-transport-native-epoll</td>
                              <td>4.1.79.Final</td>
                              </tr>
                              <tr>
                              <td>io.netty</td>
                              <td>netty-transport-native-kqueue</td>
                              <td>4.1.79.Final</td>
                              </tr>
                              <tr>
                              <td>io.netty</td>
                              <td>netty-transport-native-kqueue</td>
                              <td>4.1.79.Final</td>
                              </tr>
                              <tr>
                              <td>io.netty.incubator</td>
                              <td>netty-incubator-transport-classes-io_uring</td>
                              <td>0.0.14.Final</td>
                              </tr>
                              <tr>
                              <td>io.netty.incubator</td>
                              <td>netty-incubator-transport-native-io_uring</td>
                              <td>0.0.14.Final</td>
                              </tr>
                              <tr>
                              <td>io.netty.incubator</td>
                              <td>netty-incubator-transport-native-io_uring</td>
                              <td>0.0.14.Final</td>
                              </tr>
                              <tr>
                              <td>io.netty.incubator</td>
                              <td>netty-incubator-transport-native-io_uring</td>
                              <td>0.0.14.Final</td>
                              </tr>
                              <tr>
                              <td>io.projectreactor</td>
                              <td>reactor-core</td>
                              <td>3.4.21</td>
                              </tr>
                              <tr>
                              <td>io.vertx</td>
                              <td>vertx-core</td>
                              <td>4.3.2</td>
                              </tr>
                              <tr>
                              <td>io.vertx</td>
                              <td>vertx-db2-client</td>
                              <td>4.3.2</td>
                              </tr>
                              <tr>
                              <td>io.vertx</td>
                              <td>vertx-mssql-client</td>
                              <td>4.3.2</td>
                              </tr>
                              <tr>
                              <td>io.vertx</td>
                              <td>vertx-mysql-client</td>
                              <td>4.3.2</td>
                              </tr>
                              <tr>
                              <td>io.vertx</td>
                              <td>vertx-pg-client</td>
                              <td>4.3.2</td>
                              </tr>
                              <tr>
                              <td>io.vertx</td>
                              <td>vertx-sql-client</td>
                              <td>4.3.2</td>
                              </tr>
                              <tr>
                              <td>net.java.dev.javacc</td>
                              <td>javacc</td>
                              <td>7.0.12</td>
                              </tr>
                              <tr>
                              <td>org.apache.commons</td>
                              <td>commons-compress</td>
                              <td>1.21</td>
                              </tr>
                              <tr>
                              <td>org.apache.commons</td>
                              <td>commons-lang3</td>
                              <td>3.12.0</td>
                              </tr>
                              <tr>
                              <td>org.apache.commons</td>
                              <td>commons-text</td>
                              <td>1.9</td>
                              </tr>
                              <tr>
                              <td>org.apache.logging.log4j</td>
                              <td>log4j-api</td>
                              <td>2.17.2</td>
                              </tr>
                              <tr>
                              <td>org.apache.logging.log4j</td>
                              <td>log4j-core</td>
                              <td>2.17.2</td>
                              </tr>
                              <tr>
                              <td>org.apache.logging.log4j</td>
                              <td>log4j-jul</td>
                              <td>2.17.2</td>
                              </tr>
                              <tr>
                              <td>org.apache.logging.log4j</td>
                              <td>log4j-layout-template-json</td>
                              <td>2.17.2</td>
                              </tr>
                              <tr>
                              <td>org.apache.maven</td>
                              <td>maven-artifact</td>
                              <td>${maven.version}</td>
                              </tr>
                              <tr>
                              <td>org.apache.maven</td>
                              <td>maven-compat</td>
                              <td>${maven.version}</td>
                              </tr>
                              <tr>
                              <td>org.apache.maven</td>
                              <td>maven-core</td>
                              <td>${maven.version}</td>
                              </tr>
                              <tr>
                              <td>org.apache.maven</td>
                              <td>maven-model</td>
                              <td>${maven.version}</td>
                              </tr>
                              <tr>
                              <td>org.apache.maven</td>
                              <td>maven-plugin-api</td>
                              <td>${maven.version}</td>
                              </tr>
                              <tr>
                              <td>org.apache.maven.plugin-tools</td>
                              <td>maven-plugin-annotations</td>
                              <td>3.6.4</td>
                              </tr>
                              <tr>
                              <td>org.apache.maven.shared</td>
                              <td>maven-common-artifact-filters</td>
                              <td>3.3.1</td>
                              </tr>
                              <tr>
                              <td>org.bouncycastle</td>
                              <td>bcjmail-jdk18on</td>
                              <td>1.71</td>
                              </tr>
                              <tr>
                              <td>org.bouncycastle</td>
                              <td>bcmail-jdk18on</td>
                              <td>1.71</td>
                              </tr>
                              <tr>
                              <td>org.bouncycastle</td>
                              <td>bcpg-jdk18on</td>
                              <td>1.71</td>
                              </tr>
                              <tr>
                              <td>org.bouncycastle</td>
                              <td>bcpkix-jdk18on</td>
                              <td>1.71</td>
                              </tr>
                              <tr>
                              <td>org.bouncycastle</td>
                              <td>bcprov-jdk18on</td>
                              <td>1.71</td>
                              </tr>
                              <tr>
                              <td>org.bouncycastle</td>
                              <td>bctls-jdk18on</td>
                              <td>1.71</td>
                              </tr>
                              <tr>
                              <td>org.bouncycastle</td>
                              <td>bcutil-jdk18on</td>
                              <td>1.71</td>
                              </tr>
                              <tr>
                              <td>org.junit</td>
                              <td>junit-bom</td>
                              <td>5.9.0</td>
                              </tr>
                              <tr>
                              <td>org.mockito</td>
                              <td>mockito-core</td>
                              <td>4.6.1</td>
                              </tr>
                              <tr>
                              <td>org.ow2.asm</td>
                              <td>asm</td>
                              <td>9.3</td>
                              </tr>
                              <tr>
                              <td>org.webjars</td>
                              <td>swagger-ui</td>
                              <td>4.11.1</td>
                              </tr>
                            </tbody>
                        </table>
                    </div>
                    <h3 id="maven-plugins">Maven Plugins</h3>
                    <div class="overflow-auto">
                        <table style="margin: auto;" class="table table-striped table-bordered ">
                            <tbody>
                              <tr>
                              <th>GroupId</th>
                              <th>ArtifactId</th>
                              <th>Version</th>
                              </tr>
                              <tr>
                              <td>org.apache.maven.plugins</td>
                              <td>maven-antrun-plugin</td>
                              <td>3.1.0</td>
                              </tr>
                              <tr>
                              <td>org.apache.maven.plugins</td>
                              <td>maven-assembly-plugin</td>
                              <td>3.4.2</td>
                              </tr>
                              <tr>
                              <td>org.apache.maven.plugins</td>
                              <td>maven-clean-plugin</td>
                              <td>3.2.0</td>
                              </tr>
                              <tr>
                              <td>org.apache.maven.plugins</td>
                              <td>maven-compiler-plugin</td>
                              <td>3.10.1</td>
                              </tr>
                              <tr>
                              <td>org.apache.maven.plugins</td>
                              <td>maven-dependency-plugin</td>
                              <td>3.3.0</td>
                              </tr>
                              <tr>
                              <td>org.apache.maven.plugins</td>
                              <td>maven-deploy-plugin</td>
                              <td>3.0.0</td>
                              </tr>
                              <tr>
                              <td>org.apache.maven.plugins</td>
                              <td>maven-gpg-plugin</td>
                              <td>3.0.1</td>
                              </tr>
                              <tr>
                              <td>org.apache.maven.plugins</td>
                              <td>maven-install-plugin</td>
                              <td>3.0.1</td>
                              </tr>
                              <tr>
                              <td>org.apache.maven.plugins</td>
                              <td>maven-jar-plugin</td>
                              <td>3.2.2</td>
                              </tr>
                              <tr>
                              <td>org.apache.maven.plugins</td>
                              <td>maven-javadoc-plugin</td>
                              <td>3.4.0</td>
                              </tr>
                              <tr>
                              <td>org.apache.maven.plugins</td>
                              <td>maven-plugin-plugin</td>
                              <td>3.6.4</td>
                              </tr>
                              <tr>
                              <td>org.apache.maven.plugins</td>
                              <td>maven-resources-plugin</td>
                              <td>3.3.0</td>
                              </tr>
                              <tr>
                              <td>org.apache.maven.plugins</td>
                              <td>maven-source-plugin</td>
                              <td>3.2.1</td>
                              </tr>
                              <tr>
                              <td>org.apache.maven.plugins</td>
                              <td>maven-surefire-plugin</td>
                              <td>3.0.0-M7</td>
                              </tr>
                              <tr>
                              <td>org.codehaus.mojo</td>
                              <td>exec-maven-plugin</td>
                              <td>3.1.0</td>
                              </tr>
                              <tr>
                              <td>org.javacc.plugin</td>
                              <td>javacc-maven-plugin</td>
                              <td>3.0.3</td>
                              </tr>
                              <tr>
                              <td>org.sonatype.plugins</td>
                              <td>nexus-staging-maven-plugin</td>
                              <td>1.6.13</td>
                              </tr>
                            </tbody>
                        </table>
                    </div>
                </section>
            </div>
        </main>
        <footer class="footer bg-light border-top mt-5">
            <div class="container p-5">
                <div class="row mb-5">
                    <div class="col col-lg-3">
                        <h5>Documentation</h5>
                        <ul class="nav flex-column">
                            <li class="nav-item"><a class="nav-link px-0" href="../../../../docs/release/reference/html/index.html">Reference</a></li>
                            <li class="nav-item"><a class="nav-link px-0" href="../../../../docs/release/api/index.html">API Doc</a></li>
                            <li class="nav-item"><a class="nav-link px-0" href="../../../../docs/getting-started/html/index.html">Getting Started</a></li>
                            <li class="nav-item"><a class="nav-link px-0" href="../../../../docs/redis-vue3-fullstack/html/index.html">Build a Full-Stack application</a></li>
                        </ul>
                    </div>
                    <div class="col col-lg-3">
                        <h5>Projects</h5>
                        <ul class="nav flex-column">
                            <li class="nav-item"><a class="nav-link px-0" href="https://github.com/inverno-io/inverno-core">Core</a></li>
                            <li class="nav-item"><a class="nav-link px-0" href="https://github.com/inverno-io/inverno-mods">Modules</a></li>
                            <li class="nav-item"><a class="nav-link px-0" href="https://github.com/inverno-io/inverno-dist">Distribution</a></li>
                            <li class="nav-item"><a class="nav-link px-0" href="https://github.com/inverno-io/inverno-tools">Tools</a></li>
                            <li class="nav-item"><a class="nav-link px-0" href="https://github.com/inverno-io/inverno-examples">Examples</a></li>
                            <li class="nav-item"><a class="nav-link px-0" href="https://github.com/inverno-io/inverno-apps">Apps</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="p-3 mb-5 text-center">
                <p class="fw-light fs-6">The Inverno Framework is released under version 2.0 of the <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License</a>.</p>
                <p class="fw-light fs-6">Copyright © 2021, The Inverno Framework</p>
            </div>
        </footer>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-p34f1UUtsS3wqzfto5wAAmdvj+osOnFyQFpp4Ua3gs/ZVWx6oOypYoCJhGGScy+8" crossorigin="anonymous"></script>
    </body>
</html>