<!DOCTYPE html>
<html lang="en"> 
    <head> 
        <meta charset="UTF-8" /> 
        <title>The Inverno Framework | Reference Documentation</title> 
        <meta name="viewport" content="width=device-width, initial-scale=1" /> 
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" /> 
        <meta name="author" content="Jeremy KUHN (jeremy.kuhn@inverno.io)" /> 
        <link rel="icon" type="image/svg" href="../../../../img/snowflake.svg" /> 
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-wEmeIV1mKuiNpC+IOBjI7aAzPcEZeedi5yW5f2yOq55WWLwNGmvvx4Um1vskeMj0" crossorigin="anonymous" /> 
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css" /> 
        <link rel="stylesheet" type="text/css" href="../../../../styles/styles.css" /> 
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/stackoverflow-dark.min.css" media="screen" /> 
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/ascetic.min.css" media="print" /> 
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script> 
        <script>hljs.initHighlightingOnLoad();</script> 
    </head> 
    <body data-bs-spy="scroll" data-bs-target="#toc" data-bs-offset="0" tabindex="0"> 
        <header class="header"> 
            <div class="container-fluid border-bottom bg-light"> 
                <nav class="navbar navbar-expand-lg navbar-light container p-0 py-2 p-lg-1"> <a class="navbar-brand p-0" href="../../../../"> <img class="logo" src="../../../../img/inverno_portable.svg" alt="The Inverno Framework" /> </a> <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#smallNavMenu" aria-controls="smallNavMenu" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> 
                    <div class="collapse" id="smallNavMenu" style="flex-basis: 100%;"> 
                        <ul class="navbar-nav border-top mt-2"> 
                            <li class="nav-item mt-2"> <h5>Documentation</h5> 
                                <ul class="nav flex-column"> 
                                    <li class="nav-item ms-4"><a class="nav-link" href="../../../../docs/getting-started/html/index.html">Getting Started</a></li> 
                                    <li class="nav-item ms-4"><a class="nav-link" href="../../../../docs/release/reference/html/index.html">Reference Guide</a></li> 
                                    <li class="nav-item ms-4"><a class="nav-link" href="../../../../docs/release/api/index.html">API Doc</a></li> 
                                </ul> </li> 
                            <li class="nav-item mt-2"> <h5>Projects</h5> 
                                <ul class="nav flex-column"> 
                                    <li class="nav-item ms-4"><a class="nav-link" href="https://github.com/inverno-io/inverno-core">Core</a></li> 
                                    <li class="nav-item ms-4"><a class="nav-link" href="https://github.com/inverno-io/inverno-mods">Modules</a></li> 
                                    <li class="nav-item ms-4"><a class="nav-link" href="https://github.com/inverno-io/inverno-dist">Distribution</a></li> 
                                    <li class="nav-item ms-4"><a class="nav-link" href="https://github.com/inverno-io/inverno-tools">Tools</a></li> 
                                    <li class="nav-item ms-4"><a class="nav-link" href="https://github.com/inverno-io/inverno-examples">Examples</a></li> 
                                </ul> </li> 
                        </ul> 
                    </div> 
                    <ul class="navbar-nav d-none d-sm-none d-lg-flex flex-fill justify-content-end align-self-stretch"> 
                        <li class="nav-item dropdown d-flex align-items-center me-3"> <a class="nav-link dropdown-toggle text-decoration-none" href="#" id="documentationMenu" role="button" data-bs-toggle="dropdown" aria-expanded="false">Documentation</a> 
                            <ul class="dropdown-menu mt-1 border-0 shadow p-3 mb-5 bg-body rounded" aria-labelledby="documentationMenu"> 
                                <li><a class="dropdown-item" href="../../../../docs/getting-started/html/index.html">Getting Started</a></li> 
                                <li><a class="dropdown-item" href="../../../../docs/release/reference/html/index.html">Reference Guide</a></li> 
                                <li><a class="dropdown-item" href="../../../../docs/release/api/index.html">API Doc</a></li> 
                            </ul> </li> 
                        <li class="nav-item dropdown d-flex align-items-center"> <a class="nav-link dropdown-toggle text-decoration-none" href="#" id="projectsMenu" role="button" data-bs-toggle="dropdown" aria-expanded="false">Projects</a> 
                            <ul class="dropdown-menu mt-1 border-0 shadow p-3 mb-5 bg-body rounded" aria-labelledby="projectsMenu"> 
                                <li><a class="dropdown-item" href="https://github.com/inverno-io/inverno-core">Core</a></li> 
                                <li><a class="dropdown-item" href="https://github.com/inverno-io/inverno-mods">Modules</a></li> 
                                <li><a class="dropdown-item" href="https://github.com/inverno-io/inverno-dist">Distribution</a></li> 
                                <li><a class="dropdown-item" href="https://github.com/inverno-io/inverno-tools">Tools</a></li> 
                                <li><a class="dropdown-item" href="https://github.com/inverno-io/inverno-examples">Examples</a></li> 
                            </ul> </li> 
                    </ul> 
                </nav> 
            </div> 
        </header> 
        <main id="main" class="main container">
            <div class="heading"> 
                <h1 class="heading-title">Inverno Framework Documentation</h1> 
                <p class="heading-subtitle">Version: 1.0.0</p> 
                <p class="heading-subtitle">Author: <a href="mailto:jeremy.kuhn@inverno.io">Jeremy Kuhn</a></p> <a class="btn btn-primary d-none d-lg-inline-block d-print-none m-5 position-absolute bottom-0 end-0" href="../reference.pdf" role="button" download="inverno-framework-documentation-1.0.0.pdf"><i class="bi bi-download"></i> Inverno Documentation.pdf</a> 
            </div> 
            <div class="d-lg-flex">
                <section class="toc col-12 col-lg-3">
                    <h2 class="d-none">Table of contents</h2><button class="toc-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#toc" aria-controls="toc" aria-expanded="false" aria-label="Toggle Table of Contents"><span class="toc-toggler-icon"></span></button>
                    <nav id="toc" class="navbar navbar-light toc-navbar toc-navbar-collapse collapse scrollbar-thin" onclick="this.className = 'navbar navbar-light toc-navbar toc-navbar-collapse collapse scrollbar-thin'">
                        <nav class="nav nav-pills flex-column">
                            <a class="nav-link" href="#introduction">Introduction</a>
                            <nav class="nav nav-pills flex-column ms-2 my-1">
                                <a class="nav-link" href="#design-principles">Design principles</a><a class="nav-link" href="#getting-help">Getting help</a>
                            </nav><a class="nav-link" href="#overview">Overview</a>
                            <nav class="nav nav-pills flex-column ms-2 my-1">
                                <a class="nav-link" href="#inverno-core">Inverno Core</a>
                                <nav class="nav nav-pills flex-column ms-2 my-1">
                                    <a class="nav-link" href="#creating-an-inverno-module">Creating an Inverno module</a>
                                </nav><a class="nav-link" href="#inverno-modules">Inverno Modules</a>
                                <nav class="nav nav-pills flex-column ms-2 my-1">
                                    <a class="nav-link" href="#using-a-module">Using a module</a><a class="nav-link" href="#available-modules">Available modules</a>
                                </nav><a class="nav-link" href="#inverno-tools">Inverno Tools</a>
                                <nav class="nav nav-pills flex-column ms-2 my-1">
                                    <a class="nav-link" href="#inverno-maven-plugin">Inverno Maven Plugin</a>
                                </nav>
                            </nav><a class="nav-link" href="#inverno-distribution">Inverno Distribution</a>
                            <nav class="nav nav-pills flex-column ms-2 my-1">
                                <a class="nav-link" href="#requirements">Requirements</a><a class="nav-link" href="#creating-an-inverno-project">Creating an Inverno project</a>
                                <nav class="nav nav-pills flex-column ms-2 my-1">
                                    <a class="nav-link" href="#developing-a-simple-inverno-application">Developing a simple Inverno application</a><a class="nav-link" href="#configuring-logging">Configuring logging</a><a class="nav-link" href="#running-the-application">Running the application</a><a class="nav-link" href="#building-the-application-image">Building the application image</a>
                                </nav>
                            </nav><a class="nav-link" href="#inverno-core-1">Inverno Core</a>
                            <nav class="nav nav-pills flex-column ms-2 my-1">
                                <a class="nav-link" href="#motivation">Motivation</a><a class="nav-link" href="#prerequisites">Prerequisites</a><a class="nav-link" href="#overview-1">Overview</a>
                                <nav class="nav nav-pills flex-column ms-2 my-1">
                                    <a class="nav-link" href="#modules-and-beans">Modules and Beans</a><a class="nav-link" href="#java-module-system">Java module system</a>
                                </nav><a class="nav-link" href="#project-setup">Project Setup</a>
                                <nav class="nav nav-pills flex-column ms-2 my-1">
                                    <a class="nav-link" href="#maven">Maven</a><a class="nav-link" href="#gradle">Gradle</a>
                                </nav><a class="nav-link" href="#bean">Bean</a>
                                <nav class="nav nav-pills flex-column ms-2 my-1">
                                    <a class="nav-link" href="#module-bean">Module Bean</a><a class="nav-link" href="#wrapper-bean">Wrapper Bean</a><a class="nav-link" href="#nested-bean">Nested Bean</a><a class="nav-link" href="#overridable">Overridable</a><a class="nav-link" href="#lifecycle">Lifecycle</a><a class="nav-link" href="#visibility">Visibility</a><a class="nav-link" href="#strategy">Strategy</a>
                                </nav><a class="nav-link" href="#module">Module</a>
                                <nav class="nav nav-pills flex-column ms-2 my-1">
                                    <a class="nav-link" href="#the-module-class">The module class</a><a class="nav-link" href="#lifecycle-1">Lifecycle</a><a class="nav-link" href="#module-as-component">Module as component</a><a class="nav-link" href="#module-as-application">Module as application</a>
                                </nav><a class="nav-link" href="#dependency-injection">Dependency Injection</a>
                                <nav class="nav nav-pills flex-column ms-2 my-1">
                                    <a class="nav-link" href="#bean-socket">Bean Socket</a><a class="nav-link" href="#socket-bean">Socket Bean</a><a class="nav-link" href="#wiring">Wiring</a>
                                </nav><a class="nav-link" href="#modular-application">Modular application</a>
                                <nav class="nav nav-pills flex-column ms-2 my-1">
                                    <a class="nav-link" href="#composite-module">Composite module</a><a class="nav-link" href="#provided-type">Provided type</a>
                                </nav>
                            </nav><a class="nav-link" href="#inverno-modules-1">Inverno Modules</a>
                            <nav class="nav nav-pills flex-column ms-2 my-1">
                                <a class="nav-link" href="#motivation-1">Motivation</a><a class="nav-link" href="#prerequisites-1">Prerequisites</a><a class="nav-link" href="#overview-2">Overview</a><a class="nav-link" href="#base">Base</a>
                                <nav class="nav nav-pills flex-column ms-2 my-1">
                                    <a class="nav-link" href="#converter-api">Converter API</a><a class="nav-link" href="#net-api">Net API</a><a class="nav-link" href="#reflection-api">Reflection API</a><a class="nav-link" href="#resource-api">Resource API</a>
                                </nav><a class="nav-link" href="#boot">Boot</a>
                                <nav class="nav nav-pills flex-column ms-2 my-1">
                                    <a class="nav-link" href="#configuration">Configuration</a><a class="nav-link" href="#net-service">Net service</a><a class="nav-link" href="#media-type-service">Media type service</a><a class="nav-link" href="#resource-service">Resource service</a><a class="nav-link" href="#converters">Converters</a><a class="nav-link" href="#worker-pool">Worker pool</a><a class="nav-link" href="#object-mapper">Object mapper</a>
                                </nav><a class="nav-link" href="#configuration-1">Configuration</a>
                                <nav class="nav nav-pills flex-column ms-2 my-1">
                                    <a class="nav-link" href="#configuration-source">Configuration source</a><a class="nav-link" href="#configuration-loader">Configuration loader</a>
                                </nav><a class="nav-link" href="#http-base">HTTP Base</a>
                                <nav class="nav nav-pills flex-column ms-2 my-1">
                                    <a class="nav-link" href="#http-base-api">HTTP base API</a><a class="nav-link" href="#http-header-service">HTTP header service</a>
                                </nav><a class="nav-link" href="#http-server">HTTP Server</a>
                                <nav class="nav nav-pills flex-column ms-2 my-1">
                                    <a class="nav-link" href="#http-server-exchange-api">HTTP Server exchange API</a><a class="nav-link" href="#http-server-1">HTTP Server</a><a class="nav-link" href="#wrap-up">Wrap-up</a>
                                </nav><a class="nav-link" href="#web">Web</a>
                                <nav class="nav nav-pills flex-column ms-2 my-1">
                                    <a class="nav-link" href="#routing">Routing</a><a class="nav-link" href="#static-handler">Static handler</a><a class="nav-link" href="#web-server">Web Server</a><a class="nav-link" href="#web-controller">Web Controller</a>
                                </nav>
                            </nav><a class="nav-link" href="#inverno-maven-plugin-1">Inverno Maven Plugin</a>
                            <nav class="nav nav-pills flex-column ms-2 my-1">
                                <a class="nav-link" href="#usage">Usage</a>
                                <nav class="nav nav-pills flex-column ms-2 my-1">
                                    <a class="nav-link" href="#run-a-module-application-project">Run a module application project</a><a class="nav-link" href="#start-and-stop-the-application-for-integration-testing">Start and stop the application for integration testing</a><a class="nav-link" href="#build-a-runtime-image">Build a runtime image</a><a class="nav-link" href="#build-an-application-image">Build an application image</a><a class="nav-link" href="#build-a-container-image-tarball">Build a container image tarball</a><a class="nav-link" href="#build-and-deploy-a-container-image-to-a-docker-daemon">Build and deploy a container image to a Docker daemon</a><a class="nav-link" href="#build-and-deploy-a-container-image-to-a-remote-repository">Build and deploy a container image to a remote repository</a>
                                </nav><a class="nav-link" href="#goals">Goals</a>
                                <nav class="nav nav-pills flex-column ms-2 my-1">
                                    <a class="nav-link" href="#overview-3">Overview</a><a class="nav-link" href="#invernobuild-app">inverno:build-app</a><a class="nav-link" href="#invernobuild-image">inverno:build-image</a><a class="nav-link" href="#invernobuild-image-docker">inverno:build-image-docker</a><a class="nav-link" href="#invernobuild-image-tar">inverno:build-image-tar</a><a class="nav-link" href="#invernobuild-runtime">inverno:build-runtime</a><a class="nav-link" href="#invernohelp">inverno:help</a><a class="nav-link" href="#invernorun">inverno:run</a><a class="nav-link" href="#invernostart">inverno:start</a><a class="nav-link" href="#invernostop">inverno:stop</a>
                                </nav>
                            </nav><a class="nav-link" href="#inverno-oss-parent">Inverno OSS Parent</a>
                            <nav class="nav nav-pills flex-column ms-2 my-1">
                                <a class="nav-link" href="#dependencies">Dependencies</a><a class="nav-link" href="#maven-plugins">Maven Plugins</a>
                            </nav>
                        </nav>
                    </nav>
                </section>
                <section class="markdown col p-3 overflow-auto"> 
                    <h2 id="introduction">Introduction</h2> 
                    <p>The <strong>Inverno Framework</strong> has been created with the objective of facilitating the creation of Java enterprise applications with maximum modularity, performance, maintainability and customizability.</p> 
                    <p>New technologies are emerging all the time questioning what has been working for years, We strongly believe that we must instead recognize and preserve proven solutions and only provide what is missing or change what is no longer in line with widely accepted evolutions. The Java platform has proven to be resilient to change and offers features that make it an ideal choice to create durable and efficient applications in complex technical and organizational environments which is precisely what is expected in an enterprise world. The Inverno Framework is a fully integrated suite of modules built for the Java platform that fully embrace its philosophy by keeping things well organized, strict and explicit with clean APIs and comprehensive documentation.</p> 
                    <p>The Inverno framework is open source and licensed under version 2.0 of the <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License</a>.</p> 
                    <h3 id="design-principles">Design principles</h3> 
                    <p>A Inverno application is inherently modular, <strong>modularity</strong> is a key design principle which guarantees a proper separation of concerns providing flexibility, maintainability, stability and ease of development regardless of the lifespan of an application or the number of people involved to develop it. A Inverno module is built as a standard Java module extending the <a href="https://en.wikipedia.org/wiki/Java_Platform_Module_System">Java module system</a> with <a href="https://en.wikipedia.org/wiki/Inversion_of_control">Inversion of Control</a> and <a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a> performed at compile time.</p> 
                    <p>The Inverno Framework extends the Java compiler to generate code at compile time when it makes sense to do so which is strictly why annotations were initially created for. When done appropriately, <strong>code generation</strong> can be extremely valuable: issues can be detected ahead of time by analyzing the code during compilation, runtime footprint can be reduced by transferring costly processing like IoC/DI to the compiler improving runtime performance at the same time.</p> 
                    <p>The framework uses a state of the art threading model and it has been designed from the ground up to be fully non-blocking and reactive in order to deliver very <strong>high performance</strong> while simplifying development of highly distributed applications requiring back pressure management.</p> 
                    <p>The inherent modularity of the framework based on the Java module system guarantees a nice and clean project structure which prevents misuse and abuse by clearly separating the concerns and exposing <strong>well designed APIs</strong>.</p> 
                    <p>Special attention has been paid to <strong>configuration</strong> and <strong>customization</strong> which are often overlooked and yet vital to create applications that can adapt to any environment or context.</p> 
                    <h3 id="getting-help">Getting help</h3> 
                    <p>We provide here a reference guide that starts by an overview of the Inverno core, modules and tools projects which gives a good idea of what can be done with the framework followed by a more comprehensive documentation that should guide you in the creation of an Inverno project using the Inverno distribution, the use of the core IoC/DI framework, the various modules including the configuration and the Web server modules and the tools to run, package and distribute Inverno components and applications.</p> 
                    <p>The <a href="../../../../docs/release/api/index.html">API documentation</a> provides plenty of details on how to use the various APIs. The <a href="../../../../docs/getting-started/html/index.html">getting started guide</a> is also a good starting point to get into it.</p> 
                    <p>Feel free to report bugs and feature requests or simply ask questions using <a href="https://github.com/inverno-io/inverno-core/issues">GitHub</a>'s issue tracking system if you ran in any issue or wish to see some new functionalities implemented in the framework.</p> 
                    <h2 id="overview">Overview</h2> 
                    <h3 id="inverno-core">Inverno Core</h3> 
                    <p>The <a href="https://www.inverno.io">Inverno core framework</a> project provides an Inversion of Control and Dependency Injection framework for the Javaâ„¢ platform. It has the particularity of not using reflection for object instantiation and dependency injection, everything being verified and done statically during compilation.</p> 
                    <p>This approach has many advantages over other IoC/DI solutions starting with the static checking of the bean dependency graph at compile time which guarantees that a program is correct and will run properly. Debugging is also made easier since you can actually access the source code where beans are instantiated and wired together. Finally, the startup time of a program is greatly reduced since everything is known in advance, such program can even be further optimized with ahead of time compilation solutions like <a href="https://www.graalvm.org/">GraalVM</a>...</p> 
                    <p>The framework has been designed to build highly modular applications using standard Java modules. An Inverno module supports encapsulation, it only exposes the beans that need to be exposed and it clearly specifies the dependencies it requires to operate properly. This greatly improves program stability over time and simplifies the use of a module. Since an Inverno module has a very small runtime footprint it can also be easily integrated in any application.</p> 
                    <h4 id="creating-an-inverno-module">Creating an Inverno module</h4> 
                    <p>An <strong>Inverno module</strong> is a regular Java module, that requires <code>io.inverno.core</code> modules, and which is annotated with <code>@Module</code> annotation. The following <em>hello</em> module is a simple Inverno module:</p> 
                    <pre><code class="language-java">@io.inverno.core.annotation.Module
module io.inverno.example.hello {
    requires io.inverno.core;
}
</code></pre> 
                    <p>An <strong>Inverno bean</strong> can be a regular Java class annotated with <code>@Bean</code> annotation. A bean represents the basic building block of an application which is typically composed of multiple interconnected beans instances. The following <code>HelloService</code> bean can be used to create a basic application:</p> 
                    <pre><code class="language-java">package io.inverno.example.hello;

import io.inverno.core.annotation.Bean;

@Bean
public class HelloService {

    public HelloService() {}

    public void sayHello(String name) {
        System.out.println("Hello " + name + "!!!");
    }
}
</code></pre> 
                    <p>At compile time, the Inverno framework will generate a module class named after the module, <code>io.inverno.example.hello.Hello</code> in our example. This class contains all the logic required to instantiate and wire the application beans at runtime. It can be used in a Java program to access and use the <code>HelloService</code>. This program can be in the same Java module or in any other Java module which requires module <code>io.inverno.example.hello</code>:</p> 
                    <pre><code class="language-java">package io.inverno.example.hello;

import io.inverno.core.v1.Application;

public class Main {
    
    public static void main(String[] args) {
        Hello hello = Application.with(new Hello.Builder()).run();

        hello.helloService().sayHello(args[0]);
    }
}
</code></pre> 
                    <h5 id="building-and-running-with-maven">Building and running with Maven</h5> 
                    <p>The development of an Inverno module is pretty easy using <a href="https://maven.apache.org/">Apache Maven</a>, you simply need to create a standard Java project that inherits from <code>io.inverno.dist:inverno-parent</code> project and declare a dependency to <code>io.inverno:inverno-core</code>:</p> 
                    <pre><code class="language-xml">&lt;!-- pom.xml --&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;io.inverno.dist&lt;/groupId&gt;
        &lt;artifactId&gt;inverno-parent&lt;/artifactId&gt;
        &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;io.inverno.example&lt;/groupId&gt;
    &lt;artifactId&gt;hello&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-core&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre> 
                    <p>Java source files for <code>io.inverno.example.hello</code> module must be placed in <code>src/main/java</code> directory, the module can then be built using Maven:</p> 
                    <pre><code class="language-plaintext">$ mvn install
</code></pre> 
                    <p>You can then run the application:</p> 
                    <pre><code class="language-plaintext">$ mvn inverno:run -Dinverno.run.arguments=John

[INFO] --- inverno-maven-plugin:1.0.0:run (default-cli) @ app-hello ---
[INFO] Running project: io.inverno.example.hello@1.0.0-SNAPSHOT...
Hello John!!!

</code></pre> 
                    <h5 id="building-and-running-with-pure-java">Building and running with pure Java</h5> 
                    <p>You can also choose to build your Inverno module using pure Java commands. Assuming Inverno framework modules are located under <code>lib/</code> directory and Java source files for <code>io.inverno.example.hello</code> module are placed in <code>src/io.inverno.example.hello</code> directory, you can build the module with the <code>javac</code> command:</p> 
                    <pre><code class="language-plaintext">$ javac --processor-module-path lib/ --module-path lib/ --module-source-path src/ -d jmods/ --module io.inverno.example.hello 
</code></pre> 
                    <p>The application can then be run as follows:</p> 
                    <pre><code class="language-plaintext">$ java --module-path lib/:jmods/ --module io.inverno.example.hello/io.inverno.example.hello.Main John
Hello John!!!
</code></pre> 
                    <h3 id="inverno-modules">Inverno Modules</h3> 
                    <p>The <a href="https://www.inverno.io">Inverno modules framework</a> project provides a collection of components for building highly modular and powerful applications on top of the <a href="https://github.com/inverno-io/inverno-core">Inverno IoC/DI framework</a>.</p> 
                    <p>While being fully integrated, any of these modules can also be used individually in any application thanks to the high modularity and low footprint offered by the Inverno framework.</p> 
                    <p>The objective is to provide a complete consistent set of high end tools and components for the development of fast and maintainable applications.</p> 
                    <h4 id="using-a-module">Using a module</h4> 
                    <p>Modules can be used in a Inverno module by defining dependencies in the module descriptor. For instance you can create a Web application module using the <em>boot</em> and <em>web</em> modules:</p> 
                    <pre><code class="language-java">@io.inverno.core.annotation.Module
module io.inverno.example.webApp {
    requires io.inverno.mod.boot;
    requires io.inverno.mod.web;
}
</code></pre> 
                    <p>A simple microservice application can then be created in a few lines of code as follows:</p> 
                    <pre><code class="language-java">import io.inverno.core.annotation.Bean;
import io.inverno.core.v1.Application;
import io.inverno.mod.base.resource.MediaTypes;
import io.inverno.mod.web.annotation.WebController;
import io.inverno.mod.web.annotation.WebRoute;

@Bean
@WebController
public class MainController {

    @WebRoute( path = "/message", produces = MediaTypes.TEXT_PLAIN)
    public String getMessage() {
        return "Hello, world!";
    }

    public static void main(String[] args) {
        Application.with(new WebApp.Builder()).run();
    }
}
</code></pre> 
                    <p>Please refer to <a href="https://github.com/inverno-io/inverno-dist">Inverno distribution</a> for detailed setup and installation instructions.</p> 
                    <p>Comprehensive reference documentations are available for <a href="https://github.com/inverno-io/inverno-core/tree/master/doc/reference-guide.md">Inverno core</a> and <a href="https://github.com/inverno-io/inverno-mods/tree/master/doc/reference-guide.md">Inverno modules</a>.</p> 
                    <p>Several example projects showing various features are also available in the <a href="https://github.com/inverno-io/inverno-examples">Inverno example project</a>. They can also be used as templates to start new Inverno application or component projects.</p> 
                    <p>Feel free to report bugs and feature requests in GitHub's issue tracking system if you ran in any issue or wish to see some new functionalities implemented in the framework.</p> 
                    <h4 id="available-modules">Available modules</h4> 
                    <p>The framework currently provides the following modules.</p> 
                    <h5 id="inverno-base">inverno-base</h5> 
                    <p>The foundational APIs of the Inverno framework modules:</p> 
                    <ul> 
                        <li>Conversion API used to convert objects from/to other objects</li> 
                        <li>Net API providing URI manipulation as well as low level network client and server utilities</li> 
                        <li>Reflect API for manipulating parameterized type at runtime</li> 
                        <li>Resource API to read/write any kind of resources (eg. file, zip, jar, classpath, module...)</li> 
                    </ul> 
                    <h5 id="inverno-boot">inverno-boot</h5> 
                    <p>The boot Inverno module provides base services to an application:</p> 
                    <ul> 
                        <li>a net service used for the implementation of optimized network clients and servers</li> 
                        <li>a media type service used to determine the media type of a resource</li> 
                        <li>a resource service used to access resources based on URIs</li> 
                        <li>a basic set of converters to decode/encode JSON, parameters (string to primitives or common types), media types (text/plain, application/json, application/x-ndjson...)</li> 
                        <li>a worker thread pool used to execute tasks asynchronously</li> 
                        <li>a JSON reader/writer</li> 
                    </ul> 
                    <h5 id="inverno-configuration">inverno-configuration</h5> 
                    <p>Application configuration API providing great customization and configuration features to multiple parts of an application (eg. system configuration, multitenant configuration, user preferences...).</p> 
                    <p>This module also introduces the <code>.cprops</code> configuration file format which facilitates the definition of complex parameterized configuration.</p> 
                    <p>In addition, it also provides implementations for multiple configuration sources:</p> 
                    <ul> 
                        <li>a command line configuration source used to load configuration from command line arguments</li> 
                        <li>a map configuration source used to load configuration stored in map in memory</li> 
                        <li>a system environment configuration source used to load configuration from environment variables</li> 
                        <li>a system properties configuration source used to load configuration from system properties</li> 
                        <li>a <code>.properties</code> file configuration source used to load configuration stored in a <code>.properties</code> file</li> 
                        <li>a <code>.cprops</code> file configuration source used to load configuration stored in a <code>.cprops</code> file</li> 
                        <li>a Redis configuration source used to load/store configuration from/to a Redis data store with supports for configuration versioning</li> 
                        <li>a composite configuration source used to combine multiple sources with support for smart defaulting</li> 
                        <li>an application configuration source used to load the system configuration of an application from a set of common configuration sources in a specific order, for instance: command line, system properties, system environment, local <code>configuration.cprops</code> file and <code>configuration.cprops</code> file resource in the application module</li> 
                    </ul> 
                    <p>Configurations are defined as simple interfaces in a module which are processed by the Inverno compiler to generate configuration loaders and beans to make them available in an application with no further effort.</p> 
                    <h5 id="inverno-http-base">inverno-http-base</h5> 
                    <p>The Inverno HTTP base module provides the foundational API as well as common services for HTTP client and server development, in particular an extensible HTTP header service used to decode and encode HTTP headers.</p> 
                    <h5 id="inverno-http-server">inverno-http-server</h5> 
                    <p>The Inverno HTTP server module provides a fully reactive HTTP/1.x and HTTP/2 server implementation based on Netty.</p> 
                    <p>It supports the following features:</p> 
                    <ul> 
                        <li>SSL</li> 
                        <li>HTTP compression/decompression</li> 
                        <li>Server-sent events</li> 
                        <li>HTTP/2 over cleartext upgrade</li> 
                        <li>URL encoded form data</li> 
                        <li>Multipart form data</li> 
                    </ul> 
                    <h5 id="inverno-web">inverno-web</h5> 
                    <p>The Inverno Web module provides advanced features on top of the HTTP server module, including:</p> 
                    <ul> 
                        <li>request routing based on path, path pattern, HTTP method, request and response content negotiation including request and response content type and language of the response.</li> 
                        <li>path parameters</li> 
                        <li>transparent payload conversion based on the content type of the request or the response from raw representation (arrays of bytes) to Java objects</li> 
                        <li>transparent parameter (path, cookie, header, query...) conversion from string to Java objects</li> 
                        <li>static resource handler to serve static resources from various location based on the resource API</li> 
                        <li>a complete set of annotations for easy REST controller development</li> 
                    </ul> 
                    <p>REST controllers can be easily defined using annotations which are processed by the Inverno compiler to generate the Web server configuration. The compiler also checks that everything is in order as for example that there are no conflicting routes.</p> 
                    <h3 id="inverno-tools">Inverno Tools</h3> 
                    <p>The Inverno framework provides tools for running and building modular Java applications and Inverno applications in particular. It allows for instance to create native runtime and application images providing all the dependencies required to run a modular application. It is also possible to build Docker and <a href="https://github.com/opencontainers/image-spec">OCI</a> images.</p> 
                    <h4 id="inverno-maven-plugin">Inverno Maven Plugin</h4> 
                    <p>The <a href="https://github.com/inverno-io/inverno-tools/tree/master/inverno-maven-plugin">Inverno Maven Plugin</a> provides specific goals to:</p> 
                    <ul> 
                        <li>run a modular Java application.</li> 
                        <li>start/stop a modular Java application during the build process to execute integration tests.</li> 
                        <li>build native a runtime image containing a set of modules and their dependencies creating a light Java runtime.</li> 
                        <li>build native an application image containing an application and all its dependencies into an easy to install platform dependent package (eg. <code>.deb</code>, <code>.rpm</code>, <code>.dmg</code>, <code>.exe</code>, <code>.msi</code>...).</li> 
                        <li>build docker or OCI images of an application into a tarball, a Docker daemon or a container image registry.</li> 
                    </ul> 
                    <p>The plugin requires <a href="https://jdk.java.net/">JDK</a> 14 or later and <a href="https://maven.apache.org/download.cgi">Apache Maven</a> 3.6.0 or later.</p> 
                    <h2 id="inverno-distribution">Inverno Distribution</h2> 
                    <p>The Inverno distribution provides a parent POM <code>io.inverno.dist:inverno-parent</code> and a BOM <code>io.inverno.dist:inverno-dependencies</code> for developing Inverno components and applications.</p> 
                    <p>The parent POM inherits from the BOM which inherits from the <a href="https://github.com/inverno-io/inverno-oss-parent">Inverno OSS parent</a> POM. It provides basic build configuration for building Inverno components and applications, including dependency management and plugins configuration. It especially includes configuration for the <a href="https://github.com/inverno-io/inverno-tools/tree/master/inverno-maven-plugin">Inverno Maven plugin</a>.</p> 
                    <p>The BOM specifies the <a href="https://github.com/inverno-io/inverno-core">Inverno core</a> and <a href="https://github.com/inverno-io/inverno-mods">Inverno modules</a> dependencies as well as OSS dependencies.</p> 
                    <p>The Inverno distribution thus defines a consistent sets of dependencies and configuration for developing, building, packaging and distributing Inverno components and applications. Upgrading the Inverno framework version of a project boils down to upgrade the Inverno distribution version which is the version of the Inverno parent POM or the Inverno BOM.</p> 
                    <h3 id="requirements">Requirements</h3> 
                    <p>The Inverno framework requires <a href="https://jdk.java.net/">JDK</a> 14 or later and <a href="https://maven.apache.org/download.cgi">Apache Maven</a> 3.6.0 or later.</p> 
                    <h3 id="creating-an-inverno-project">Creating an Inverno project</h3> 
                    <p>The recommended way to start a new Inverno project is to create a Maven project which inherits from the <code>io.inverno.dist:inverno-parent</code> project, we might also want to add a dependency to <code>io.inverno:inverno-core</code> in order to create an Inverno module with IoC/DI:</p> 
                    <pre><code class="language-xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;io.inverno.dist&lt;/groupId&gt;
        &lt;artifactId&gt;inverno-parent&lt;/artifactId&gt;
        &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;io.inverno.example&lt;/groupId&gt;
    &lt;artifactId&gt;sample-app&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-core&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre> 
                    <p>That is all we need to develop, run, build, package and distribute a basic Inverno component or application. The Inverno parent POM provides dependency management and Java compiler configuration to invoke the Inverno compiler during the build process as well as Inverno tools configuration to be able to run and package the Inverno component or application.</p> 
                    <p>If it is not possible to inherit from the Inverno parent POM, we can also declare the Inverno BOM <code>io.inverno.dist:inverno-dependencies</code> in the <code>&lt;dependencyManagement/&gt;</code> section to benefit from dependency management but loosing plugins configuration which must then be recovered from the Inverno parent POM.</p> 
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;io.inverno.dist&lt;/groupId&gt;
                &lt;artifactId&gt;inverno-dependencies&lt;/artifactId&gt;
                &lt;version&gt;1.0.0&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
&lt;/project&gt;
</code></pre> 
                    <p>Inverno modules dependencies can be added in the <code>&lt;dependencies/&gt;</code> section of the project POM. For instance the following dependencies can be added to develop a REST microservice application:</p> 
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-boot&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre> 
                    <p>Please refer to the <a href="https://github.com/inverno-io/inverno-core/tree/master/doc/reference-guide.md">Inverno core documentation</a> and <a href="https://github.com/inverno-io/inverno-mods/tree/master/doc/reference-guide.md">Inverno modules documentation</a> to learn how to develop with IoC/DI and how to use Inverno modules.</p> 
                    <h4 id="developing-a-simple-inverno-application">Developing a simple Inverno application</h4> 
                    <p>We can now start developing a sample REST application. An Inverno component or application is a regular Java module annotated with <code>@io.inverno.core.annotation.Module</code>, so the first thing we need to do is to create Java module descriptor <code>module-info.java</code> under <code>src/main/java</code> which is where Maven finds the sources to compile.</p> 
                    <pre><code class="language-java">@io.inverno.core.annotation.Module
module io.inverno.example.sample_app {
    requires io.inverno.mod.boot;
    requires io.inverno.mod.web;
}
</code></pre> 
                    <p>Note that we declared the <code>io.inverno.mod.boot</code> and <code>io.inverno.mod.web</code> module dependencies since we want to create a REST application, please refer to the <a href="https://github.com/inverno-io/inverno-mods/tree/master/doc/reference-guide.md">Inverno modules documentation</a> to learn more.</p> 
                    <p>We then can create the main class of our sample REST application in <code>src/main/java/io/inverno/example/sample_app/App.java</code>:</p> 
                    <pre><code class="language-java">package io.inverno.example.sample_app;

import io.inverno.core.annotation.Bean;
import io.inverno.core.v1.Application;
import io.inverno.mod.base.resource.MediaTypes;
import io.inverno.mod.web.annotation.WebController;
import io.inverno.mod.web.annotation.WebRoute;

@Bean
@WebController
public class App {

    @WebRoute( path = "/message", produces = MediaTypes.TEXT_PLAIN)
    public String getMessage() {
        return "Hello, world!";
    }

    public static void main(String[] args) {
        Application.with(new Sample_app.Builder()).run();
    }
}
</code></pre> 
                    <h4 id="configuring-logging">Configuring logging</h4> 
                    <p>Inverno framework is using <a href="https://logging.apache.org/log4j/2.x/index.html">Log4j 2</a> for logging, Inverno application logging can be activated by adding the dependency to <code>org.apache.logging.log4j:log4j-core</code>:</p> 
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre> 
                    <blockquote> 
                        <p>If you don't include this dependency at runtime, Log4j falls back to the <code>SimpleLogger</code> implementation provided with the API and configured using <code>org.apache.logging.log4j.simplelog.*</code> system properties. The log level can then be configured by setting <code>-Dorg.apache.logging.log4j.simplelog.level=INFO</code> system property when running the application.</p> 
                    </blockquote> 
                    <p>Log4j 2 provides a default configuration with a default root logger level set to <code>ERROR</code>, resulting in no info messages being output when starting an application. This can be changed by setting <code>-Dorg.apache.logging.log4j.level=INFO</code> system property when running the application.</p> 
                    <p>However the recommended way is to provide a specific <code>log4j2.xml</code> logging configuration file in the project resources under <code>src/main/resources</code>:</p> 
                    <pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;Configuration xmlns="http://logging.apache.org/log4j/2.0/config"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://logging.apache.org/log4j/2.0/config https://raw.githubusercontent.com/apache/logging-log4j2/rel/2.14.0/log4j-core/src/main/resources/Log4j-config.xsd" 
    status="WARN" shutdownHook="disable"&gt;

    &lt;Appenders&gt;
        &lt;Console name="LogToConsole" target="SYSTEM_OUT"&gt;
             &lt;PatternLayout pattern="%d{DEFAULT} %highlight{%-5level} [%t] %c{1.} - %msg%n%ex"/&gt;
        &lt;/Console&gt;
    &lt;/Appenders&gt;
    &lt;Loggers&gt;
        &lt;Root level="info"&gt;
            &lt;AppenderRef ref="LogToConsole"/&gt;
        &lt;/Root&gt;
    &lt;/Loggers&gt;
&lt;/Configuration&gt;
</code></pre> 
                    <blockquote> 
                        <p>Note that the Log4j shutdown hook must be disabled so as not to interfere with the Inverno application shutdown hook, if it is not disabled, application shutdown logs might be dropped.</p> 
                    </blockquote> 
                    <blockquote> 
                        <p>We could have chosen to provide a default logging configuration in the Inverno framework itself, but we preferred to stick to standard Log4j 2 configuration rules in order to keep things simple so please refer to the <a href="https://logging.apache.org/log4j/2.x/manual/configuration.html">Log4j 2 configuration documentation</a> to learn how to configure logging.</p> 
                    </blockquote> 
                    <h4 id="running-the-application">Running the application</h4> 
                    <p>The application is now ready and can be run using the <code>inverno:run</code> goal:</p> 
                    <pre><code class="language-plaintext">$ mvn inverno:run

...
[INFO] --- inverno-maven-plugin:1.0.0:run (default-cli) @ sample-app ---
[INFO] Running project: io.inverno.example.sample_app@1.0.0-SNAPSHOT...
 [â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• 100&nbsp;% â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•] 
2021-04-08 23:50:35,261 INFO  [main] i.w.c.v.Application - Inverno is starting...


     â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
     â•‘                      , ~~ ,                                                                â•‘
     â•‘                  , '   /\   ' ,                                                            â•‘
     â•‘                 , __   \/   __ ,      _                                                    â•‘
     â•‘                ,  \_\_\/\/_/_/  ,    | |  ___  _    _  ___   __  ___   ___                 â•‘
     â•‘                ,    _\_\/_/_    ,    | | / _ \\ \  / // _ \ / _|/ _ \ / _ \                â•‘
     â•‘                ,   __\_/\_\__   ,    | || | | |\ \/ /|  __/| | | | | | |_| |               â•‘
     â•‘                 , /_/ /\/\ \_\ ,     |_||_| |_| \__/  \___||_| |_| |_|\___/                â•‘
     â•‘                  ,     /\     ,                                                            â•‘
     â•‘                    ,   \/   ,                                  -- 1.2.0 --                 â•‘
     â•‘                      ' -- '                                                                â•‘
     â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
     â•‘ Java runtime        : OpenJDK Runtime Environment                                          â•‘
     â•‘ Java version        : 16+36-2231                                                           â•‘
     â•‘ Java home           : /home/jkuhn/Devel/jdk/jdk-16                                         â•‘
     â•‘                                                                                            â•‘
     â•‘ Application module  : io.inverno.example.sample_app                                        â•‘
     â•‘ Application version : 1.0.0-SNAPSHOT                                                       â•‘
     â•‘ Application class   : io.inverno.example.sample_app.App                                    â•‘
     â•‘                                                                                            â•‘
     â•‘ Modules             :                                                                      â•‘
     â•‘  * ...                                                                                     â•‘
     â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


2021-04-08 23:50:35,266 INFO  [main] i.w.e.s.Sample_app - Starting Module io.inverno.example.sample_app...
2021-04-08 23:50:35,266 INFO  [main] i.w.m.b.Boot - Starting Module io.inverno.mod.boot...
2021-04-08 23:50:35,446 INFO  [main] i.w.m.b.Boot - Module io.inverno.mod.boot started in 179ms
2021-04-08 23:50:35,446 INFO  [main] i.w.m.w.Web - Starting Module io.inverno.mod.web...
2021-04-08 23:50:35,446 INFO  [main] i.w.m.h.s.Server - Starting Module io.inverno.mod.http.server...
2021-04-08 23:50:35,446 INFO  [main] i.w.m.h.b.Base - Starting Module io.inverno.mod.http.base...
2021-04-08 23:50:35,450 INFO  [main] i.w.m.h.b.Base - Module io.inverno.mod.http.base started in 3ms
2021-04-08 23:50:35,545 INFO  [main] i.w.m.h.s.i.HttpServer - HTTP Server (nio) listening on http://0.0.0.0:8080
2021-04-08 23:50:35,546 INFO  [main] i.w.m.h.s.Server - Module io.inverno.mod.http.server started in 99ms
2021-04-08 23:50:35,546 INFO  [main] i.w.m.w.Web - Module io.inverno.mod.web started in 99ms
2021-04-08 23:50:35,546 INFO  [main] i.w.e.s.Sample_app - Module io.inverno.example.sample_app started in 281ms

</code></pre> 
                    <p>We can now test the application:</p> 
                    <pre><code class="language-plaintext">$ curl http://127.0.0.1:8080/message
Hello, world!
</code></pre> 
                    <p>The application can be gracefully shutdown by pressing <code>Ctrl-c</code>.</p> 
                    <h4 id="building-the-application-image">Building the application image</h4> 
                    <p>In order to create a native image containing the application and all its dependencies including JDK's dependencies, we can simply invoke the <code>inverno:build-app</code> goal:</p> 
                    <pre><code class="language-plaintext">$ mvn inverno:build-app

...
[INFO] Building application image: /home/jkuhn/Devel/git/frmk/io.inverno.example.sample-app/target/maven-inverno/application_linux_amd64/sample-app-1.0.0-SNAPSHOT...
 [â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  67&nbsp;% â•â•â•â•â•â•â•â•â•â•â•â•â•&gt;                                ] Creating archive sample-app-1.0.0-SNAPSHOT-application_linux_amd64.zip...
</code></pre> 
                    <blockquote> 
                        <p>This uses <code>jpackage</code> tool which is an incubating feature in JDK&lt;16, if you intend to build an application image with an old JDK, you'll need to explicitly add the <code>jdk.incubator.jpackage</code> module in <code>MAVEN_OPTS</code>:</p> 
                        <pre><code class="language-plaintext">$ export MAVEN_OPTS="--add-modules jdk.incubator.jpackage"
</code></pre> 
                    </blockquote> 
                    <p>This will create a ZIP archive containing a native application distribution <code>target/sample-app-1.0.0-SNAPSHOT-application_linux_amd64.zip</code> which will be deployed to the local Maven repository and eventually to a remote Maven repository.</p> 
                    <p>Then in order to install the application on a compatible platform, we just need to download the archive corresponding to the platform, extract it to some location and run the application. Luckily for us this can be done quite easily with Maven dependency plugin:</p> 
                    <pre><code class="language-plaintext">$ mvn dependency:unpack -Dartifact=io.inverno.example:sample-app:1.0.0-SNAPSHOT:zip:application_linux_amd64 -DoutputDirectory=./
...
$ ./sample-app-1.0.0-SNAPSHOT/bin/sample-app
...
</code></pre> 
                    <p>It is also possible to create platform specific package such as <code>.deb</code> or a <code>.msi</code> by defining particular formats in the Inverno Maven plugin configuration:</p> 
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;io.inverno.tool&lt;/groupId&gt;
                &lt;artifactId&gt;inverno-maven-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;build-app&lt;/id&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;build-app&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;formats&gt;
                                &lt;format&gt;zip&lt;/format&gt;
                                &lt;format&gt;deb&lt;/format&gt;
                            &lt;/formats&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre> 
                    <pre><code class="language-plaintext">$ mvn package
...
</code></pre> 
                    <blockquote> 
                        <p>Note that there is no cross-platform support and a given platform specific format must be built on the platform it runs on.</p> 
                    </blockquote> 
                    <p>Such platform-specific package can then be downloaded and installed using the right package manager:</p> 
                    <pre><code class="language-plaintext">$ mvn dependency:copy -Dartifact=io.inverno.example:sample-app:1.0.0-SNAPSHOT:deb:application_linux_amd64 -DoutputDirectory=./
...
$ sudo dpkg -i sample-app-1.0.0-SNAPSHOT-application_linux_amd64.deb
...
$ /opt/sample-app/bin/sample-app
</code></pre> 
                    <h2 id="inverno-core-1">Inverno Core</h2> 
                    <h3 id="motivation">Motivation</h3> 
                    <p><a href="https://en.wikipedia.org/wiki/Inversion_of_control">Inversion of Control</a> and <a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a> principles are not new and many Java applications have been developed following these principles over the past two decades using frameworks such as Spring, CDI, Guice... However these recognized solutions might have some issues in practice especially with the way Java has evolved and how applications should be developed nowadays.</p> 
                    <p>Dependency injection errors like a missing dependency or a cycle in the dependency graph are often reported at runtime when the application is started. Most of the time these issues are easy to fix but when considering big applications split into multiple modules developed by different people, it might become more complex. In any case you can't tell for sure if an application will start before you actually start it.</p> 
                    <p>Most IoC/DI frameworks are black boxes, often considered as magical because one gets beans instantiated and wired altogether without understanding what just happened and it is indeed quite hard to figure out how it actually works. This is not a problem as long as everything works as expected but it can become one when you actually need to troubleshoot a failing application.</p> 
                    <p>Beans instantiation and wiring are done at runtime using Java reflection which offers all the advantages of Java dynamic linking at the expense of some performance overhead. Classpath scanning, instantiation and wiring process indeed takes some time and prevents just-in-time compilation optimization making application startup quite slow.</p> 
                    <p>Although IoC frameworks make the development of modular applications easier, they often require a rigorous methodology to make it the right way. For instance, you must know precisely what components are provided and/or required by all the modules composing an application and make sure one doesn't provide a component that might interfere with another.</p> 
                    <p>These points are very high level, please have a look at this <a href="https://inverno.medium.com/reviving-java-ioc-di-and-why-does-it-matters-b1a2b0b57cca">article</a> if you like to learn more about the general ideas behind the Inverno framework. The Inverno framework proposes a new approach of IoC/DI principles consistent with latest developments of the Javaâ„¢ platform and perfectly adapted to the development of modern applications in Java.</p> 
                    <h3 id="prerequisites">Prerequisites</h3> 
                    <p>In this documentation, weâ€™ll assume that you have a working knowledge of <a href="https://en.wikipedia.org/wiki/Inversion_of_control">Inversion of Control</a> and <a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a> principles as well as <a href="https://en.wikipedia.org/wiki/Object-oriented_programming">Object Oriented Programming</a>.</p> 
                    <h3 id="overview-1">Overview</h3> 
                    <p>The Inverno framework is different in many ways and tries to address previous issues. Its main difference is that it doesn't rely on Java reflection at all to instantiate the beans composing an application (IoC) and wire them together (DI), this is actually done by a class generated by the Inverno compiler at compile time.</p> 
                    <p>Since beans and their dependencies are determined at compile time, errors can be raised precisely when they make sense during development or at build time.</p> 
                    <p>There is also no need for complex runtime libraries since the complexity is handled by the compiler which generates a readable class providing only what is required at runtime. This presents two advantages, first applications have a small footprint and start fast since most of the processing is already done and no reflection is involved. Secondly you will be able to actually debug all parts of your application since nothing is hidden behind a complex library, you can actually see when the beans are instantiated with the <code>new</code> operator opening rooms to other compile and runtime optimization as well.</p> 
                    <p>The framework also fully embraces the modular system introduced in Java 9 which basically imposes to develop with modularity in mind. An Inverno module only exposes the beans that must be exposed to other modules and it clearly indicates the beans it requires to operate. All this makes modular development safer, clearer and more natural.</p> 
                    <h4 id="modules-and-beans">Modules and Beans</h4> 
                    <p>Inversion of control and dependency injection principles have proven to be an elegant and efficient way to create applications in an Object Oriented Programming language. A Java application basically consists in a set of interconnected objects.</p> 
                    <p>An Inverno application adds a modular dimension to these principles, the objects or the <strong>beans</strong> composing the application are created and connected in one or more isolated <strong>modules</strong> which are themselves composed in the <strong>application</strong>.</p> 
                    <p>A <strong>module</strong> encapsulates several beans and possibly other modules. It specifies the dependencies it needs to operate and only exposes the beans that need to be exposed from the module perspective. As a result it is isolated from the rest of the application, it is unaware of how and where it is used and it actually doesn't care as long as its requirements are met. It really resembles a class which makes it very familiar to use.</p> 
                    <p>A <strong>bean</strong> is a component of a module and more widely an application. It has required and optional dependencies provided by the module when a bean instance is created.</p> 
                    <p>The <strong>Inverno compiler</strong> is an annotation processor which runs inside the Java compiler and generates module classes based on Inverno annotations found on the modules and classes being compiled.</p> 
                    <h4 id="java-module-system">Java module system</h4> 
                    <p>Before you can create your first Inverno module, you must first understand what a Java module is and how it might change your life as a Java developer. If you are already familiar with it, you can skip that section and go directly to the <a href="#project-setup">project setup</a> section.</p> 
                    <p>The Java module system has been introduced in Java 9 mostly to modularize the overgrowing Java runtime library which is now split into multiple interdependent modules loaded when you need them at runtime or compile time. This basically means that the size of the Java runtime you need to compile and/or run your application now depends on your application's needs which is a pretty big improvement.</p> 
                    <p>If you know OSGI or Maven already, you might say that modules have existed in Java for a long time but now they are fully integrated into the language, the compiler and the runtime. You can create a Java module, specify what packages are exposed and what dependencies are required and the good part is that both the compiler and JVM tell you when you do something wrong being as close as possible to the code, thereâ€™s no more xml or manifest files to care about.</p> 
                    <p>So how do you create a Java module? There is plenty of documentation you can read to have a complete and deep understanding of the Java module system, here we will only explain what you need to know to develop regular Inverno modules.</p> 
                    <p>A Java module is specified in a <code>module-info.java</code> file located in the default package. Let's assume you want to create module <code>io.inverno.example.sample</code>, you can create the following file structure:</p> 
                    <pre><code class="language-plaintext">src
â””â”€â”€ io.inverno.example.sample
    â”œâ”€â”€ io
    â”‚   â””â”€â”€ inverno
    â”‚       â””â”€â”€ example
    â”‚           â””â”€â”€ sample
    â”‚               â”œâ”€â”€ internal
    â”‚               â”‚   â””â”€â”€ ...
    â”‚               â””â”€â”€ ...
    â””â”€â”€ module-info.java
</code></pre> 
                    <blockquote> 
                        <p>This is one way to organize the code, the only important thing is to put the <code>module-info.java</code> descriptor in the default package.</p> 
                    </blockquote> 
                    <p>Now let's have a closer look at the module descriptor:</p> 
                    <pre><code class="language-java">module io.inverno.example.sample {      // 1
    exports io.inverno.example.sample;  // 2
}
</code></pre> 
                    <ol> 
                        <li>A module is declared using a familiar syntax starting with the <code>module</code> keyword followed by the name of the module which must be a valid Java name.</li> 
                        <li>The <code>io.inverno.example.sample</code> module exports the <code>io.inverno.example.sample</code> package which means that other modules can only access public types contained in that package. Any type defined in another package within that module is only visible from within the module following usual Java visibility rules (default, public, protected, private). This basically defines a new level of encapsulation at module level. For instance, types in package <code>io.inverno.example.sample.internal</code> are not accessible to other modules regardless of their visibility.</li> 
                    </ol> 
                    <p>Now let's say you need to use some external types defined and exported in another module <code>io.inverno.example.other</code>:</p> 
                    <pre><code class="language-plaintext">src
â”œâ”€â”€ io.inverno.example.sample
â”‚   â”œâ”€â”€ ...
â”‚   â””â”€â”€ module-info.java
â””â”€â”€ io.inverno.example.other
    â”œâ”€â”€ ...
    â””â”€â”€ module-info.java
</code></pre> 
                    <p>If you try to reference any of these types in <code>io.inverno.example.sample</code> module as is the compiler will complain with explicit visibility errors unless you specify that <code>io.inverno.example.sample</code> module requires <code>io.inverno.example.other</code> module:</p> 
                    <pre><code class="language-java">module io.inverno.example.sample {
    requires io.inverno.example.other;
    
    exports io.inverno.example.sample;
}
</code></pre> 
                    <p>You should now be able to reference any public types defined in a package exported in <code>io.inverno.example.other</code> module.</p> 
                    <p>The modular system has also changed the way Java applications are built and run. Before we used to specify a classpath listing the locations where the Java compiler and the JVM should look for application's classes whereas now we should specify a module path listing the locations of modules and forget about the classpath.</p> 
                    <p>If we consider previous modules, they are compiled and run as follows:</p> 
                    <pre><code class="language-plaintext">&gt; javac --module-source-path src -d jmods --module io.inverno.example.sample --module io.inverno.example.other

&gt; java --module-path jmods/ --module io.inverno.example.sample/io.inverno.example.sample.Sample
</code></pre> 
                    <p>There are other subtleties like transitive dependencies, service providers or opened modules and cool features like jmod packaging and the <code>jlink</code> tool but for now that's pretty much all you need to know to develop Inverno modules which are basically instrumented Java modules.</p> 
                    <p>You should now have a basic understanding of how an Inverno application is built and what Java technologies are involved. An Inverno application results from the composition of multiple isolated modules which create and wire the beans making up the application. Almost everything is done at compile time where module classes are generated.</p> 
                    <h3 id="project-setup">Project Setup</h3> 
                    <h4 id="maven">Maven</h4> 
                    <p>The easiest way to setup an Inverno module project is to start by creating a regular Java Maven project which inherits from <code>io.inverno.dist:inverno-parent</code> project and depends on <code>io.inverno:inverno-core</code>:</p> 
                    <pre><code class="language-xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;io.inverno.dist&lt;/groupId&gt;
        &lt;artifactId&gt;inverno-parent&lt;/artifactId&gt;
        &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;io.inverno.example&lt;/groupId&gt;
    &lt;artifactId&gt;sample&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;

    ...
    &lt;dependencies&gt;
        ...
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-core&lt;/artifactId&gt;
        &lt;/dependency&gt;
        ...
    &lt;/dependencies&gt;
    ...
    
&lt;/project&gt;
</code></pre> 
                    <p>Then you have to add a module descriptor to make it a Java module project. An Inverno module requires <code>io.inverno.core</code> and <code>io.inverno.core.annotation</code> modules. If you want your module to be used in other modules it must also export the package where the module class is generated by the Inverno compiler which is the module name by default. Remember that an Inverno module is materialized in a regular Java class subject to the same rules as any other class in a Java module.</p> 
                    <pre><code class="language-java">module io.inverno.example.sample {
    requires io.inverno.core;
    requires io.inverno.core.annotation;
    
    exports io.inverno.example.sample;
}
</code></pre> 
                    <p>If you do not want your project to inherit from <code>io.inverno.dist:inverno-parent</code> project, you'll have to explicitly specify compiler source and target version (&gt;=9), dependencies version and configure the Maven compiler plugin to invoke the Inverno compiler.</p> 
                    <pre><code class="language-xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;io.inverno.example&lt;/groupId&gt;
    &lt;artifactId&gt;sample&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
    
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;9&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;9&lt;/maven.compiler.target&gt;
        &lt;version.inverno&gt;1.0.0&lt;/version.inverno&gt;
    &lt;/properties&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;io.inverno.dist&lt;/groupId&gt;
                &lt;artifactId&gt;inverno-dependencies&lt;/artifactId&gt;
                &lt;version&gt;${version.inverno}&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-core&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    
    &lt;build&gt;
        &lt;plugins&gt;
            ...
            &lt;plugin&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;annotationProcessorPaths&gt;
                        &lt;path&gt;
                            &lt;groupId&gt;io.inverno&lt;/groupId&gt;
                            &lt;artifactId&gt;inverno-core-compiler&lt;/artifactId&gt;
                            &lt;version&gt;${version.inverno}&lt;/version&gt;
                        &lt;/path&gt;
                    &lt;/annotationProcessorPaths&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
            ...
        &lt;plugin&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre> 
                    <p>An Inverno module is built just as a regular Maven project using maven commands (compile, package, install...). The module class is generated and compiled during the <code>compile</code> phase and included in the resulting JAR file during the <code>package</code> phase. If anything related to IoC/DI goes wrong during compilation, the compilation fails with explicit compilation errors reported by the Inverno compiler.</p> 
                    <h4 id="gradle">Gradle</h4> 
                    <p>Since version 6.4, it is also possible to use <a href="https://gradle.org/">Gradle</a> to build Inverno module projects. Here is a sample <code>build.gradle</code> file:</p> 
                    <pre><code class="language-groovy">plugins {
    id 'application'
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'io.inverno:inverno-core:1.0.0'
    annotationProcessor 'io.inverno:inverno-core-compiler:1.0.0'
}

java {
    modularity.inferModulePath = true
    sourceCompatibility = JavaVersion.VERSION_1_9
    targetCompatibility = JavaVersion.VERSION_1_9
}

application {
    mainModule = 'io.inverno.example.hello'
    mainClassName = 'io.inverno.example.hello.App'
}
</code></pre> 
                    <h3 id="bean">Bean</h3> 
                    <p>As you already know, a Java application can be reduced to the composition of objects working together. In an Inverno application, these objects are instantiated and injected into each other by one or more modules. Inside a module, a bean basically specifies what it needs to create a bean instance (DI) and how to obtain it (IoC).</p> 
                    <p>A bean and a bean instance are two different things that should not be confused. A bean can result in multiple bean instances in the application whereas a bean instance always refers to exactly one bean. A bean is like a plan used to create instances.</p> 
                    <p>A bean is fully identified by its name and the module in which it resides. The following notation is used to represent a bean qualified name: <code>[MODULE]:[BEAN]</code>. As a consequence, two beans with the same name cannot exist in the same module but it is safe to have multiple beans with the same name in different modules.</p> 
                    <h4 id="module-bean">Module Bean</h4> 
                    <p>Module bean is the primary type of beans you can create in an Inverno module. It is defined by a concrete class annotated with the <code>@Bean</code> annotation.</p> 
                    <pre><code class="language-java">import io.inverno.core.annotation.Bean;
    
@Bean
public class SomeBean {
    ...
}
</code></pre> 
                    <p>In the previous code we created a bean of type <code>SomeBean</code>. At compile time, the Inverno compiler will include it in the generated module class that you'll eventually use at runtime to obtain <code>SomeBean</code> instances.</p> 
                    <p>By default, a bean is named after the simple name of the class starting with a lower case (eg. <code>someBean</code> in our previous example). This can be specified in the annotation using the name attribute:</p> 
                    <pre><code class="language-java">@Bean(name="customSomeBean")
public class SomeBean {
    ...
}
</code></pre> 
                    <h4 id="wrapper-bean">Wrapper Bean</h4> 
                    <p>A wrapper bean is a particular form of bean used to define beans whose code cannot be instrumented with Inverno annotations or that require more complex logic to create the instance. This is especially the case for legacy code or third party libraries.</p> 
                    <p>A wrapper bean is defined by a concrete class annotated with both <code>@Bean</code> and <code>@Wrapper</code> annotations which basically wraps the actual bean instance and include the instantiation, initialization and destruction logic. It must implement the <code>Supplier&lt;E&gt;</code> interface which specifies the actual type of the bean as formal parameter.</p> 
                    <pre><code class="language-java">@Bean
@Wrapper
public class SomeWrapperBean implements Supplier&lt;SomeLegacyBean&gt; {
    
    private SomeLegacyBean instance;
    
    public SomeWrapperBean() {
        // Creates the wrapped instance 
        this.instance = ...
    }
    
    SomeLegacyBean get() {
        // Returns the wrapped instance
        return this.instance;
    }
    ...
}
</code></pre> 
                    <p>In the previous code we created a bean of type <code>SomeLegacyBean</code>. One instance of the wrapper class is used to create exactly one bean instance and it lives as long as the bean instance is referenced.</p> 
                    <p>Since a wrapper bean is annotated with <code>@Bean</code> annotation, it can be configured in the exact same way as a module bean except that it only applies to the wrapper instance which is responsible to configure the actual bean instance. The wrapper instance is never exposed, only the actual bean instance wrapped in it is exposed. As for module beans, <code>SomeLegacyBean</code> instances can be obtained using the generated Module class.</p> 
                    <blockquote> 
                        <p>Note that since a new wrapper instance is created every time a new bean instance is requested, a wrapper class is not required to return a new or distinct result in the <code>get()</code> method. Nonetheless a wrapper instance is used to create, initialize and destroy exactly one instance of the supplied type and as a result it is good practice to have the wrapper instance always return the same bean instance. This is especially true and done naturally when initialization or destruction methods are specified.</p> 
                    </blockquote> 
                    <blockquote> 
                        <p>When designing a prototype wrapper bean, particular care must be taken to make sure the wrapper does not hold a strong reference to the wrapped instance in order to prevent memory leak when a prototype bean instance is requested by the application. It is strongly advised to rely on <code>WeakReference&lt;&gt;</code> in that particular use case.</p> 
                    </blockquote> 
                    <h4 id="nested-bean">Nested Bean</h4> 
                    <p>A nested bean is, as its name suggests, a bean inside a bean. A nested bean instance is obtained by invoking a particular method on another bean instance. Instances thus obtained participate in dependency injection but unlike other types of bean they do not follow any particular lifecycle or strategy, the implementor of the nested bean method is free to decide whether a new instance should be returned on each invocation.</p> 
                    <p>A nested bean is declared in the class of a bean, by annotating a non-void method with no arguments with <code>@NestedBean</code> annotation. The name of a nested bean is given by the name of the bean providing the instance and the name of the annotated method following this notation: <code>[MODULE]:[BEAN].[METHOD_NAME]</code>.</p> 
                    <pre><code class="language-java">@Bean
public class SomeBean {

    ...

    @NestedBean
    public SomeNestedBean nestedBean() {
        ...
    }
}
</code></pre> 
                    <p>It is also possible to <em>cascade</em> nested beans.</p> 
                    <h4 id="overridable">Overridable</h4> 
                    <p>A module bean or a wrapper bean can be declared as overridable which allows to override the bean inside the module by a socket bean of the same type.</p> 
                    <p>An overridable bean is defined as a module bean or a wrapper bean whose class has been annotated with <code>@Overridable</code>. This basically tells the Inverno compiler to create an extra optional socket bean with the particular feature of being able to take over the bean when an instance is provided on module instantiation.</p> 
                    <pre><code class="language-java">@Bean
@Overridable
public class SomeBean {
    
}
</code></pre> 
                    <h4 id="lifecycle">Lifecycle</h4> 
                    <p>All bean instances follow the subsequent lifecycle in a module:</p> 
                    <ol> 
                        <li>A bean instance is created</li> 
                        <li>It is initialized</li> 
                        <li>It is active</li> 
                        <li>It is <em>"eventually"</em> destroyed</li> 
                    </ol> 
                    <p>Let's examine each of these steps in details.</p> 
                    <p>A bean instance is always created in a module, when a bean instance is created greatly depends on the context in which it is used, it can be created when a module instance is started or when it is required in the application. In order to create a bean instance the module must provide all the dependencies required by the bean. After that it sets any optional dependencies available on the instance thus obtained. This is actually when and where dependency injection takes place, this aspect will be covered more in details in following sections, for now all you have to know is that when requested the module creates a fully wired bean instance.</p> 
                    <p>After that the module invokes initialization methods on the bean instance to initialize it. An initialization method is declared on the bean class using the <code>@Init</code> annotation:</p> 
                    <pre><code class="language-java">@Bean
public class SomeBean {
    
    @Init
    public void init() {
        ...
    }
}
</code></pre> 
                    <p>You can specify multiple initialization methods but the order in which they are invoked is undetermined. Inheritance is not considered here, only the methods annotated on the bean class are considered. Bean initialization is useful when you want to execute some code after dependency injection to make the bean instance fully functional (eg. initialize a connection pool, start a server socket...).</p> 
                    <p>After that, the bean instance is active and can be used either directly by accessing it from the module or indirectly through another bean instance where it has been injected.</p> 
                    <p>A bean instance is <em>"eventually"</em> destroyed, typically when its enclosing module instance is stopped. Just as you specified initialization methods, you can specify destruction methods to be invoked when a bean instance is destroyed using the <code>@Destroy</code> annotation:</p> 
                    <pre><code class="language-java">@Bean
public class SomeBean {
    
    @Destroy
    public void destroy() {
        ...
    }
}
</code></pre> 
                    <p>As for initialization methods, you can specify multiple destruction methods but the order in which they are invoked is undetermined and inheritance is also not considered. Bean destruction is useful when you need to free resources that have been allocated by the bean instance during application operation (eg. shutdown a connection pool, close a server socket...).</p> 
                    <p>In case of wrapper beans, the initialization and destruction of a bean instance is delegated to the initialization and destruction methods specified on the wrapper bean which respectively initialize and destroy the actual bean instance wrapped in the wrapper bean.</p> 
                    <pre><code class="language-java">@Bean
@Wrapper
public class SomeWrapperBean implements Supplier&lt;SomeLegacyBean&gt; {
    
    private SomeLegacyBean instance;
    
    public SomeWrapperBean() {
        // Creates the wrapped instance 
        this.instance = ...
    }
    
    @Init
    public void init() {
        // Initialize the wrapped instance
        this.instance.start();
    }
    
    @Destroy
    public void destroy() {
        // Destroy the wrapped instance
        this.instance.stop();
    }
    ...
}
</code></pre> 
                    <blockquote> 
                        <p>We stated here that all bean instances are eventually destroyed but this is actually not always the case. Depending on the bean strategy and the context in which it is used, it might not be destroyed at all, hopefully workarounds exist to make sure a bean instance is always properly destroyed. We'll cover this more in detail when we'll describe <a href="#strategy">bean strategies</a>.</p> 
                    </blockquote> 
                    <h4 id="visibility">Visibility</h4> 
                    <p>A bean can be assigned a public or private visibility. A public bean is exposed by the module to the rest of the application whereas a private bean is only visible from within the module.</p> 
                    <p>Bean visibility is set in the <code>@Bean</code> annotation in the visibility attribute:</p> 
                    <pre><code class="language-java">@Bean(visibility=Visibility.PUBLIC)
public class SomeBean {
    
}
</code></pre> 
                    <h4 id="strategy">Strategy</h4> 
                    <p>A bean is always defined with a particular strategy which controls how a module should create a bean instance when one is requested, either during dependency injection when a module requires a bean instance to inject in another bean instance or during application operation when some application code requests a bean instance to a module instance.</p> 
                    <h5 id="singleton">Singleton</h5> 
                    <p>The singleton strategy is the default strategy used when no explicit strategy is specified on a bean class. An Inverno module only creates one single instance for a singleton bean. That same instance is returned every time an instance of that bean is requested. It is then shared among all dependent beans through dependency injection and also the application if it has requested an instance.</p> 
                    <p>A singleton bean is specified explicitly by setting the <code>strategy</code> attribute to <code>Strategy.SINGLETON</code> in the <code>@Bean</code> annotation:</p> 
                    <pre><code class="language-java">@Bean(strategy = Strategy.SINGLETON)
public class SomeSingletonBean {

}
</code></pre> 
                    <p>Modules easily support the bean lifecyle for singleton beans since a module instance holds singleton bean instances by design, they can then be properly destroyed when the module instance is stopped.</p> 
                    <p>Particular care must be taken when a singleton bean instance is requested to a module instance by the application as the resulting reference will point to a <em>managed</em> instance which will be destroyed when the module instance is stopped leaving the instance referenced in the application in an unpredictable state.</p> 
                    <p>A singleton bean is the basic building block of any application which explains why it is the default strategy. An application is basically made of multiple long living components rather than volatile disposable components. A server is a typical example of singleton bean, it is created when the application is started, initialized to accept requests and destroyed when the application is stopped.</p> 
                    <blockquote> 
                        <p>A singleton instance is held by exactly one module instance, if you instantiate a module twice, you'll get two singleton bean instances, one in the first module instance and the other in the second module instance. This basically differs from the standard singleton pattern, you'll see more in detail why this actually matters when we'll describe <a href="#composite-module">composite modules</a>.</p> 
                    </blockquote> 
                    <h5 id="prototype">Prototype</h5> 
                    <p>A prototype bean results in the creation of as many instances as requested. All dependent beans in the module get a different bean instance and each time a bean instance is requested to a module instance by the application a new instance is also created.</p> 
                    <p>A prototype bean is specified by setting the <code>strategy</code> attribute to <code>Strategy.PROTOTYPE</code> in the <code>@Bean</code> annotation:</p> 
                    <pre><code class="language-java">@Bean(strategy = Strategy.PROTOTYPE)
public class SomeBean {

}
</code></pre> 
                    <p>Unlike singleton beans, modules can't always fully support the bean lifecycle for prototype beans. All prototype beans instances are kept in the module instance in order to destroy them when it is stopped. Modules use weak references to prevent memory leaks so that dereferenced instances are automatically removed from the internal registry when the garbage collector reclaims them. This works well for prototype bean instances injected into singleton bean instances since they are actually referenced until the module instance is stopped just like any singleton bean instance. It becomes tricky when a prototype bean instance is requested by the application. In that case, the prototype bean instance is removed from the module instance when it is dereferenced from the application and reclaimed by the garbage collector leaving no chance for the module instance to destroy it properly. The actual behavior is more subtle because a dereferenced prototype bean instance might actually be destroyed when a module is stopped before the instance is reclaimed by the garbage collector.</p> 
                    <p>As a result, it is not recommended to define destruction methods on a prototype bean but if you really need to, you can make your bean implement <code>AutoClosable</code>, specify the <code>close()</code> method as the unique destruction method and request prototype bean instances from the application using a try-with-resources block:</p> 
                    <pre><code class="language-java">@Bean(strategy = Strategy.PROTOTYPE)
public class SomeBean implements AutoCloseable {

    @Destroy
    public void close() throws Exception {
        ...
    }
}
</code></pre> 
                    <p>Then when requesting a prototype bean instance from the application:</p> 
                    <pre><code class="language-java">try(SomeBean bean = module.someBean()) {
    ...
}
</code></pre> 
                    <p>As soon as the program exits the try-with-resources block the bean instance is properly destroyed, then dereferenced and eventually reclaimed by the garbage collector and finally removed from the module instance. However you should make sure that the <code>close()</code> method can be called twice since it actually might.</p> 
                    <p>Prototype beans should be used whenever there is a need to hold a state in a particular context. An HTTP client is a typical example of a stateful instance, different instances should be created and injected in singleton beans so they can deal with concurrency independently to make sure requests are sent only after a response to the previous request has been received.</p> 
                    <blockquote> 
                        <p>That might not be the smartest way to use HTTP clients in an application but it gives you the idea.</p> 
                    </blockquote> 
                    <p>Prototype beans can also be used to implement the factory pattern, just like a factory, you can request new bean instances on a module. Inverno framework makes this actually very powerful since there's no runtime overhead, modules can be created and used anywhere and you never have to worry about the boiler plate code that instantiates the bean since it is generated for you by the framework.</p> 
                    <h3 id="module">Module</h3> 
                    <p>An Inverno module can be seen as an isolated collection of beans. The role of a module is to create and wire bean instances in order to expose logic to the application.</p> 
                    <p>In practice, a module is materialized by the class generated by the Inverno compiler during compilation and which results from the processing of Inverno annotations.</p> 
                    <p>A module is isolated from the rest of the application through its module class which clearly defines the beans exposed by the module and what it needs to operate. As a result, a module doesnâ€™t care when and how it is used in an application as long as its requirements are met.</p> 
                    <blockquote> 
                        <p>Isolation is actually what makes the Inverno framework so special as it greatly simplifies the development of complex modular applications.</p> 
                    </blockquote> 
                    <p>A module is defined as a regular Java module annotated with the <code>@Module</code> annotation:</p> 
                    <pre><code class="language-java">@Module
Module io.inverno.sample.sampleModule {
    ...
}
</code></pre> 
                    <h4 id="the-module-class">The module class</h4> 
                    <p>Java modules annotated with <code>@Module</code> will be processed by the Inverno compiler at compile time. The Inverno compiler generates one <strong>module class</strong> per module providing all the code required at runtime to create and wire bean instances.</p> 
                    <p>This class is the entry point of a module and serve several purposes:</p> 
                    <ul> 
                        <li>encapsulate beans instances creation and wiring logic</li> 
                        <li>implement bean instance lifecyle</li> 
                        <li>specify required or optional module dependencies</li> 
                        <li>expose public beans</li> 
                        <li>hide private beans</li> 
                        <li>guarantee a proper isolation of the module within the application</li> 
                    </ul> 
                    <p>This regular Java class can be instantiated like any other class. It relies on a minimal runtime library barely visible which makes it self-describing and very easy to use.</p> 
                    <p>Letâ€™s see how it looks like for the <code>io.inverno.sample.sampleModule</code> module and <code>SomeBean</code> bean, the module class would be used as follows:</p> 
                    <pre><code class="language-java">SampleModule module = new SampleModule.Builder().build(); // 1
module.start();                                           // 2

SomeBean someBean = module.someBean();                    // 3
// Do something useful with someBean
module.stop();                                            // 4
</code></pre> 
                    <ol> 
                        <li>The <code>SampleModule</code> class is instantiated</li> 
                        <li>The module is started</li> 
                        <li>The <code>SomeBean</code> instance is retrieved</li> 
                        <li>Eventually the module is stopped</li> 
                    </ol> 
                    <p>There are two important things to notice here, first you control when, where and how many times you want to instantiate a module, which brings great flexibility in the way modules are used in your application. For instance integrating an Inverno module in an existing code is pretty straightforward as it is plain old Java, it is also possible to create and use a module instance during application operation (eg. when processing a request). Secondly beans are exposed with their actual types through named methods which eventually produces more secure code because static type checking can (finally) be performed by the compiler.</p> 
                    <p>Module classes provide dedicated builders to facilitate the creation of complex modules instances with multiple required and optional dependencies.</p> 
                    <p>By default, the module class is named after the last identifier of the module name and generated in a package named after the module. The full class name can be specified in the annotation using the <code>className</code> attribute:</p> 
                    <pre><code class="language-java">@Module(className=â€io.inverno.sample.CustomSampleModuleâ€)
Module io.inverno.sample.sampleModule {
    ...
}
</code></pre> 
                    <p>The module class is like any other class in the module, if you want to use it outside the module you have to explicitly export its package in the module descriptor:</p> 
                    <pre><code class="language-java">@Module
Module io.inverno.sample.sampleModule {
    exports io.inverno.sample.sampleModule;
}
</code></pre> 
                    <p>Most of the time this is something youâ€™ll do especially if you want to create <a href="#modular-application">composite modules</a>, however if you only use the module class from within the module, typically in a main method or embedded in some other class, you wonâ€™t have to do it.</p> 
                    <blockquote> 
                        <p>Note that the Java compiler fails if you try to export a package which is empty before compilation, since the module class is generated this might actually happen, so you need to make sure the class will be generated in a package containing some code. This is not an ideal situation however a module usually defines and exports a package named after its name so this should solve the issue.</p> 
                    </blockquote> 
                    <h4 id="lifecycle-1">Lifecycle</h4> 
                    <p>Just like a bean instance, a module follows a lifecycle:</p> 
                    <ol> 
                        <li>A module instance is created</li> 
                        <li>It is started</li> 
                        <li>It is active</li> 
                        <li>It is stopped</li> 
                    </ol> 
                    <p>Let's examine each of these steps in details.</p> 
                    <p>A module instance can be created directly in the application or indirectly inside a composite module. A module defines a dedicated <code>Builder</code> class that must be used to build the module instance. Relying on a builder is very helpful when considering complex modules with many required and optional dependencies.</p> 
                    <p>The instance must then be started to make it operational. During this phase, all Inverno modules composed in the module are instantiated and started and all the beans defined in the module are created and initialized. Dependency injection is performed naturally as beans are created. Since everything has been validated at compile time, we know for sure that everything will work properly.</p> 
                    <blockquote> 
                        <p>A module is actually composed by the beans it defines and the beans defined in the modules it composes. This is discussed in details in the <a href="#modular-application">Modular application</a> section.</p> 
                    </blockquote> 
                    <p>Once the module instance is active, beans are exposed to the application.</p> 
                    <p>Finally, a module instance is stopped to release resources held by the beans instances. During this phase, beans are destroyed in the reverse order of their creation and composed Inverno modules are stopped.</p> 
                    <h4 id="module-as-component">Module as component</h4> 
                    <p>Inverno modules are very flexible and can be used in many situations. You can for instance develop Inverno modules to create reusable software components. Such components would benefit from inversion of control and dependency injection capabilities offered by the framework without interfering with the applications that uses them. An Inverno module has also a very low runtime footprint since it creates objects and wires them in a fixed and deterministic way, it can then be created at any time in any situations.</p> 
                    <h5 id="standalone-component">Standalone component</h5> 
                    <p>You can imagine a standalone module used to interface with an external system like a coffee maker module for example. From the outside a coffee maker is actually quite simple:</p> 
                    <ul> 
                        <li>it requires electricity to operate</li> 
                        <li>you have to fill it with coffee beans</li> 
                        <li>you have to supply some water as well</li> 
                        <li>then you can make some tasty coffee</li> 
                    </ul> 
                    <p>From the inside on the other hand it can be much more complex than this, it is probably composed of multiple internal components that you actually don't care about as long as the coffee is good.</p> 
                    <p>Let's try to imagine what kind of interface would be exposed by the <code>io.inverno.sample.coffeeMakerModule</code> module without anticipating any implementation.</p> 
                    <p>First of all it would probably export the module's package as it is intended to be used from outside the module:</p> 
                    <p><strong>module-info.java</strong></p> 
                    <pre><code class="language-java">@Module
Module io.inverno.sample.coffeeMakerModule {
    exports io.inverno.sample.coffeeMakerModule;
}
</code></pre> 
                    <p>It might expose three singleton beans:</p> 
                    <ul> 
                        <li><code>io.inverno.sample.coffeeMakerModule:coffeeBeansContainer</code> to be able to fill the coffee maker with beans</li> 
                        <li><code>io.inverno.sample.coffeeMakerModule:waterReservoir</code> for water supply</li> 
                        <li><code>io.inverno.sample.coffeeMakerModule:coffeeMaker</code> to actually make some coffee</li> 
                    </ul> 
                    <p><strong>CoffeeBeansContainer</strong></p> 
                    <pre><code class="language-java">public interface CoffeeBeansContainer {
    void fill(CoffeeBean[] beans);
}
</code></pre> 
                    <p><strong>WaterReservoir</strong></p> 
                    <pre><code class="language-java">public interface WaterReservoir {
    void fill(int waterQuantity);
}
</code></pre> 
                    <p><strong>CoffeeMaker</strong></p> 
                    <pre><code class="language-java">public interface CoffeeMaker {
    Coffee make();
}
</code></pre> 
                    <p>Inside a coffee shop application, you might instantiate several coffee maker modules used in the following way:</p> 
                    <pre><code class="language-java">PowerSupply powerSupply = ...                                                        // Get some power supply

CoffeeMakerModule coffeeMakerModule = new CoffeeMakerModule.Builder(powerSupply).build();
coffeeMakerModule.start();

ArabicaCoffeeBeans[]&nbsp;coffeeBeans = ...                                               // Get some tasty coffee beans
coffeeMakerModule.coffeeBeansContainer().fill(coffeeBeans);                          // fill the coffee beans container
coffeeMakerModule.waterReservoir().fill(1.5);                                        // fill the water reservoir with 1.5 Liters

CoffeeMaker coffeeMaker = coffeeMakerModule.coffeeMaker();                           // Get the coffee maker instance

Coffee coffee_1 = coffeeMaker.make();                            // Deliver some tasty coffees
...
Coffee coffee_n = coffeeMaker.make();

coffeeMakerModule.stop();
</code></pre> 
                    <p>The goal of this example was to show the benefits of using Inverno modules as standalone components in an application. As you can see:</p> 
                    <ul> 
                        <li>implementation details are completely hidden: you don't know and you don't have to know how the beans container, the water reservoir and the coffee maker are working together.</li> 
                        <li>dependencies are clearly exposed: you must provide some power supply to instantiate the module.</li> 
                        <li>only significant functionalities are exposed.</li> 
                        <li>if you look closely, you'll see that no particular technical framework is visible: from a code perspective, the application doesn't see and don't need to know it is using an Inverno module, everything is also statically typed and self-describing.</li> 
                    </ul> 
                    <h5 id="factory-component">Factory component</h5> 
                    <p>You can also create a module as a generic factory or builder to ease the creation of complex objects. If we consider previous example from a different perspective, we can imagine a factory module that could be used to build coffee makers from raw materials.</p> 
                    <p>It would also probably export the module's package so it can be used from outside the module:</p> 
                    <p><strong>module-info.java</strong></p> 
                    <pre><code class="language-java">@Module
Module io.inverno.sample.coffeeMakerFactoryModule {
    exports io.inverno.sample.coffeeMakerFactoryModule;
}
</code></pre> 
                    <p>Then it would expose the <code>io.inverno.sample.coffeeMakerFactoryModule:coffeeMaker</code> prototype bean:</p> 
                    <pre><code class="language-java">public interface CoffeeMaker {

    void fillWithCoffeeBeans(CoffeeBeans[] beans);
    
    void filleWithWater();
    
    Coffee makeCoffee();
}
</code></pre> 
                    <p>Inside a cooking appliances factory application, you might instantiate one or more coffee maker factory module to produce coffee makers:</p> 
                    <pre><code class="language-java">CoffeeMakerFactoryModule coffeeMakerFactoryModule = new CoffeeMakerFactoryModule.Builder(rawMaterials...).build();
coffeeMakerFactoryModule.start();

CoffeeMaker coffeeMaker_1 = coffeeMakerFactoryModule.coffeeMaker(); // We can massively produce coffee makers
...
CoffeeMaker coffeeMaker_n = coffeeMakerFactoryModule.coffeeMaker();

coffeeMakerFactoryModule.stop();
</code></pre> 
                    <p>The context and the approach are clearly different here, the purpose of a factory component module is to enable developers to use IoC/DI to easily create complex objects.</p> 
                    <h5 id="processing-component">Processing component</h5> 
                    <p>Dependency Injection is mostly about interconnecting objects to form an application, but this is more a consequence of how IoC/DI frameworks are designed than an absolute fact. An Inverno module is cheap, it can also be created and used during the operation of an application to process requests. This makes it possible to have data objects or contextual objects injected and used in bean instances.</p> 
                    <p>Let's say we have created a highly customizable coffee maker, capable of producing a coffee based on many parameters: steam pressure, temperature, grinding size... These parameters have to be used in various components of the coffee maker. These data have to be provided each time a customer orders a coffee</p> 
                    <p>Propagating the right data to the right coffee maker component can be a tedious task. An Inverno module can be created to inject data where they are needed based on the dependencies of each beans composing the coffee maker module and eventually process the request.</p> 
                    <pre><code class="language-java">public Coffee orderCoffee(Param_1 p1, Param_2 p2, ... Param_n pn) {
    // Receive a large amount of parameters to make a coffee
    
    try {
        CoffeeMakerModule coffeeMakerFactoryModule = new CoffeeMakerFactoryModule.Builder(p1, p2, ... pn).build(); // Parameters are injected only where they are needed
        coffeeMakerModule.start();
    
        return offeeMakerModule.coffeeMaker().makeCoffee();
    }
    finally {
        coffeeMakerFactoryModule.stop();
    }
}
</code></pre> 
                    <p>You can then benefit from dependency injection inside the business logic, performance shouldn't be impacted by bean instantiation or dependency injection logic because the creation of a module instance is no different than creating some objects with the <code>new</code> operator and invoking some setter methods. This is especially interesting when you have to process very complex requests with a lot of input data.</p> 
                    <h4 id="module-as-application">Module as application</h4> 
                    <p>An Inverno module can also be used to bootstrap a whole application. In such situation one single Inverno module is started as an application in the main method of a class. This class can be defined in the same module but this is not mandatory as long as it has access to the application module. The role of an application module is to create and start all the components of the application.</p> 
                    <pre><code class="language-java">public static void main(String[] args) {
    CoffeeMakerModule coffeeMakerModule = Application.with(new CoffeeMakerModule.Builder(...)).run();
    ...
}
</code></pre> 
                    <p>An application module is basically a regular module whose lifecycle is managed by the <code>Application</code> class. A module instance is created and started when the <code>run()</code> method is invoked and eventually stopped when the JVM shuts down.</p> 
                    <blockquote> 
                        <p>Note that this involves a shutdown hook, as a consequence there is actually no guarantee that the module will be stopped especially if the JVM is not gracefully shut down.</p> 
                    </blockquote> 
                    <p>Furthermore, an Inverno application outputs a customizable <code>Banner</code> on startup providing useful environment information in the application log.</p> 
                    <pre><code class="language-plaintext">mars 04, 2020 1:14:27 PM io.inverno.core.v1.Application run
INFO: Inverno is starting...


     â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
     â•‘                      , ~~ ,                                                                â•‘
     â•‘                  , '   /\   ' ,                                                            â•‘
     â•‘                 , __   \/   __ ,      _                                                    â•‘
     â•‘                ,  \_\_\/\/_/_/  ,    | |  ___  _    _  ___   __  ___   ___                 â•‘
     â•‘                ,    _\_\/_/_    ,    | | / _ \\ \  / // _ \ / _|/ _ \ / _ \                â•‘
     â•‘                ,   __\_/\_\__   ,    | || | | |\ \/ /|  __/| | | | | | |_| |               â•‘
     â•‘                 , /_/ /\/\ \_\ ,     |_||_| |_| \__/  \___||_| |_| |_|\___/                â•‘
     â•‘                  ,     /\     ,                                                            â•‘
     â•‘                    ,   \/   ,                                  -- 1.2.0 --                 â•‘
     â•‘                      ' -- '                                                                â•‘
     â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
     â•‘ Java runtime        : OpenJDK Runtime Environment                                          â•‘
     â•‘ Java version        : 12.0.2+10                                                            â•‘
     â•‘ Java home           : /home/jkuhn/Devel/jdk/jdk-12.0.2                                     â•‘
     â•‘                                                                                            â•‘
     â•‘ Application module  : io.inverno.sample.coffeeMakerModule                                  â•‘
     â•‘ Application class   : io.inverno.sample.coffeeMakerModule.App                              â•‘
     â•‘                                                                                            â•‘
     â•‘ Modules             :                                                                      â•‘
     â•‘  * ...                                                                                     â•‘
     â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


mars 04, 2020 1:14:27 PM io.inverno.core.v1.Module start
...
</code></pre> 
                    <p>The <code>StandardBanner</code> is displayed by default but you can specify custom implementations as well:</p> 
                    <pre><code class="language-java">public static void main(String[] args) {
    CustomBanner customBanner = ...
    CoffeeMakerModule coffeeMakerModule = Application.with(new CoffeeMakerModule.Builder(...)).banner(customBanner).run();
    ...
}
</code></pre> 
                    <h3 id="dependency-injection">Dependency Injection</h3> 
                    <p><a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a> principle is at the heart of the Inverno framework. Inside an Inverno module, beans instances are wired into each other based on their respective types and dependencies.</p> 
                    <p>In order to understand how this works, you could imagine that each bean exposes multiple sockets and that multiple wires leave the bean, as many as necessary. After creating and initializing bean instances, the module has to plug these wires into compatible sockets. The type of the wire, which is the type of the bean, must match the type of the socket, which is the type of the dependency defined in the bean.</p> 
                    <p>The result is modeled in a graph of beans built at compile time by the Inverno compiler which checks that it is a directed acyclic graph (ie. there's no cycles in the graph) and that there is a plug in each required socket. If everything is correct, a module class implementing the graph is created.</p> 
                    <blockquote> 
                        <p>Dependency injection is validated and fully determined at compile time, the module class just instantiates and injects beans in a predetermined order without having to worry about missing dependencies or dependency cycles amongst others.</p> 
                    </blockquote> 
                    <h4 id="bean-socket">Bean Socket</h4> 
                    <p>A <strong>bean socket</strong> designates a bean dependency. A bean can have two kinds of dependencies and then define two kinds of sockets: required and optional. Required dependencies must be resolved to create an operational bean instance whereas optional dependencies add extra capabilities to the bean instance. As a consequence, a module has to wire every required sockets, the Inverno compiler actually raises compilation errors on beans with unresolved required sockets.</p> 
                    <p>The Inverno framework tries to be as less intrusive as possible, a bean specifies its sockets using standard Java as constructor arguments for required sockets and setter methods for optional sockets. Creating a bean is then very natural.</p> 
                    <p>A bean socket is fully identified by its name, the name of the bean which defines it and the module in which the bean resides. The following notation is used to represent a bean socket qualified name: <code>[MODULE]:[BEAN]:[SOCKET_NAME]</code>. On a given bean in a given module, it is not possible to specify two sockets with the same name.</p> 
                    <p>Let's go back to our coffee maker example and define the dependencies of the <code>CoffeeMaker</code> bean.</p> 
                    <p><strong>CoffeeMakerImpl</strong></p> 
                    <pre><code class="language-java">@Bean
public class CoffeMakerImpl implements CoffeMaker {
    
    private PowerSupply powerSupply;
    
    private WaterReservoir waterReservoir;
    
    private CoffeeBeansContainer coffeeBeansContainer;
    
    public CoffeeMakerImpl(PowerSupply powerSupply, WaterReservoir waterReservoir, CoffeeBeansContainer coffeeBeansContainer) {
        this.powerSupply = powerSupply;
        this.waterReservoir = waterReservoir;
        this.coffeeBeansContainer = coffeeBeansContainer;
    }
    
    public Coffee make() {
        ...
    }
}
</code></pre> 
                    <p>The <code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl</code> bean then specifies three required sockets:</p> 
                    <ul> 
                        <li><code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl:powerSupply</code></li> 
                        <li><code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl:waterReservoir</code></li> 
                        <li><code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl:coffeeBeansContainer</code></li> 
                    </ul> 
                    <p>There should be only one public constructor defined in a bean class, this is actually proper bean design. Defining multiple constructors means that there are probably some dependencies not really required by the bean to work properly. Only required dependencies should be specified in a single bean constructor and optional dependencies in multiple setter methods. However if for some reasons multiple public constructors are defined on a bean class, you can explicitly specify which constructor to consider using the <code>@BeanSocket</code> annotation.</p> 
                    <pre><code class="language-java">@Bean
public class CoffeMakerImpl implements CoffeMaker {
    
    @BeanSocket
    public CoffeeMakerImpl(PowerSupply powerSupply, WaterReservoir waterReservoir, CoffeeBeansContainer coffeeBeansContainer) {
        ...
    }
    
    public CoffeeMakerImpl(PowerSupply powerSupply, WaterReservoir waterReservoir, CoffeeBeansContainer coffeeBeansContainer, SomeOptionalDependency dependency) {
        ...
    }
}
</code></pre> 
                    <p>The coffee maker should now have everything it needs to make coffee but let's say we want the coffee maker to be able to make cappuccinos, it will then need a <code>MilkFrother</code>. The coffee maker can use a <code>MilkFrother</code> when available but it doesn't require a <code>MilkFrother</code> to make coffee, only to make cappuccinos, as a result it should be declared in an optional socket.</p> 
                    <pre><code class="language-java">@Bean
public class CoffeMakerImpl implements CoffeMaker {
    
    ...    
    private MilkFrother milkFrother
    
    ...    
    public void setMilkFrother(MilkFrother milkFrother) {
        this.milkFrother = milkFrother;
    }
    
    public Coffee make() {
        ...
        if(this.milkFrother != null) {
            // Do something useful with the milk frother
            ...
        }
    }
}
</code></pre> 
                    <p>The <code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl</code> bean now specifies one optional socket: <code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl:milkFrother</code>.</p> 
                    <p>By convention, every setter method on a bean is considered an optional socket, this enforces proper bean design. However in some situations you might need to explicitly specify which setter methods are sockets. In order to do that, you need to annotate every socket setter method of the bean with the <code>@BeanSocket</code> annotation.</p> 
                    <pre><code class="language-java">@Bean
public class CoffeMakerImpl implements CoffeMaker {
    
    ...    
    @BeanSocket
    public void setMilkFrother(MilkFrother milkFrother) {
        ...
    }

    ...
    public void setSomethingElse() {
        ...
    }    
}
</code></pre> 
                    <blockquote> 
                        <p>Note that Inverno annotation are not inherited from ancestor class, the Inverno compiler only considers the bean class annotated with <code>@Bean</code> so you must explicitly override setter methods to specify optional sockets defined in a class ancestor. This might not be obvious but it is actually the safer way that gives a perfect control on the sockets you want to expose in your beans.</p> 
                    </blockquote> 
                    <h5 id="single-and-multiple">Single and multiple</h5> 
                    <p>We can differentiate two kinds of bean socket: single socket and multiple socket. A single socket can be of any type except arrays, <code>java.util.List</code>, <code>java.util.Set</code> and <code>java.util.Collection</code> whereas the type of a multiple socket is necessarily an array, a <code>java.util.List</code>, a <code>java.util.Set</code> or a <code>java.util.Collection</code>. Multiple beans can be wired to a multiple socket whereas only one bean is wired to a single socket.</p> 
                    <h5 id="lazy">Lazy</h5> 
                    <p>A socket can be annotated with the <code>@Lazy</code> to indicate that a bean instance supplier should be provided instead of an actual bean instance. A lazy socket must then necessarily be of type <code>Supplier&lt;E&gt;</code> which specifies the actual type of the socket as formal parameter.</p> 
                    <p>A lazy socket allows a dependent bean to lazily retrieve a bean instance. This presents several advantages when prototype beans are wired into a lazy socket, it is then possible to create fully wired bean instances on demand during the operation of a module and use them when processing a request for instance.</p> 
                    <h4 id="socket-bean">Socket Bean</h4> 
                    <p>Bean sockets designates the dependencies of a single bean. All beans in a module must be operational for a module to work properly as a consequence all beans required sockets must be resolved but what if one or more <em>plugs</em> are missing inside the module to match all these sockets? The dependency can then be declared at module level using a particular kind of bean: the <strong>socket bean</strong>.</p> 
                    <p>From inside a module, a socket bean is considered as any regular beans as it takes part in the dependency injection process. From outside the module, it designates a module dependency that is provided when a module is instantiated.</p> 
                    <p>Unlike other type of beans, a socket bean is not a concrete class, it must be an interface annotated with <code>@Bean</code> extending the <code>Supplier&lt;E&gt;</code> interface. The supplier's formal parameter designates the type of the dependency to provide.</p> 
                    <p>Let's say the coffee maker module does not provide any <code>PowerSupply</code> bean internally, this makes sense since a power supply might be required to make coffee but it is clearly unrelated. We must then find a way to provide a <code>PowerSupply</code> inside the module to make it work. We can then create a <code>PowerSupplySocket</code> socket bean inside the coffee maker module.</p> 
                    <pre><code class="language-java">@Bean
public interface PowerSupplySocket implements Supplier&lt;PowerSupply&gt; {}
</code></pre> 
                    <p>This creates socket bean <code>io.inverno.sample.coffeeMakerModule:powerSupplySocket</code> in the module <code>io.inverno.sample.coffeeMakerModule</code>. As you can imagine, this bean can be injected in other module's beans just like any regular beans.</p> 
                    <p>The module class generated by the Inverno compiler now defines an argument of type <code>PowerSupply</code> in the module's builder constructor, we must then provide a <code>PowerSupply</code> instance in order to instantiate the module.</p> 
                    <pre><code class="language-java">PowerSupply powerSupply = ...
CoffeeMakerModule coffeeMakerModule = new CoffeeMakerModule.Builder(powerSupply).build();
...
</code></pre> 
                    <p>A socket bean appears in the builder constructor when it is wired to a required bean socket inside the module. On the other hand, a socket bean wired to an optional bean socket appears in an extra method of the module's builder class.</p> 
                    <p>We might want to be able to stick a brand sticker on the coffee maker, this is obviously completely optional and external to the coffee maker module. We can then define a <code>BrandStickerSocket</code> in the module.</p> 
                    <pre><code class="language-java">BrandSticker brandSticker = ...
CoffeeMakerModule coffeeMakerModule = new CoffeeMakerModule.Builder(powerSupply).brandSticker(brandSticker).build();
...
</code></pre> 
                    <blockquote> 
                        <p>It is interesting to notice here that a Inverno module explicitly specifies its dependencies which is extremely valuable to create complex modular applications involving multiple people working together, one can easily understand how to use another one's module without mentioning the fact that the compiler can actually check that everything fits together since beans, modules and modules builder arguments are all statically typed.</p> 
                    </blockquote> 
                    <h4 id="wiring">Wiring</h4> 
                    <p>The Inverno compiler wires beans together based on the sockets defined in the module. A viable module is a module that has:</p> 
                    <ul> 
                        <li>all its required sockets resolved, either internally with another bean in the module or externally through a socket bean</li> 
                        <li>no cycles in the resulting graph of beans</li> 
                    </ul> 
                    <h5 id="autowiring">Autowiring</h5> 
                    <p>By default, the Inverno compiler tries to automatically wire the beans in a module based on their respective types and the types of the sockets they expose.</p> 
                    <p>In the coffee maker module we have the following beans:</p> 
                    <ul> 
                        <li><code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl</code></li> 
                        <li><code>io.inverno.sample.coffeeMakerModule:waterReservoirImpl</code></li> 
                        <li><code>io.inverno.sample.coffeeMakerModule:coffeeBeansContainerImpl</code></li> 
                        <li><code>io.inverno.sample.coffeeMakerModule:powerSupply</code> (socket bean)</li> 
                    </ul> 
                    <p>The <code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl</code> bean defines the following sockets:</p> 
                    <ul> 
                        <li><code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl:powerSupply</code></li> 
                        <li><code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl:waterReservoir</code></li> 
                        <li><code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl:coffeeBeansContainer</code></li> 
                        <li><code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl:milkFrother</code> (optional)</li> 
                    </ul> 
                    <p>This configuration results in the following graph of beans:</p> 
                    <img class="img-fluid mt-4 mb-5" src="img/coffee_maker_bean_graph.svg" alt="Beans dependency graph" /> 
                    <p>The module is viable since all required beans sockets are resolved and the graph of beans is a directed acyclic graph. The Inverno compiler can then generate a module class containing the logic to instantiate the beans in the right order and the dependency injection logic. When an instance of the <code>io.inverno.sample.coffeeMakerModule</code> module is started, the <code>waterReservoirImpl</code> bean and the <code>coffeeBeansContainerImpl</code> are instantiated first then the <code>coffeeMakerImpl</code> bean is instantiated next using previously created instances and the <code>powerSupply</code> instance injected when the module was created.</p> 
                    <p>In case one or more bean sockets cannot be resolved, the Inverno compiler outputs specific compilation errors for each one of them. When this happens, you must either define module beans or socket beans inside the module matching the unresolved sockets in order for the module to compile.</p> 
                    <blockquote> 
                        <p>You'll learn in the <a href="#modular-application">Modular application</a> section that there is another way to provide beans in a module by <em>composing</em> another Inverno module inside your module.</p> 
                    </blockquote> 
                    <h5 id="explicit-wiring">Explicit wiring</h5> 
                    <p>It is not possible for the Inverno compiler to automatically wire module beans when more than one bean matching a socket exists in the module. In that case, the Inverno compiler outputs specific compilation errors on bean sockets presenting such conflicts. In order for the module to compile, these conflicts must be explicitly resolved.</p> 
                    <p>Let's assume we actually have two beans of type <code>WaterReservoir</code> in the coffee maker module: <code>smallWaterReservoir</code> and <code>bigWaterReservoir</code>, the <code>coffeeMakerImpl</code> requires only one <code>WaterReservoir</code> since the <code>waterReservoir</code> socket is a single socket, we clearly have a conflict that the Inverno compiler cannot resolve on its own because it cannot decide for you which water reservoir bean is best suited. So you have to explicitly tell the Inverno compiler what to do using a <code>@Wire</code> annotation on the module definition:</p> 
                    <pre><code class="language-java">@Module
@Wire(beans="smallWaterReservoir", into="coffeeMakerImpl:waterReservoir")
Module io.inverno.sample.coffeeMakerModule {
    ...
}
</code></pre> 
                    <p>In the <code>@Wire</code> annotation the <code>beans</code> attribute is used to specify which beans must be wired into the socket specified in the <code>into</code> attribute.</p> 
                    <p>The <code>beans</code> attribute is an array of bean qualified names of the form <code>([MODULE]:)?[BEAN]</code>. If the module name is omitted, the compiler will look for beans in the current module. When defining a wire for a single socket, only one bean qualified name is expected.</p> 
                    <p>The <code>into</code> attribute is a bean socket qualified name of the form <code>([MODULE]|([MODULE]:)?[BEAN]):[SOCKET_NAME]</code>. When specifying a wire on a bean socket name which is necessarily defined in a bean in the current module, the module name can be omitted.</p> 
                    <blockquote> 
                        <p>The module name is in fact only necessary when specifying a wire on a socket bean of a module composed in a <a href="#composite-module">composite module</a>.</p> 
                    </blockquote> 
                    <p>Obviously, multiple <code>@Wire</code> annotations can be specified on a module definition. If a specified bean does not exist, if the specified socket does not exist, if the specified beans does not match the specified socket or if multiple beans were specified for a single socket, the Inverno compiler will raise compilation errors.</p> 
                    <p>Resolving conflicts is one way of using explicit wiring, but in the case of a multiple socket, you can also use a wire to explicitly select which beans you want to inject using the <code>@Wire</code> annotation. For instance, let's say we have a module with four beans of type <code>SomeType</code>: <code>beanA</code>, <code>beanB</code>, <code>beanC</code>, <code>beanD</code> and another bean which defines a multiple socket of the same type (eg. <code>List&lt;SomeType&gt;</code>), if you do nothing, by default the Inverno compiler will automatically wire all four into the multiple socket, if you want to inject only <code>beanA</code> and <code>beanB</code> you can specify the following on the module definition:</p> 
                    <pre><code class="language-java">@Module
@Wire(beans={"beanA", "beanB"}, into="someBean:multipleSomeType")
Module someModule {
    ...
}
</code></pre> 
                    <blockquote> 
                        <p>It's interesting to see that it is not on the socket that the conflict is resolved but on the module that actually created that conflict. This is quite different than other DI frameworks that use qualifiers specified on the conflicting injection point. With these approaches, In order to properly separate the concerns a bean should not know the name of the actual bean that will be injected, as a result it is up to the bean to define the qualifiers and up to the other beans to be named or aliased after these qualifiers but this means the bean still know that a conflict exist otherwise it wouldn't need to specify any qualifier. The Inverno framework eliminates this issue to enforce proper separation of concerns.</p> 
                    </blockquote> 
                    <h5 id="selector">Selector</h5> 
                    <p>Beans are always wired to sockets based on their types, selectors provide another level of filtering. They are used to specify what compile time properties a bean type must have to be wired to a particular socket.</p> 
                    <p>Selectors are annotations annotated with <code>@Selector</code> that can be specified on both bean sockets and socket beans. The framework currently supports the <code>@AnnotationSelector</code> that lets you filter beans based on a particular annotation.</p> 
                    <p>Let's say, you finally decided to provide a milk frother to the coffee maker which is unfortunately only compatible with milk frothers of a particular brand. To do so, you can define a <code>@SuperSteam</code> annotation for the brand and tell the Inverno compiler to make sure the milk forther wired to the coffee maker is annotated with it.</p> 
                    <pre><code class="language-java">public @interface SuperSteam {}
</code></pre> 
                    <pre><code class="language-java">@Bean
public class CoffeMakerImpl implements CoffeMaker {
    
    ...
    public void setMilkFrother(@AnnotationSelector(SuperSteam.class) MilkFrother milkFrother) {
        ...
    }

}
</code></pre> 
                    <p>If no bean of type <code>MilkForther</code> annotated with <code>@SuperSteam</code> exists, a compilation error is raised.</p> 
                    <blockquote> 
                        <p>It's important to understand here that the Inverno compiler considers the declared type of a bean which is not necessarily the actual type of the runtime instance. This is especially true when defining a <a href="#provided-type">provided type</a> in a bean class, the selector annotation must then be specified on the provided type and not the actual bean class.</p> 
                    </blockquote> 
                    <h3 id="modular-application">Modular application</h3> 
                    <p>Modularity is at the heart of the Inverno framework, it has been built on the idea that flexibility, maintainability and stability, especially on large and complex applications can only be achieved through a proper modularization and strict <a href="https://en.wikipedia.org/wiki/Separation_of_concerns">separation of concerns</a>.</p> 
                    <p>So far, we explored how to define and compose beans inside a module to implement a wider component or a standalone application but the Inverno framework also allows the composition of modules to create even more complex components and applications.</p> 
                    <h4 id="composite-module">Composite module</h4> 
                    <p>A <strong>composite module</strong> is literally a module composed of multiple Inverno modules. Concretely, all public beans exposed in a component module are considered for dependency injection in the composite module. In the same way, socket beans defined in a component module are resolved with the beans available in the composite module.</p> 
                    <p>By default, any Inverno module required in the module descriptor of a Inverno module are composed by the Inverno compiler inside the module class. Component modules public beans are encapsulated in the composite module class and then only accessible from within that module. At runtime, component modules are instantiated and started along with the composite module which wires their public beans into the module's beans sockets or into other component modules socket beans.</p> 
                    <p>Let's assume module <code>io.inverno.sample.milkFrotherModule</code> provides a <code>MilkFrother</code> bean compatible with the coffee maker. You can simply declare it as required in the module descriptor of the <code>io.inverno.sample.coffeeMakerModule</code> module to get the milk frother module created and started along with the coffee maker module and eventually wire the milk frother into the coffee maker.</p> 
                    <pre><code class="language-java">@Module
Module io.inverno.sample.coffeeMakerModule {
    ...
    requires io.inverno.sample.milkFrotherModule;
    ...
}
</code></pre> 
                    <p>The Inverno compiler will find out that the milk frother module provides a bean matching coffee maker optional milk frother socket and do the wiring in the module class.</p> 
                    <p>In some situations, you might want to explicitly include or exclude required modules from the module composition, you can do this using <code>includes</code> and <code>excludes</code> attributes in the <code>@Module</code> annotation. This is useful when you just want to use types from another module without instantiating it.</p> 
                    <pre><code class="language-java">@Module(includes={"moduleA", "moduleB"})
Module someModule {
    ...
    requires moduleA;
    requires moduleB;
    requires moduleC; // moduleC will be ignored by the Inverno compiler
    ...
}
</code></pre> 
                    <p>In order for the module to compile, all required socket beans defined in component modules must be resolved. They can be resolved with any beans available in the composite module including beans, socket beans or any public beans provided in other component modules.</p> 
                    <p>Explicit wiring can be used as described before using fully qualified names for component modules public beans or socket beans.</p> 
                    <pre><code class="language-java">@Module
@Wire(beans="moduleA:bean1", into="someBean:socket")     // Explicitly wire bean 'bean1' of component module 'moduleA' into bean socket 'socket' in bean 'someBean' of module 'someModule'
@Wire(beans="moduleB:bean2", into="moduleC:socketBean")  // Explicitly wire bean 'bean2' of component module 'moduleB' into socket bean 'socketBean' of module 'moduleC'
Module someModule {
    ...
    requires moduleA;
    requires moduleB;
    requires moduleC;
    ...
}
</code></pre> 
                    <p>Module composition offers greater flexibility when using or designing modules. A typical Inverno application module would be a simple composition of multiple Inverno modules implementing different aspects. Multiple modules inside an application can depend on the same module but with different instances which limits the possibility of collisions and increases reusability. Indeed when developing a module you don't have to worry about the context in which it will be used or executed, you can focus on the feature it provides, external dependencies can be provided internally through module composition or externally through socket beans.</p> 
                    <h4 id="provided-type">Provided type</h4> 
                    <p>By default, the type of a bean is given by the class defining the bean, for a module bean it is the annotated class and for a wrapper bean it is the formal parameter specified in the <code>Supplier&lt;E&gt;</code> interface.</p> 
                    <p>This basically means that the type of a public bean must be accessible from outside the module, its package must then be exported in the module descriptor. However, you might, and probably will, need to hide bean implementations and only expose public API types.</p> 
                    <p>You can control which type is actually provided by a bean using the <code>@Provide</code> annotation. A bean can only provide one type.</p> 
                    <p>Let's see how it works for the <code>io.inverno.sample.coffeeMakerModule:coffeeMakerImpl</code> bean:</p> 
                    <pre><code class="language-java">@Bean
public class CoffeMakerImpl implements @Provide CoffeMaker {
    ...
}
</code></pre> 
                    <p>The <code>CoffeeMakerImpl</code> class can implement several types but it will be exposed as a <code>CoffeeMaker</code> in the module class.</p> 
                    <blockquote> 
                        <p>The <code>@Provide</code> annotation is only useful on module bean, for w beans the implementation type is already hidden in the <code>Supplier#get()</code> method and the provided type is the formal parameter specified in the <code>Supplier&lt;E&gt;</code> interface.</p> 
                    </blockquote> 
                    <p>The provided type is only considered outside the module when used in a composite module or in an application. Inside the module, the actual bean type is always used for dependency injection.</p> 
                    <p>Hiding implementation and only expose public API is very convenient when you developed a component module and it is a best practice in general if you want to enforce modularity inside an application. Most of the time modules should always depend on public API so from a dependency injection perspective it doesn't really matters whether a module expose implementation classes but you can't guarantee that nobody will ever create a dependency on an implementation class if that class is accessible which would be quite bad for maintainability. Being able to control the types actually exposed in a module enforces a proper isolation.</p> 
                    <blockquote> 
                        <p>Particular care must be taken when using <a href="#selector">selectors</a> in a composite module, the type of component modules beans considered by the Inverno compiler will be the provided types, so if you want to specify properties matching selectors, you have to specify them on the provided types and not the actual beans types.</p> 
                    </blockquote> 
                    <h2 id="inverno-modules-1">Inverno Modules</h2> 
                    <h3 id="motivation-1">Motivation</h3> 
                    <p>Built on top of the <a href="https://github.com/inverno-io/inverno-core">Inverno core IoC/DI framework</a>, Inverno modules suite aimed to provide a complete set of features to develop high end production-grade applications.</p> 
                    <p>The advent of cloud computing and highly distributed architecture based on microservices has changed the way applications should be conceived, maintained, executed and operated. While it was perfectly fine to have application started in couple of seconds or even minutes some years ago with long release cycles, today's application must be highly efficient, agile in terms of development and deployment and start in a heart beat.</p> 
                    <p>The Inverno framework was created to reduce framework overhead at runtime to the minimum, allowing to create applications that start in milliseconds. Inverno modules extend this approach to provide functionalities with low footprint, relying on the compiler when it makes sense to generate human-readable code for easy maintenance and improved performance.</p> 
                    <p>An agile application is naturally modular which is the essence of the Inverno framework, but it must also be highly configurable and customizable in many ways using configuration data distributed in various data stores and that greatly depend on the context such as an execution environment: test, production..., a location: US, Europe, Asia..., a particular customer, a particular user... Advanced configuration capabilities are then essential to build modern applications.</p> 
                    <p>Traditional application servers and frameworks used to be based on inefficient threading models that didn't make fair use of hardware resources which make them bad cloud citizens. Inverno applications are one hundred percent reactive making maximum use of the allocated resources.</p> 
                    <p>The primary goals can be summarized as follows:</p> 
                    <ul> 
                        <li>provide a complete set of common features to build any kind of applications</li> 
                        <li>maintain a high level of performance...</li> 
                        <li>...but always choose modularity and maintainability over performance to favor agility</li> 
                        <li>be explicit and consistent, there's nothing worse than ambiguity and disparateness, the <em>you have to know</em>s must be minimal and logical.</li> 
                        <li>provide advanced configuration and customization features</li> 
                    </ul> 
                    <h3 id="prerequisites-1">Prerequisites</h3> 
                    <p>Before we can dig into the various modules provided in the framework, it is important to understand how to setup a modular Inverno project, so please have a look at the <a href="https://github.com/inverno-io/inverno-dist">Inverno distribution documentation</a> which describes in details how to create, build, run, package and distribute a modular Inverno component or application.</p> 
                    <p>Inverno modules are built on top of the Inverno core IoC/DI framework, please refer to the <a href="https://github.com/inverno-io/inverno-core/tree/master/doc/reference-guide.md">Inverno core documentation</a> to understand how IoC/DI is working in the framework.</p> 
                    <p>The framework is fully reactive thanks to <a href="https://projectreactor.io/">Project Reactor Core library</a>, it is strongly recommended to also look at <a href="https://projectreactor.io/docs/core/release/reference/">the reference documentation</a>.</p> 
                    <h3 id="overview-2">Overview</h3> 
                    <p>The basic Inverno application is an Inverno module composing the <em>boot</em> module which provides common services. Other Inverno modules can then be added by defining the corresponding dependencies in the module descriptor.</p> 
                    <pre><code class="language-java">@io.inverno.core.annotation.Module
module io.inverno.example.app {
    requires io.inverno.mod.boot;
    // Other modules...
}
</code></pre> 
                    <p>Declaring a dependency to the <em>boot</em> module automatically includes core IoC/DI modules as well as <em>base</em> module, <em>configuration</em> module and reactive framework dependencies.</p> 
                    <p>A basic application can then be created as follows:</p> 
                    <pre><code class="language-java">import io.inverno.core.v1.Application;

public class Main {

    public static void main(String[] args) {
        Application.with(new App.Builder()).run();
    }
}
</code></pre> 
                    <p>Inverno modules are fully integrated which means they have been designed to work together in an Inverno component or application but this doesn't mean it's not possible to embed them independently in any kind of application following the agile principle. For instance, the <em>configuration</em> module, can be easily used in any application with limited dependency overhead. More generally, an Inverno module can be created and started very easily in pure Java thanks to the Inverno core IoC/DI framework.</p> 
                    <p>For instance, an application can embed a HTTP server as follows:</p> 
                    <pre><code class="language-java">Boot boot = new Boot.Builder().build();
boot.start();

Server httpServer = new Server.Builder(boot.netService(), boot.resourceService())
    .setHttpServerConfiguration(HttpServerConfigurationLoader.load(conf -&gt; conf.server_port(8080)))
    .setRootHandler(
        exchange -&gt; exchange
            .response()
            .body()
            .raw()
            .value(Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("Hello, world!", Charsets.DEFAULT)))
    )
    .build();

httpServer.start();
...
httpServer.stop();
boot.stop();
</code></pre> 
                    <blockquote> 
                        <p>Note that as for any Inverno module, dependencies are clearly specified and must be provided when creating a module, in the previous example the HTTP server requires a <code>NetService</code> and a <code>ResourceService</code> which are normally provided by the boot module but custom implementations can be provided. It is also possible to create an Inverno module composing the <em>boot</em> and <em>http-server</em> modules to let the framework deal with dependency injection.</p> 
                    </blockquote> 
                    <h3 id="base">Base</h3> 
                    <p>The Inverno <em>base</em> module defines the foundational APIs used across all modules, it can be seen as an extension to the <em>java.base</em> module.</p> 
                    <p>In order to use the Inverno <em>base</em> module, we need to declare a dependency in the module descriptor:</p> 
                    <pre><code class="language-java">module io.inverno.example.app {
    requires io.inverno.mod.base;
    ...
}
</code></pre> 
                    <p>The <em>base</em> module declares transitive dependencies to reactive APIs which don't need to be re-declared.</p> 
                    <p>We also need to declare that dependency in the build descriptor:</p> 
                    <p>Using Maven:</p> 
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-base&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre> 
                    <p>Using Gradle:</p> 
                    <pre><code class="language-groovy">...
compile 'io.inverno.mod:inverno-base:1.0.0'
...
</code></pre> 
                    <p>The <em>base</em> module is usually provided as a transitive dependency by other modules, mainly the <em>boot</em> module, so defining a direct dependency is usually not necessary at least for an application module.</p> 
                    <h4 id="converter-api">Converter API</h4> 
                    <p>The converter API provides interfaces and classes for building converters, decoders or encoders which are basically used to decode/encode objects of a given type from/to objects of another type.</p> 
                    <h5 id="basic-converter">Basic converter</h5> 
                    <p>The <code>Converter</code> interface defines a basic converter. It simply extends <code>Decoder</code> and <code>Encoder</code> interfaces which defines respectively the basic decoder and the basic encoder.</p> 
                    <p>A basic decoder is used to decode an object of a source type to an object of a target type. For instance, we can create a simple string to integer decoder as follows:</p> 
                    <pre><code class="language-java">public class StringToIntegerDecoder {
    
    @Override
    public &lt;T extends Integer&gt; T decode(String value, Class&lt;T&gt; type) throws ConverterException {
        return (T)Integer.valueOf(value);
    }
    
    @Override
    public &lt;T extends Integer&gt; T decode(String value, Type type) throws ConverterException {
        return (T)Integer.valueOf(value);
    }
}
Decoder&lt;String, Integer&gt; 
</code></pre> 
                    <p>A basic encoder is used to encode an object of a source type to an object of a target type. For instance, we can create a simple integer to string encoder as follows:</p> 
                    <pre><code class="language-java">public class IntegerToStringEncoder implements Encoder&lt;Integer, String&gt; {
    
    @Override
    public &lt;T extends Integer&gt; String encode(T value) throws ConverterException {
        return value.toString();
    }
    
    @Override
    public &lt;T extends Integer&gt; String encode(T value, Class&lt;T&gt; type) throws ConverterException {
        return value.toString();
    }
    
    @Override
    public &lt;T extends Integer&gt; String encode(T value, Type type) throws ConverterException {
        return value.toString();
    }
}
</code></pre> 
                    <p>A string to integer converter can then be created by combining both implementations.</p> 
                    <p>The previous example while not very representative illustrates the basic decoder and encoder API, you should now wonder how to use this properly in an application and what is the fundamental difference between a decoder and an encoder, the answer actually lies in the names. A decoder is meant to <em>decode</em> data formatted in a particular way into a representation that can be used in an application whereas an encoder is meant to <em>encode</em> an object in an application into data formatted in a particular way. From there, we understand that a converter can be used to read or write raw data (JSON data in an array of bytes for instance) to or from actual usable representations in the form of Java objects but it can also be used as an object mapper to convert from one representation to another (domain object to data transfer object for instance).</p> 
                    <p>A more realistic example would then be a JSON string to object converter:</p> 
                    <pre><code class="language-java">public class JsonToObjectConverter implements Converter&lt;String, Object&gt; {
    
    private ObjectMapper mapper = new ObjectMapper();
    
    @Override
    public &lt;T&gt; T decode(String value, Class&lt;T&gt; type) throws ConverterException {
        try {
            return this.mapper.readValue(value, type);
        } 
        catch (JsonProcessingException e) {
            throw new ConverterException(e);
        }
    }
    
    @Override
    public &lt;T&gt; T decode(String value, Type type) throws ConverterException {
        ...
    }
    
    @Override
    public &lt;T&gt; String encode(T value) throws ConverterException {
        try {
            return this.mapper.writeValueAsString(value);
        } 
        catch (JsonProcessingException e) {
            throw new ConverterException(e);
        }
    }
    
    @Override
    public &lt;T&gt; String encode(T value, Class&lt;T&gt; type) throws ConverterException {
        ...
    }
    
    @Override
    public &lt;T&gt; String encode(T value, Type type) throws ConverterException {
        ...
    }
}
</code></pre> 
                    <p>The API provides other interfaces to create converters, decoders and encoders with more capabilities.</p> 
                    <h5 id="splittable-decoder-and-joinable-encoder">Splittable decoder and Joinable encoder</h5> 
                    <p>A <code>SplittableDecoder</code> is a particular decoder which allows to decode an object of a source type into multiple objects of a target type. It specifies methods to decode one source instance into an array, a list or a set of target instances.</p> 
                    <p>In the same way, a <code>JoinableEncoder</code> is a particular encoder which allows to encode multiple objects of a source type into one single object of a target type. It specifies methods to encode an array, a list or a set of source instances into a single target instance.</p> 
                    <p>The <code>StringConverter</code> is a typical implementation that can decode or encode multiple parameters values.</p> 
                    <pre><code class="language-java">StringConverter converter = new StringConverter();

// List.of(1, 2, 3)
List&lt;Integer&gt; l = converter.decodeToList("1,2,3", Integer.class); 
// "1,2,3"
String s = converter.encodeList(List.of(1, 2, 3));
</code></pre> 
                    <h5 id="primitive-decoder-and-encoder">Primitive decoder and encoder</h5> 
                    <p>A <code>PrimitiveDecoder</code> is fundamentally an object decoder which provides bindings to decode an object of a source type into an object of primitive (boolean, integer...) or common type (string, date, URI...).</p> 
                    <p>In the same way, a <code>PrimitiveEncoder</code> is fundamentally an object encoder which provides bindings to encode an object of a primitive or common type to an object of a target type.</p> 
                    <p>The <code>StringConverter</code> which is meant to convert parameter values is again a typical use case of primitive decoder and encoder.</p> 
                    <pre><code class="language-java">StringConverter converter = new StringConverter();

// 123l
long l = converter.decodeLong("123");
// ISO-8601 date: "yyyy-MM-dd"
String s = converter.encode(LocalDate.now());
</code></pre> 
                    <p>The <code>SplittablePrimitiveDecoder</code> and <code>JoinablePrimitiveEncoder</code> are primitive decoder and encoder that respectively extends <code>SplittableDecoder</code> and <code>JoinableEncoder</code>.</p> 
                    <h5 id="object-converter">Object converter</h5> 
                    <p>An <code>ObjectConverter</code> is a convenient interface for building <code>Object</code> converters. It extends <code>Converter</code>, <code>SplittablePrimitiveDecoder</code> and <code>JoinablePrimitiveEncoder</code>.</p> 
                    <h5 id="reactive-converter">Reactive converter</h5> 
                    <p>A <code>ReactiveConverter</code> is a particular converter which extends <code>ReactiveDecoder</code> and <code>ReactiveEncoder</code> for building reactive converters which are particularly useful to convert data from non-blocking I/O channels.</p> 
                    <p>The <code>ReactiveDecoder</code> interface defines methods to decode one or many objects of a target type from a stream of objects of a source type. In the same way, the <code>ReactiveEncoder</code> interface defines methods to encode one or many objects of a source type into a stream of objects of target type.</p> 
                    <p>The <code>ByteBufConverter</code> is a typical use case, it is meant to convert data from non-blocking channels like the request or response payloads in a network server or client, or the content of a resource read asynchronously.</p> 
                    <pre><code class="language-java">ByteBufConverter converter = new ByteBufConverter(new StringConverter());

Publisher&lt;ByteBuf&gt; dataStream = ... // comes from a request or resource

// On subscription, chunk of data accumulates until a complete response can be emitted
Mono&lt;ZonedDateTime&gt; dateTimeMono = converter.decodeOne(dataStream, ZonedDateTime.class); 

// On subscription, a stream of integer is mapped to a publisher of ByteBuf
Publisher&lt;ByteBuf&gt; integerStream = converter.encodeMany(Flux.just(1,2,3,4));
</code></pre> 
                    <h5 id="media-type-converter">Media type converter</h5> 
                    <p>A <code>MediaTypeConverter</code> is a particular kind of object converter which supports a specific format specified as a <a href="https://en.wikipedia.org/wiki/Media_type">media type</a> and converts object from/to raw data in the supported format. A typical example would be a JSON media type converter used to decode/encode raw JSON data.</p> 
                    <blockquote> 
                        <p>The <em>web</em> module relies on such converters to respectively decode end encode HTTP request and HTTP response payloads based on the content type specified in the message headers.</p> 
                    </blockquote> 
                    <h5 id="composite-converter">Composite converter</h5> 
                    <p>A <code>CompositeConverter</code> is an extensible object converter based on a <code>CompositeDecoder</code> and a <code>CompositeEncoder</code> which themselves rely on multiple <code>CompoundDecoder</code> and <code>CompoundEncoder</code> to extend or override respectively the decoding and encoding capabilities of the converter. In practical terms, it is possible to make a converter able to decode or encode any type of object by providing ad hoc compound decoders and encoders.</p> 
                    <p>The <code>StringCompositeConverter</code> is a composite converter implementation which uses a default <code>StringConverter</code> to convert primitive and common types of objects, it can be extended to convert other types of object.</p> 
                    <p>For instance, let's consider the following <code>Message</code> class:</p> 
                    <pre><code class="language-java">public static class Message {

    private String message;

    // constructor, getter, setter
    ...
}
</code></pre> 
                    <p>We can create specific compound decoder and encoder to respectively decode and encode a <code>Message</code> from/to a string as follows:</p> 
                    <pre><code class="language-java">public static class MessageDecoder implements CompoundDecoder&lt;String, Message&gt; {

    @SuppressWarnings("unchecked")
    @Override
    public &lt;T extends Message&gt; T decode(String value, Class&lt;T&gt; type) throws ConverterException {
        return (T) new Message(value);
    }
    
    @SuppressWarnings("unchecked")
    @Override
    public &lt;T extends Message&gt; T decode(String value, Type type) throws ConverterException {
        return (T) new Message(value);
    }
    
    @Override
    public &lt;T extends Message&gt; boolean canDecode(Class&lt;T&gt; type) {
        return Message.class.equals(type);
    }
    
    @Override
    public boolean canDecode(Type type) {
        return Message.class.equals(type);
    }
}
</code></pre> 
                    <pre><code class="language-java">public static class MessageEncoder implements CompoundEncoder&lt;Message, String&gt; {
    
    @Override
    public &lt;T extends Message&gt; String encode(T value) throws ConverterException {
        return value.getMessage();
    }
    
    @Override
    public &lt;T extends Message&gt; String encode(T value, Class&lt;T&gt; type) throws ConverterException {
        return value.getMessage();
    }
    
    @Override
    public &lt;T extends Message&gt; String encode(T value, Type type) throws ConverterException {
        return value.getMessage();
    }
    
    @Override
    public &lt;T extends Message&gt; boolean canEncode(Class&lt;T&gt; type) {
        return Message.class.equals(type);
    }
    
    @Override
    public boolean canEncode(Type type) {
        return Message.class.equals(type);
    }
}
</code></pre> 
                    <p>And inject them into a string composite converter which can then decode/encode <code>Message</code> object:</p> 
                    <pre><code class="language-java">CompoundDecoder&lt;String, Message&gt; messageDecoder = new MessageDecoder();
CompoundEncoder&lt;Message, String&gt; messageEncoder = new MessageEncoder();

StringCompositeConverter converter = new StringCompositeConverter();
converter.setDecoders(List.of(messageDecoder));
converter.setEncoders(List.of(messageEncoder));

Message decodedMessage = converter.decode("this is an encoded message", Message.class);
String encodedMessage = converter.encode(new Message("this is a decoded message"));
</code></pre> 
                    <h4 id="net-api">Net API</h4> 
                    <p>The Net API provides interfaces and classes to manipulate basic network elements such as URIs or to create basic network clients and servers.</p> 
                    <h5 id="uris">URIs</h5> 
                    <p>A URI follows the standard defined by <a href="https://tools.ietf.org/html/rfc3986">RFC 3986</a>, it is mostly used to identify resources such as file or more specifically a route in a Web server. The JDK provides a standard implementation which is not close to what is required by the <em>web</em> module to name just one.</p> 
                    <p>The <code>URIs</code> utility class is the main entry point for working on URIs in any ways imaginable. It defines methods to create a blank URI or a URI based on a given path or URI. These methods return a <code>URIBuilder</code> instance which is then used to build a URI, a path, a query string or a URI pattern.</p> 
                    <p>A simple URI can then be created as follows:</p> 
                    <pre><code class="language-java">// http://localhost:8080/path/to/resource?parameter=value
URI uri = URIs.uri()
    .scheme("http")
    .host("localhost")
    .port(8080)
    .path("/path/to/resource")
    .queryParameter("parameter", "value")
    .build();
</code></pre> 
                    <p>or from an existing URI as follows:</p> 
                    <pre><code class="language-java">// https://test-server/path/to/resource
URI uri = URIs.uri(URI.create("http://localhost:8080/path/to?parameter=value"))
    .scheme("https")
    .host("test-server")
    .port(null)
    .segment("resource")
    .clearQuery()
    .build();
</code></pre> 
                    <p>A URI can be normalized by enabling the <code>URIs.Option.NORMALIZED</code> option:</p> 
                    <pre><code class="language-java">// path/to/other
URI uri = URIs.uri("path/to/resource", URIs.Option.NORMALIZED)
    .segment("..")
    .segment("other")
    .build();
</code></pre> 
                    <p>A parameterized URI can be created by enabling the <code>URIs.Option#PARAMETERIZED</code> option and specifying parameters of the form <code>{[&lt;name&gt;][:&lt;pattern&gt;]}</code> in the components of the URI. This allows to create URI templates that can be used to generate URIs from a set of parameters.</p> 
                    <pre><code class="language-java">URIBuilder uriTemplate = URIs.uri(URIs.Option.PARAMETERIZED)
    .scheme("{scheme}")
    .host("{host}")
    .path("/path/to/resource")
    .segment("{id}")
    .queryParameter("format", "{format}");

// http://locahost/path/to/resource/1?format=text
URI uri1 = uriTemplate.build("http", "localhost", "1", "text");

// https://production/path/to/resource/32?format=json
URI uri2 = uriTemplate.build("https", "production", "32", "json");
</code></pre> 
                    <p>The <code>URIBuilder</code> also defines methods to create string representations of the whole URI, the path component or the query component.</p> 
                    <pre><code class="language-java">URIBuilder uriBuilder = URIs.uri()
    .scheme("http")
    .host("localhost")
    .port(8080)
    .path("/path/to/resource")
    .queryParameter("parameter", ""value);

// http://localhost:8080/path/to/resource?parameter=value
String uri = uriBuilder.buildString();

// path/to/resource
String path = uriBuilder.buildPath();

// parameter=value
String query = uriBuilder.buildQuery();
</code></pre> 
                    <p>It can also create <code>URIPattern</code> to match a given input against the pattern specified by the URI while extracting parameter values when the URI is parameterized.</p> 
                    <pre><code class="language-java">URIPattern uriPattern = URIs.uri(URIs.Option.PARAMETERIZED)
    .scheme("{scheme}")
    .host("{host}")
    .path("/path/to/resource")
    .segment("{id}")
    .queryParameter("format", "{format}")
    .buildPattern();

URIMatcher matcher = uriPattern.matcher("http://localhost:8080/path/to/resource/1?format=text");
if(matcher.matches()) {
    // scheme=http, host=localhost, id=1, format=text
    Map&lt;String, String&gt; parameters = matcher.getParameters();
    ...
}
</code></pre> 
                    <h5 id="network-service">Network service</h5> 
                    <p>The <code>NetService</code> interface specifies a service for building optimized network clients and servers based on Netty. The <em>base</em> module doesn't provide any implementation, a base implementation is provided in the <em>boot</em> module.</p> 
                    <p>This service especially defines methods to obtain <code>EventLoopGroup</code> instances backed by a root event loop group in order to reuse event loops across different network servers or clients running in the same application.</p> 
                    <p>It also defines methods to create basic network client and server bootstraps.</p> 
                    <h4 id="reflection-api">Reflection API</h4> 
                    <p>The reflection API provides classes and interfaces for building <code>java.lang.reflect.Type</code> instances in order to represent parameterized types at runtime which is otherwise not possible due to type erasure. Such <code>Type</code> instances are used when decoding data into objects of parameterized types.</p> 
                    <p>The <code>Types</code> class is the main entry point for building any kind of Java types.</p> 
                    <pre><code class="language-java">// java.util.List&lt;? extends java.lang.Comparable&lt;java.lang.String&gt;&gt;
Type type = Types.type(List.class)
    .wildcardType()
        .upperBoundType(Comparable.class)
            .type(String.class).and()
    .and()
    .build();
</code></pre> 
                    <p>The reflection API is particularly useful to specify a parameterized type to an <a href="#object-converter">object converter</a>. For instance, let's imagine we have a <code>ByteBuf</code> we want to decode to a <code>List&lt;String&gt;</code>, we can do:</p> 
                    <pre><code class="language-java">ByteBuf input = ...;
ObjectConverter&lt;ByteBuf&gt; converter = ...;

Type listOfStringType = Types.type(List.class)
    .type(String.class).and()
    .build();
List&lt;String&gt; decode = converter.&lt;List&lt;String&gt;&gt;decode(input, listOfStringType);
</code></pre> 
                    <h4 id="resource-api">Resource API</h4> 
                    <p>The resource API provides classes and interfaces for accessing resources of different kinds and locations (file, zip, jar, classpath, module...) in a consistent way using a unique <code>Resource</code> interface.</p> 
                    <p>A resource can be created directly using the implementation corresponding to the kind of resource. For instance, in order to access a resource on the class path, you need to choose the <code>ClasspathResource</code> implementation:</p> 
                    <pre><code class="language-java">ClasspathResource resource = new ClasspathResource(URI.create("classpath:/path/to/resource"));
</code></pre> 
                    <p>A resource is identified by a URI whose scheme specifies the kind of resources. The <em>base</em> module provides several implementations with a corresponding scheme.</p> 
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered "> 
                            <tbody>
                                <tr> 
                                    <th>Type</th> 
                                    <th>URI</th> 
                                    <th>Implementation</th> 
                                </tr> 
                                <tr> 
                                    <td><code>file</code></td> 
                                    <td><code>file:/path/to/resource</code></td> 
                                    <td><code>FileResource</code></td> 
                                </tr> 
                                <tr> 
                                    <td><code>zip</code></td> 
                                    <td><code>zip:/path/to/zip!/path/to/resource</code></td> 
                                    <td><code>ZipResource</code></td> 
                                </tr> 
                                <tr> 
                                    <td><code>jar</code></td> 
                                    <td><code>jar:/path/to/jar!/path/to/resource</code></td> 
                                    <td><code>JarResource</code></td> 
                                </tr> 
                                <tr> 
                                    <td><code>url</code></td> 
                                    <td><code>http|https|ftp://host/path/to/resource</code></td> 
                                    <td><code>URLResource</code></td> 
                                </tr> 
                                <tr> 
                                    <td><code>classpath</code></td> 
                                    <td><code>classpath:/path/to/resource</code></td> 
                                    <td><code>ClasspathResource</code></td> 
                                </tr> 
                                <tr> 
                                    <td><code>module</code></td> 
                                    <td><code>module://[MODULE_NAME]/path/to/resource</code></td> 
                                    <td><code>ModuleResource</code></td> 
                                </tr> 
                            </tbody>
                        </table>
                    </div> 
                    <p>The <code>ResourceService</code> interface specifies a service which provides a unified access to resources based only on the resource URI. The <em>base</em> module doesn't provide any implementation, a base implementation is provided in the <em>boot</em> module.</p> 
                    <p>A typical use case is to get a resource from a URI without knowing the actual kind of the resource.</p> 
                    <pre><code class="language-java">ResourceService resourceService = ...

Resource resource = resourceService.getResource(URI.create("classpath:/path/to/resource"));
</code></pre> 
                    <p>The resource service can also be used to list resources at a given location. Nonetheless this actually depends on the implementation and the kind of resource, although it is clearly possible to list resources from a file location, it might not be supported to list resources from a class path or URL location.</p> 
                    <p>The <em>boot</em> module <a href="#resource-service">implementation</a> supports for instance the listing of resources that match a specific path pattern:</p> 
                    <pre><code class="language-java">ResourceService resourceService = ...

Stream&lt;Resource&gt; resources = resourceService.getResources(URI.create("file:/path/to/resources/**/*"));
</code></pre> 
                    <p>The <code>MediaTypeService</code> interface specifies a service used to determine the media type of a resource based on its extension, name, path or URI. As for the resource service, a base implementation is provided in the <em>boot</em> module.</p> 
                    <pre><code class="language-java">MediaTypeService mediaTypeService = ...

// image/png
String mediaType = mediaTypeService.getForExtension("png");
</code></pre> 
                    <h3 id="boot">Boot</h3> 
                    <p>The Inverno <em>boot</em> module provides basic services to applications including several base implementation for interfaces defined in the <em>base</em> module.</p> 
                    <p>The Inverno <em>boot</em> module is the basic building block for any application and as such it must be the first module to declare in an application module descriptor.</p> 
                    <pre><code class="language-java">@io.inverno.core.annotation.Module
module io.inverno.example.app {
    requires io.inverno.mod.boot;
    // Other modules...
}
</code></pre> 
                    <p>The <em>boot</em> module declares transitive dependencies to the core IoC/DI modules as well as <em>base</em> and <em>configuration</em> modules. They don't need to be re-declared.</p> 
                    <p>This dependency must also be declared in the build descriptor:</p> 
                    <p>Using Maven:</p> 
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-boot&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre> 
                    <p>Using Gradle:</p> 
                    <pre><code class="language-groovy">...
compile 'io.inverno.mod:inverno-boot:1.0.0'
...
</code></pre> 
                    <h4 id="configuration">Configuration</h4> 
                    <p>The <em>boot</em> module defines specific configuration for the services it exposes, they can be specified when starting the module to override default values.</p> 
                    <p>For instance the <code>NetConfiguration</code> is used to configure the net service.</p> 
                    <p>Please refer to the <a href="https://inverno.io/docs/release/api/index.html">API documentation</a> to have an exhaustive description of the different configuration properties.</p> 
                    <h4 id="net-service">Net service</h4> 
                    <p>The module provides a base <code>NetService</code> implementation exposed as a bean for building network applications based on Netty.</p> 
                    <h4 id="media-type-service">Media type service</h4> 
                    <p>The module provides a base <code>MediaTypeService</code> implementation based on the JDK (see <a href="https://docs.oracle.com/javase/9/docs/api/java/nio/file/Files.html#probeContentType-java.nio.file.Path-">Files.probeContentType(Path)</a>) and exposed as an overridable bean allowing custom implementations to be provided.</p> 
                    <h4 id="resource-service">Resource service</h4> 
                    <p>The module provides a base <code>ResourceService</code> implementation exposed as a bean for accessing resources.</p> 
                    <p>This base implementation supports the following schemes: <code>file</code>, <code>zip</code>, <code>jar</code>, <code>classpath</code>, <code>module</code>, <code>http</code>, <code>https</code> and <code>ftp</code> and it allows to list resources for <code>file</code>, <code>zip</code> and <code>jar</code> schemes.</p> 
                    <p>When supported, resources are listed from a base URI specifying a path pattern using the following rules:</p> 
                    <ul> 
                        <li><code>?</code> matches one character</li> 
                        <li><code>*</code> matches zero or more characters</li> 
                        <li><code>**</code> matches zero or more directories in a path</li> 
                    </ul> 
                    <p>For instance:</p> 
                    <pre><code class="language-java">ResourceService resourceService = ...

// Return: '/base/test1/a', '/base/test1/a/b', '/base/test2/c'...
Stream&lt;Resource&gt; resources = resourceService.getResources(URI.create("file:/base/test?/**/*"));
</code></pre> 
                    <p>It is also possible to resolve all resources with a specific name defined in all application modules by specifying '<code>*</code>' instead of the module name in a module URI:</p> 
                    <pre><code class="language-java">ResourceService resourceService = ...

// all resources named '/path/to/resource' in all application modules
Stream&lt;Resource&gt; resources = resourceService.getResources(URI.create("module://*/path/to/resource"));
</code></pre> 
                    <p>This service can be extended by injecting custom <code>ResourceProvider</code> providing resources for a custom URI scheme. For instance, if we create a custom <code>Resource</code> and corresponding <code>ResourceProvider</code> implementations mapped to URI scheme <code>custom</code>, we can extend the resource service so it can create such custom resources.</p> 
                    <pre><code class="language-java">Boot boot = new Base.Boot()
    .setResourceProviders(List.of(new CustomResourceProvider())
    .build();

boot.start();

Resource customResource = boot.resourceService().get(URI.create("custom:..."));
...

boot.stop();
</code></pre> 
                    <h4 id="converters">Converters</h4> 
                    <p>The module exposes various <code>Converter</code> implementations used across an application to convert parameter values or message payloads.</p> 
                    <p>This includes the following also exposed as beans:</p> 
                    <ul> 
                        <li>a parameter converter for converting strings from/to objects, this converter can be extended by injecting specific compound decoders and encoders in the module as described in the <a href="#composite-converter">composite converter documentation</a>.</li> 
                        <li>a JSON <code>ByteBuf</code> converter for converting raw JSON data in <code>ByteBuf</code> from/to objects in the application.</li> 
                        <li>an <code>application/json</code> media type converter for converting message payloads from/to JSON.</li> 
                        <li>an <code>application/x-ndjson</code> media type converter for converting message payloads from/to <a href="http://ndjson.org/">Newline Delimited JSON</a></li> 
                        <li>a <code>text/plain</code> media type converter for converting message payloads from/to plain text.</li> 
                    </ul> 
                    <h4 id="worker-pool">Worker pool</h4> 
                    <p>An Inverno application must be fully reactive, most of the processing is performed in non-blocking I/O threads but sometimes blocking operations might be needed, in such cases, the worker thread pool should be used to execute these blocking operations without impacting the I/O event loop.</p> 
                    <p>The default worker pool bean is a simple <a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Executors.html#newCachedThreadPool--">cached Thread pool</a> which can be overridden by providing a different instance to the <em>boot</em> module.</p> 
                    <h4 id="object-mapper">Object mapper</h4> 
                    <p>A standard JSON reader/writer based on Jackson <code>ObjectMapper</code> is also provided. This instance is used across the application to perform JSON conversion operations, a global configuration can then be applied to that particular instance or it can be overridden when creating the <em>boot</em> module.</p> 
                    <h3 id="configuration-1">Configuration</h3> 
                    <p>The Inverno <em>configuration</em> module defines a unified configuration API for building agile highly configurable applications.</p> 
                    <p>Configuration is one of the most important aspect of an application and sadly one of the most neglected. There are very few decent configuration frameworks and most of the time they relate to one part of the issue. It is important to approach configuration by considering it as a whole and not as something that can be solved by a property file here and a database there. Besides, it must be the first issue to tackle during the design phase as it will impact all aspects of the application. For instance, we can imagine an application where configuration is defined in simple property files, a complete configuration would probably be needed for each environment where the application is deployed, maintenance would be probably problematic even more when we know that configuration properties can be added, modified or removed over time.</p> 
                    <p>In its most basic form, a configuration is not more than a set of properties associating a value to a key. It would be naive to think that this is enough to build an agile and customizable application, but in the end, a property should still be considered as the basic building block for configurations.</p> 
                    <p>Now, the first thing to notice is that any part of an application can potentially be configurable, from a server IP address to a color of a button in a user interface, there are multiple forms of configuration with different expectations that must coexist in an application. For instance, some parts of the configuration are purely static and do not change during the operation of an application, this is the case of a bootstrap configuration which mostly relates to the operating environment (eg. a server port). Some other parts, on the other hand, are more dynamic and can change during the operation of an application, this is the case of tenant specific configuration or even user preferences.</p> 
                    <p>Following this, we can see that a configuration greatly depends on the context in which it is loaded. The definition of a configuration, which is basically a list of property names, is dictated by the application, so when the application is running, this definition should be fixed but the context is not. For instance, the bootstrap configuration is different from one operating environment to another, user preferences are not the same from one user to another...</p> 
                    <p>We can summarize this as follows:</p> 
                    <ul> 
                        <li>a configuration is a set of configuration properties.</li> 
                        <li>the configuration of an application is actually composed of multiple configurations with their own specificities.</li> 
                        <li>the definition of a configuration is bound to the application as a result the only way to change it is to change the application.</li> 
                        <li>a configuration depends on a particular context which must be considered when setting or getting configuration properties.</li> 
                    </ul> 
                    <p>The configuration API has been created to address previous points, giving a maximum flexibility to precisely design how an application should be configured.</p> 
                    <p>In order to use the Inverno <em>configuration</em> module, we need to declare a dependency in the module descriptor:</p> 
                    <pre><code class="language-java">module io.inverno.example.app {
    ...
    requires io.inverno.mod.configuration;
    ...
}
</code></pre> 
                    <p>And also declare that dependency in the build descriptor:</p> 
                    <p>Using Maven:</p> 
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-configuration&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre> 
                    <p>Using Gradle:</p> 
                    <pre><code class="language-groovy">...
compile 'io.inverno.mod:inverno-configuration:1.0.0'
...
</code></pre> 
                    <h4 id="configuration-source">Configuration source</h4> 
                    <p>A configuration source can be any data store that holds configuration data, the API abstracts configuration data sources to provide a unified access to configuration data through the <code>ConfigurationSource</code> interface. Specific implementations should be considered depending on the type of configuration: a bootstrap configuration is most likely to be static and stored in configuration files or environment variables whereas a tenant specific configuration is most likely to be stored in a distributed data store. However this is not a universal rule, depending on the needs we can very well consider any kind of configuration source for any kind of configuration. The configuration source abstracts these concerns from the the rest of the application.</p> 
                    <p>The <code>ConfigurationSource</code> is the main entry point for accessing configuration properties, it shall be used every time there's a need to retrieve configuration properties. It defines only one method for creating a <code>ConfigurationQuery</code> instance eventually executed in order to retrieve one or more configuration properties.</p> 
                    <p>For instance, property <code>server.uri</code> can be retrieved as follows:</p> 
                    <pre><code class="language-java">ConfigurationSource&lt;?, ?, ?&gt; source = ...

source.get("server.url")                        // 1
    .execute()                                  // 2
    .single()                                   // 3
    .map(queryResult -&gt; queryResult
        .getResult()                            // 4
        .flatMap(property -&gt; property.asURI())  // 5
        .orElse(URI.create("http://localhost")) // 6
    )
    .subscribe(serverURI -&gt; ...);               // 7
</code></pre> 
                    <p>In the preceding example:</p> 
                    <ol> 
                        <li>creates a configuration query to retrieve the <code>server.url</code> property</li> 
                        <li>executes the query, the API is reactive so nothing will happen until a subscription is actually made on the resulting <code>Flux</code> of <code>ConfigurationQueryResult</code></li> 
                        <li>transforms the <code>Flux</code> to a <code>Mono</code> since we expect a single result</li> 
                        <li>gets the resulting configuration property, a query result is always returned even if the property does not exist in the source therefore <code>getResult()</code> returns an <code>Optional</code> that lets you decide what to do if the property is missing</li> 
                        <li>converts the property value to URI if present, a property can be defined in a source with a null value which explains why the property value is also an <code>Optional</code> and why we need to use <code>flatMap()</code></li> 
                        <li>returns the actual value if it exists or the specified default value</li> 
                        <li>we subscribe to the <code>Mono</code> which actually runs the query in the source and returns the property value or the default value if the property value is null or not defined in the source</li> 
                    </ol> 
                    <p>This seems to be a lot of steps to simply retrieve one property value, but if you look closely you'll understand that each of them is actually necessary:</p> 
                    <ul> 
                        <li>we want to be able to retrieve multiple properties and/or create more complex queries in a batch so <code>.execute()</code> is required to mark the end of a batch of queries</li> 
                        <li>we want to be reactive so <code>.single().map()</code> and <code>subscribe()</code> are required</li> 
                        <li>we want to have access to the configuration query key at the origin of a property for troubleshooting as a result the a query result must expose <code>getQueryKey()</code> and <code>getResult()</code> methods</li> 
                        <li>we want to be able to convert a property value and provide different behaviors when a property does not exist in a source or when it does exist but with a null value, as a result <code>.flatMap(property -&gt; property.asURI()).orElse(URI.create("http://localhost"))</code> is required</li> 
                    </ul> 
                    <p>As we said earlier, a configuration depends on the context: a given property might have different values when considering different contexts. The configuration API defines a configuration property with a name, a value and a set of parameters specifying the context for which the property is defined. Such configuration property is referred to as a <strong>parameterized configuration property</strong>.</p> 
                    <blockquote> 
                        <p>Some configuration source implementations do not support parameterized configuration property, they simply ignore parameters specified in queries and return the value associated to the property name. This is especially the case of environment variables which don't allow to specify property parameters.</p> 
                    </blockquote> 
                    <p>In order to retrieve a property in a particular context we can then parameterized the configuration query as follows:</p> 
                    <pre><code class="language-java">source.get("server.url")
    .withParameters("environment", "production", "zone", "us")
    .execute()
    ...
</code></pre> 
                    <p>In the preceding example, we query the source for property <code>server.url</code> defined for the production environment in zone US. To state the obvious, both the list of parameters and their values can be determined at runtime using actual contextual values. This is what makes parameterized properties so powerful as it is suitable for a wide range of use cases. This is all the more true when using a configuration source which supports some kind of defaulting such as the <a href="#composite-configuration-source">Composite Configuration source</a>.</p> 
                    <blockquote> 
                        <p>Whether the exact or nearest value matching the query is returned by a configuration source is implementation dependent but since the <em>configuration</em> module provides the <a href="#composite-configuration-source">Composite Configuration source</a> which can wrap any configuration source to add support for defaulting, it is a good practice to implement configuration sources that only support exact matching of a configuration query key (ie. including name and parameters).</p> 
                    </blockquote> 
                    <p>As said before the API let's you fluently query multiple properties in a batch and map the results in a configuration object.</p> 
                    <pre><code class="language-java">source
    .get("server.port", "db.url", "db.user", "db.password").withParameters("environment", "production", "zone", "us")
    .and()
    .get("db.schema").withParameters("environment", "production", "zone", "us", "tenant", "someCompany")
    .execute()
    .collectMap(queryResult -&gt; queryResult.getQueryKey().getName(), queryResult -&gt; queryResult.getResult())
    .map(properties -&gt; {
        ApplicationConfiguration config = new ApplicationConfiguration();
        
        properties.get("server.port").flatMap(property -&gt; property.asInteger()).ifPresent(config::setServerPort);
        properties.get("db.url").flatMap(property -&gt; property.asURL()).ifPresent(config::setDbURL);
        properties.get("db.user").flatMap(property -&gt; property.asString()).ifPresent(config::setDbUser);
        String dbPassword = properties.get("db.password").flatMap(property -&gt; property.asString()).ifPresent(config::setDbPassword);
        String dbSchema = properties.get("db.schema").flatMap(property -&gt; property.asString()).ifPresent(config::setDbSchema);
        
        return config;
    })
    .subscribe(config -&gt; {
        ...
    });
</code></pre> 
                    <p>The beauty of being reactive is that it comes with a lot of cool features such as the ability to re-execute a query or caching the result. A <code>Flux</code> or a <code>Mono</code> executes on subscriptions, which means we can create a complex query to retrieve a whole configuration, keep the resulting Reactive Streams <code>Publisher</code> and subscribe to it when needed. A Reactive Stream publisher can also cache configuration results.</p> 
                    <pre><code class="language-java">Mono&lt;ApplicationConfiguration&gt; configurationLoader = ... // see previous example

// Query the source on each subscriptions
configurationLoader.subscribe(config -&gt; {
    ...
});

// Cache the configuration for five minutes
Mono&lt;ApplicationConfiguration&gt; cachedConfigurationLoader = configurationLoader.cache(Duration.ofMinutes(5));

// Query the source on first subscriptions, further subscriptions within a window of 5 minutes will get the cached configuration
cachedConfigurationLoader.subscribe(config -&gt; {
    ...
});
</code></pre> 
                    <blockquote> 
                        <p>Although publisher caching is a cool feature, it might not be ideal for complex caching use cases and more solid solution should be considered.</p> 
                    </blockquote> 
                    <p>A configuration source relies on a <code>SplittablePrimitiveDecoder</code> to decode property values. Configuration source implementations usually provide a default decoder but it is possible to inject custom decoders to decode particular configuration values. The expected decoder implementation depends on the configuration source implementation but most of the time a string to object decoder is expected.</p> 
                    <pre><code class="language-java">SplittablePrimitiveDecoder&lt;String&gt; customDecoder = ...

PropertyFileConfigurationSource source = new PropertyFileConfigurationSource(new ClasspathResource(URI.create("classpath:/path/to/configuration")), customDecoder)
</code></pre> 
                    <h5 id="map-configuration-source">Map configuration source</h5> 
                    <p>The map configuration is the most basic configuration source implementation. It exposes configuration properties stored in a map in memory. It doesn't support parameterized properties, regardless of the parameters specified in a query, only the property name is considered when resolving a value.</p> 
                    <pre><code class="language-java">MapConfigurationSource source = new MapConfigurationSource(Map.of("server.url", new URL("http://localhost")));
...
</code></pre> 
                    <p>This implementation can be used for testing purpose in order to provide a mock configuration source.</p> 
                    <h5 id="system-environment-configuration-source">System environment configuration source</h5> 
                    <p>The system environment configuration source exposes system environment variables as configuration properties. As for the map configuration source, this implementation doesn't support parameterized properties.</p> 
                    <pre><code class="language-plaintext">$ export SERVER_URL=http://localhost
</code></pre> 
                    <pre><code class="language-java">SystemEnvironmentConfigurationSource source = new SystemEnvironmentConfigurationSource();
...
</code></pre> 
                    <p>This implementation can be used to bootstrap an application using system environment variables.</p> 
                    <h5 id="system-properties-configuration-source">System properties configuration source</h5> 
                    <p>The system properties configuration source exposes system properties as configuration properties. As for the two previous implementations, it doesn't support parameterized properties.</p> 
                    <pre><code class="language-plaintext">$ java -Dserver.url=http://localhost ...
</code></pre> 
                    <pre><code class="language-java">SystemPropertiesConfigurationSource source = new SystemPropertiesConfigurationSource();
...
</code></pre> 
                    <p>This implementation can be used to bootstrap an application using system properties.</p> 
                    <h5 id="command-line-configuration-source">Command line configuration source</h5> 
                    <p>The command line configuration source exposes configuration properties specified as command line arguments of the application. This implementation supports parameterized properties.</p> 
                    <p>Configuration properties must be specified as application arguments using the following syntax: <code>--property[parameter_1=value_1...parameter_n=value_n]=value</code> where property and parameter names are valid Java identifiers and property and parameter values are Java primitives such as integer, boolean, string... A complete description of the syntax can be found in the <a href="https://inverno.io/docs/release/api/index.html">API documentation</a>.</p> 
                    <p>For instance the following are valid configuration properties specified as command line arguments:</p> 
                    <pre><code class="language-plaintext">$ java ... Main \
--web.server_port=8080 \
--web.server_port[profile="ssl"]=8443 \
--db.url[env="dev"]="jdbc:oracle:thin:@dev.db.server:1521:sid" \
--db.url[env="prod",zone="eu"]="jdbc:oracle:thin:@prod_eu.db.server:1521:sid" \
--db.url[env="prod",zone="us"]="jdbc:oracle:thin:@prod_us.db.server:1521:sid"
</code></pre> 
                    <pre><code class="language-java">public static void main(String[] args) {
    CommandLineConfigurationSource source = new CommandLineConfigurationSource(args);
    ...
}
...
</code></pre> 
                    <h5 id="properties-file-configuration-source"><code>.properties</code> file configuration source</h5> 
                    <p>The <code>.properties</code> file configuration source exposes configuration properties specified in a <code>.properties</code> file. This implementation supports parameterized properties.</p> 
                    <p>Configuration properties can be specified in a property file using a syntax similar to the command line configuration source for the property key. Some characters must be escaped with respect to the <code>.properties</code> file format. Property values don't need to follow Java's notation for strings since they are considered as strings by design.</p> 
                    <pre><code class="language-properties">web.server_port=8080 
web.server_port[profile\="ssl"]=8443
db.url[env\="dev"]=jdbc:oracle:thin:@dev.db.server:1521:sid
db.url[env\="prod",zone\="eu"]=jdbc:oracle:thin:@prod_eu.db.server:1521:sid
db.url[env\="prod",zone\="us"]=jdbc:oracle:thin:@prod_us.db.server:1521:sid
</code></pre> 
                    <pre><code class="language-java">PropertyFileConfigurationSource source = new PropertyFileConfigurationSource(new ClasspathResource(URI.create("classpath:/path/to/file")));
...
</code></pre> 
                    <h5 id="cprops-file-configuration-source"><code>.cprops</code> file configuration source</h5> 
                    <p>The <code>.cprops</code> file configuration source exposes configuratio properties specified in a <code>.cprops</code> file. This implementation supports parameterized properties.</p> 
                    <p>The <code>.cprops</code> file format has been introduced to facilitate the definition and reading of parameterized properties. In particular it allows to regroup the definition of properties with common parameters into sections and many more.</p> 
                    <p>For instance:</p> 
                    <pre><code class="language-properties">server.port=8080
db.url=jdbc:oracle:thin:@localhost:1521:sid
db.user=user
db.password=password
log.level=ERROR
application.greeting.message="""
 === Welcome! === 

     This is      
    a formated    
     message.     

 ================
"""

[ environment="test" ] {
    db.url=jdbc:oracle:thin:@test:1521:sid
    db.user=user_test
    db.password=password_test
}

[ environment="production" ] {
    db.url=jdbc:oracle:thin:@production:1521:sid
    db.user=user_production
    db.password=password_production
    
    [ zone="US" ] {
        db.url=jdbc:oracle:thin:@production.us:1521:sid
    }
    
    [ zone="EU" ] {
        db.url=jdbc:oracle:thin:@production.eu:1521:sid
    }
    
    [ zone="EU", node="node1" ] {
        log.level=DEBUG
    }
}
</code></pre> 
                    <p>A complete <a href="https://javacc.github.io/javacc/">JavaCC</a> <a href="https://github.com/inverno-io/inverno-mods/tree/master/inverno-configuration/src/main/javacc/configuration_properties.jj">grammar</a> is available in the source of the configuration module.</p> 
                    <pre><code class="language-java">CPropsFileConfigurationSource source = new CPropsFileConfigurationSource(new ClasspathResource(URI.create("classpath:/path/to/file")));
...
</code></pre> 
                    <h5 id="bootstrap-configuration-source">Bootstrap configuration source</h5> 
                    <p>The bootstrap configuration source is a <a href="#composite-configuration-source">composite configuration source</a> preset with configuration sources typically used when bootstrapping an application.</p> 
                    <p>This implementation resolves configuration properties from the following sources in that order, from the highest priority to the lowest:</p> 
                    <ul> 
                        <li>command line</li> 
                        <li>system properties</li> 
                        <li>system environment variables</li> 
                        <li>the <code>configuration.cprops</code> file in <code>./conf/</code> or <code>${inverno.conf.path}/</code> directories if one exists (if the first one exists the second one is ignored)</li> 
                        <li>the <code>configuration.cprops</code> file in <code>${java.home}/conf/</code> directory if it exists</li> 
                        <li>the <code>configuration.cprops</code> file in the application module if it exists</li> 
                    </ul> 
                    <p>This source is typically created in a <code>main</code> method to load the bootstrap configuration on startup.</p> 
                    <pre><code class="language-java">public class Application {

    public static void main(String[] args) {
        BootstrapConfigurationSource source = new BootstrapConfigurationSource(Application.class.getModule(), args);
        
        // Load configuration
        ApplicationConfiguration configuration = ConfigurationLoader
            .withConfiguration(ApplicationConfiguration.class)
            .withSource(source)
            .load()
            .block();

        // Start the application with the configuration
        ...
    }
}
</code></pre> 
                    <h5 id="redis-configuration-source">Redis configuration source</h5> 
                    <p>The <a href="https://redis.io/">Redis</a> configuration source exposes configuration properties stored in a Redis data store. This implementation supports parameterized properties and it is also configurable which means it can be used to set configuration properties in the data store at runtime.</p> 
                    <p>It also provides a simple but effective versioning system which allows to set multiple properties and activate or revert them atomically. A global revision keeps track of the whole data store but it is also possible to version a particular branch in the tree of properties.</p> 
                    <p>The following example shows how to set configuration properties for the <code>dev</code> and <code>prod</code> environment and activates them globally or independently.</p> 
                    <pre><code class="language-java">RedisClient redisClient = ...
RedisConfigurationSource source = new RedisConfigurationSource(redisClient);

source
    .set("db.url", "jdbc:oracle:thin:@dev.db.server:1521:sid").withParameters("environment", "dev").and()
    .set("db.url", "jdbc:oracle:thin:@prod_eu.db.server:1521:sid").withParameters("environment", "prod", "zone", "eu").and()
    .set("db.url", "jdbc:oracle:thin:@prod_us.db.server:1521:sid").withParameters("environment", "prod", "zone", "us")
    .execute()
    .blockLast();
    
// Activate working revision globally
source.activate().block();

// Activate working revision for dev environment and prod environment independently
source.activate("environment", "dev").block();
source.activate("environment", "prod").block();
</code></pre> 
                    <p>It is also possible to fallback to a particular revision by specifying it in the <code>activate()</code> method:</p> 
                    <pre><code class="language-java">// Activate revision 2 globally
source.activate(2).block();
</code></pre> 
                    <p>This implementation is particularly suitable to load tenant specific configuration in a multi-tenant application, or user preferences... basically any kind of configuration that can and will be dynamically changed at runtime.</p> 
                    <blockquote> 
                        <p>Parameterized properties and versioning per branch are two simple yet powerful features but it is important to be picky here otherwise there is a real risk of messing things up. You should thoughtfully decide when a configuration branch can be versioned, for instance the versioned sets of properties must be disjointed (if this is not obvious, think again), this is actually checked in the Redis configuration source and an exception will be thrown if you try to do things like this, basically trying to version the same property twice.</p> 
                    </blockquote> 
                    <h5 id="composite-configuration-source">Composite Configuration source</h5> 
                    <p>The composite configuration source is a configuration source implementation with two particular features: first it allows to compose multiple configuration sources into one configuration source and then it supports defaulting strategies to determine the best matching value for a given configuration query key.</p> 
                    <p>The property returned for a configuration query key then depends on two factors: the order in which configuration sources were defined in the composite configuration source, from the highest priority to the lowest, and then how close is a property from the configuration query key.</p> 
                    <p>The <code>CompositeConfigurationSource</code> resolves a configuration property by querying its sources in sequence from the highest priority to the lowest. It relies on a <code>CompositeConfigurationStrategy</code> to determine at each round which queries to execute and retain the best matching property from the results. The best matching property is the property whose key is the closest to the original configuration query key according to a metric implemented in the strategy. The algorithm stops when an exact match is found or when there's no more configuration source to query.</p> 
                    <p>The <code>DefaultCompositeConfigurationStrategy</code> defines the default strategy implementation. It determines the best matching property for a given original query by prioritizing query parameters from left to right: the best matching property is the one matching the most continuous parameters from right to left. In practice, if we consider query key <code>property[p1=v1,...pn=vn]</code>, it supersedes key <code>property[p2=v2,...pn=vn]</code> which supersedes key <code>property[p3=v3,...pn=vn]</code>... which supersedes key <code>property[]</code>. As a result, an original query with <code>n</code> parameters results in <code>n+1</code> queries being actually executed if no property was retained in previous rounds and <code>n-p</code> queries if a property with p parameters (p&lt;n) was retained in previous rounds. The order into which parameters are specified in the original query is then significant: <code>property[p1=v1,p2=v2] != property[p2=v2,p1=v1]</code>.</p> 
                    <p>When defining configuration parameters, we should then order them from the most specific to the most general when querying a composite source. For example, the <code>node</code> parameter which is more specific than the <code>zone</code> parameter should come first then the <code>zone</code> parameter which is more specific than the <code>environment</code> parameter should come next and finally the <code>environment</code> parameter which is the most general should come last.</p> 
                    <p>For instance, we can consider two parameterized configuration sources: <code>source1</code> and <code>source2</code>.</p> 
                    <p><code>source1</code> holds the following properties:</p> 
                    <ul> 
                        <li><code>server.url[]=null</code></li> 
                        <li><code>server.url[zone="US", environment="production"]="https://prod.us"</code></li> 
                        <li><code>server.url[zone="EU"]="https://default.eu"</code></li> 
                    </ul> 
                    <p><code>source2</code> holds the following properties:</p> 
                    <ul> 
                        <li><code>server.url[]="https://default"</code></li> 
                        <li><code>server.url[environment="test"]="https://test"</code></li> 
                        <li><code>server.url[environment="production"]="https://prod"</code></li> 
                    </ul> 
                    <p>We can compose them in a composite configuration source as follows:</p> 
                    <pre><code class="language-java">ConfigurationSource&lt;?, ?, ?&gt; source1 = ...
ConfigurationSource&lt;?, ?, ?&gt; source2 = ...

CompositeConfigurationSource source = new CompositeConfigurationSource(List.of(source1, source2));

source                                                         // 1
    .get("server.url")
    .withParameters("zone", "US", "environment", "production")
    .execute()
    ...

source                                                         // 2
    .get("server.url")
    .withParameters("environment", "test")
    .execute()
    ...

source                                                         // 3
    .get("server.url")
    .execute()
    ...


source                                                         // 4
    .get("server.url")
    .withParameters("zone", "EU", "environment", "production")
    .execute()...

source                                                         // 5
    .get("server.url")
    .withParameters("environment", "production", "zone", "EU")
    .execute()
    ...
    
</code></pre> 
                    <p>In the example above:</p> 
                    <ol> 
                        <li><code>server.url[environment="production",zone="US"]</code> is exactly defined in <code>source1</code> =&gt; <code>https://prod.us</code> defined in <code>source1</code> is returned</li> 
                        <li><code>server.url[environment="test"]</code> is not defined in <code>source1</code> but exactly defined in <code>source2</code> =&gt; <code>https://test</code> defined in <code>source2</code> is returned</li> 
                        <li>Although <code>server.url[]</code> is defined in both <code>source1</code> and <code>source2</code>, <code>source1</code> has the highest priority and therefore =&gt; <code>null</code> is returned</li> 
                        <li>There is no exact match for <code>server.url[zone="EU", environment="production"]</code> in both <code>source1</code> and <code>source2</code>, the priority is given to the parameters from left to right, the property matching <code>server.url[environment="production"]</code> shall be returned =&gt; <code>https://prod</code> defined in <code>source2</code> is returned</li> 
                        <li>Here we've simply changed the order of the parameters in the previous query, again the priority is given to parameters from left to right, since there is no match for <code>server.url[environment="production", zone="EU"]</code>, <code>server.url[zone="EU"]</code> is considered =&gt; <code>https://default.eu</code> defined in <code>source1</code> is returned</li> 
                    </ol> 
                    <p>As you can see, the order into which parameters are specified in a query is significant and different results might be returned.</p> 
                    <p>When considering multiple configuration sources, properties can be defined with the exact same key in two different sources, the source with the highest priority wins. In the last example we've been able to set the value of <code>server.url[]</code> to <code>null</code> in <code>source1</code>, however <code>null</code> is itself a value with a different meaning than a missing property, the <code>unset</code> value can be used in such situation to <em>unset</em> a property defined in a source with a lower priority.</p> 
                    <p>For instance, considering previous example, we could have defined <code>server.url[]=unset</code> instead of <code>server.url[]=null</code> in <code>source1</code>, the query would then have returned an empty query result indicating an undefined property.</p> 
                    <h5 id="configurable-configuration-source">Configurable configuration source</h5> 
                    <p>A configurable configuration source is a particular configuration source which supports configuration properties updates. The <a href="#redis-configuration-source">Redis configuration source</a> is an example of configurable configuration source.</p> 
                    <p>The <code>ConfigurableConfigurationSource</code> interface is the main entry point for updating configuration properties, it shall be used every time there's a need to retrieve or set configuration properties.</p> 
                    <p>It extends the <code>ConfigurationSource</code> with one method for creating a <code>ConfigurationUpdate</code> instance eventually executed in order to set one or more configuration properties in the configuration source.</p> 
                    <p>For instance, a parameterized property <code>server.port</code> can be set in a configuration source as follows:</p> 
                    <pre><code class="language-java">ConfigurableConfigurationSource&lt;?, ?, ?, ?, ?, ?&gt; source = null;

source.set("server.port", 8080)
    .withParameters("environment", "production", "zone", "us")
    .execute()
    .single()
    .subscribe(
        updateResult -&gt; {
            try {
                updateResult.check();
                // Update succeeded
                ...
            }
            catch(ConfigurationSourceException e) {
                // Update failed
                ...
            }
        }
    );
</code></pre> 
                    <p>A configurable configuration source relies on a <code>JoinablePrimitiveEncoder</code> to encode property values. Implementations usually provide a default encoder but it is possible to inject custom encoders to encode particular configuration values. The expected encoder implementation depends on the configuration source implementation but most of the time an object to string encoder is expected.</p> 
                    <pre><code class="language-java">RedisClient redisClient = ...
JoinablePrimitiveEncoder&lt;String&gt; customEncoder = ...
SplittablePrimitiveDecoder&lt;String&gt; customDecoder = ...

RedisConfigurationSource source = new RedisConfigurationSource(redisClient, customEncoder, customDecoder)
</code></pre> 
                    <h4 id="configuration-loader">Configuration loader</h4> 
                    <p>The API offers a great flexibility but as we've seen it might require some efforts to load a configuration in a usable explicit Java bean. Hopefully, this has been anticipated and the configuration module provides a configuration loader to smoothly load configuration objects in the application.</p> 
                    <p>The <code>ConfigurationLoader</code> interface is the main entry point for loading configuration objects from a configuration source. It can be used in two different ways, either dynamically using Java reflection or statically using the Inverno compiler.</p> 
                    <h5 id="dynamic-loader">Dynamic loader</h5> 
                    <p>A dynamic loader can be created by invoking static method <code>ConfigurationLoader#withConfiguration()</code> which accepts a single <code>Class</code> argument specifying the type of the configuration that must be loaded.</p> 
                    <p>A valid configuration type must be an interface defining configuration properties as non-void no-argument methods whose names correspond to the configuration properties to retrieve and to map to the resulting configuration object, default values can be specified in default methods.</p> 
                    <p>For instance the following interface represents a valid configuration type which can be loaded by a configuration loader:</p> 
                    <pre><code class="language-java">public interface AppConfiguration {

    // query property 'server_host'
    String server_host();

    // query property 'server_port'
    default int server_port() {
        return 8080;
    }
}
</code></pre> 
                    <p>It can be loaded at runtime as follows:</p> 
                    <pre><code class="language-java">ConfigurationSource&lt;?, ?, ?&gt; source = ...

ConfigurationLoader
    .withConfiguration(AppConfiguration.class)
    .withSource(source)
    .withParameters("environment", "production")
    .load()
    .map(configuration -&gt; startServer(configuration.server_host(), configuration.server_port()))
    .subscribe();
</code></pre> 
                    <p>In the above example, the configuration source is queried for properties <code>server_host[environment="production"]</code> and <code>server_port[environment="production"]</code>.</p> 
                    <p>The dynamic loader also supports nested configurations when the return type of a method is an interface representing a valid configuration type.</p> 
                    <pre><code class="language-java">public interface ServerConfiguration {

    // query property 'server_host'
    String server_host();
    
    // query property 'server_port'
    default int server_port() {
        return 8080;
    }
}
</code></pre> 
                    <pre><code class="language-java">public interface AppConfiguration {
    
    // Prefix child property names with 'server_configuration'
    ServerConfiguration server_configuration();
}
</code></pre> 
                    <p>In the above example, the configuration source is queried for properties <code>server_configuration.server_host[environment="production"]</code> and <code>server_configuration.server_port[environment="production"]</code>.</p> 
                    <p>It is also possible to load a configuration by invoking static method <code>ConfigurationLoader#withConfigurator()</code> which allows to load any type of configuration (not only interface) by relying on a configurator and a mapping function.</p> 
                    <p>A configurator defines configuration properties as void single argument methods whose names correspond to the configuration properties to retrieve and inject into a configurator instance using a dynamic configurer <code>Consumer&lt;Configurator&gt;</code>. The mapping function is finally applied to that configurer to actually create the resulting configuration object.</p> 
                    <p>For instance, previous example could have been implemented as follows:</p> 
                    <pre><code class="language-java">public class AppConfiguration {
    
    private String server_host;
    private String server_port = 8080;
    
    // query property 'server_host'
    public void server_host(String server_host) {
        this.server_host = server_host;
    }
    
    // query property 'server_port'
    public void server_port(int server_port) {
        this.server_port = server_port;
    }
    
    public String server_host() {
        return server_host;
    }
    
    public int server_port() {
        return server_port;
    }
}
</code></pre> 
                    <pre><code class="language-java">ConfigurationSource&lt;?, ?, ?&gt; source = ...

ConfigurationLoader
    .withConfigurator(AppConfiguration.class, configurer -&gt; {
        AppConfiguration configuration = new AppConfiguration();
        configurer.apply(configuration);
        return configuration;
    })
    .withSource(source)
    .withParameters("environment", "production")
    .load()
    .map(configuration -&gt; startServer(configuration.server_host(), configuration.server_port()))
    .subscribe();
</code></pre> 
                    <h5 id="static-loader">Static loader</h5> 
                    <p>Dynamic loading is fine but it relies on Java reflection which induces extra processing at runtime and might cause unexpected runtime errors due to the lack of static checking. This is all the more true as most of the time configuration definitions are known at compile time. For these reasons, it is better to create adhoc configuration loader implementations. Fortunately, the configuration Inverno compiler plugin can generate these for us.</p> 
                    <p>In order to create a configuration bean in an Inverno module, we simply need to create an interface for our configuration as specified above and annotates it with <code>@Configuration</code>, this will tell the configuration Inverno compiler plugin to generate a corresponding configuration loader implementation as well as a module bean making our configuration directly available inside our module.</p> 
                    <pre><code class="language-java">@Configuration
public interface AppConfiguration {

    // query property 'server_host'
    String server_host();

    // query property 'server_port'
    int server_port();
}
</code></pre> 
                    <p>The preceding code will result in the generation of class <code>AppConfigurationLoader</code> which can then be used to load configuration at runtime without resorting to reflection.</p> 
                    <pre><code class="language-java">ConfigurationSource&lt;?, ?, ?&gt; source = ...

new AppConfigurationLoader()
    .withSource(source)
    .withParameters("environment", "production")
    .load()
    .map(configuration -&gt; startServer(configuration.server_host(), configuration.server_port()))
    .subscribe();
</code></pre> 
                    <p>A configuration can also be obtained <em>manually</em> as follows:</p> 
                    <pre><code class="language-java">AppConfiguration defaultConfiguration = AppConfigurationLoader.load(configurator -&gt; configurator.server_host("0.0.0.0"));

AppConfiguration customConfiguration = AppConfigurationLoader.load(configurator -&gt; configurator.server_host("0.0.0.0"));
</code></pre> 
                    <p>By default, the generated loader also defines an overridable module bean which loads the configuration in the module. This bean defines three optional sockets:</p> 
                    <ul> 
                        <li><strong>configurationSource</strong> indicates the configuration source to query when initializing the configuration bean</li> 
                        <li><strong>parameters</strong> indicates the parameters to consider when querying the source</li> 
                        <li><strong>configurer</strong> provides a way to overrides default values</li> 
                    </ul> 
                    <p>If no configuration source is present, a default configuration is created, otherwise the configuration source is queried with the parameters, the resulting configuration is then <em>patched</em> with the configurer if present. The bean is overridable by default which means we can inject our own implementation if we feel like it.</p> 
                    <p>It is possible to disable the activation of the configuration bean or make it non overridable in the <code>@Configuration</code> interface:</p> 
                    <pre><code class="language-java">@Configuration(generateBean = false, overridable = false)
public interface AppConfiguration {
    ...
}
</code></pre> 
                    <p>Finally, nested beans can be specified in a configuration which is convenient when a module is composing multiple modules and we wish to aggregate all configurations into one single representation in the composite module.</p> 
                    <p>For instance, we can have the following configuration defined in a component module:</p> 
                    <pre><code class="language-java">@Configuration
public interface ComponentModuleConfiguration {
    ...
}
</code></pre> 
                    <p>and the following configuration defined in the composite module:</p> 
                    <pre><code class="language-java">@Configuration
public interface CompositeModuleConfiguration {

    @NestedBean
    ComponentModuleConfiguration component_module_configuration();
}
</code></pre> 
                    <p>In the preceding example, we basically indicate to the Inverno framework that the <code>ComponentModuleConfiguration</code> defined in the <code>CompositeModuleConfiguration</code> must be injected into the component module instance.</p> 
                    <h3 id="http-base">HTTP Base</h3> 
                    <p>The Inverno <em>http-base</em> module defines the foundational API for creating HTTP clients and servers. It also provides common HTTP services such as the header service.</p> 
                    <p>In order to use the Inverno <em>http-base</em> module, we need to declare a dependency in the module descriptor:</p> 
                    <pre><code class="language-java">module io.inverno.example.app {
    requires io.inverno.mod.http.base;
    ...
}
</code></pre> 
                    <p>And also declare that dependency in the build descriptor:</p> 
                    <p>Using Maven:</p> 
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-http-base&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre> 
                    <p>Using Gradle:</p> 
                    <pre><code class="language-groovy">...
compile 'io.inverno.mod:inverno-http-base:1.0.0'
...
</code></pre> 
                    <p>The <em>http-base</em> module is usually provided as a transitive dependency by other HTTP modules, the <em>http-server</em> module or the <em>web</em> module in particular, so this might not be necessary.</p> 
                    <h4 id="http-base-api">HTTP base API</h4> 
                    <p>The base HTTP API defines common classes and interfaces for implementing applications or modules using HTTP/1.x or HTTP/2 protocols. This includes:</p> 
                    <ul> 
                        <li>HTTP methods and status enumerations</li> 
                        <li>Exception bindings for HTTP errors: <code>BadRequestException</code>, <code>InternalServerErrorException</code>...</li> 
                        <li>basic building blocks such as <code>Parameter</code> which defines the base interface for any HTTP component that can be represented as a key/value pair (eg. query parameter, header, cookie...)</li> 
                        <li>Cookie types: <code>Cookie</code> and <code>SetCookie</code></li> 
                        <li>Common HTTP header names (<code>Headers.NAME_*</code>) and values (<code>Headers.VALUE_*</code>) constants</li> 
                        <li>Common HTTP header types: <code>Headers.ContentType</code>, <code>Headers.Accept</code>...</li> 
                        <li>HTTP header codec API for implementing HTTP header codec used to decode a raw HTTP header in a specific <code>Header</code> object</li> 
                        <li>A HTTP header service used to encode/decode HTTP headers from/to specific <code>Header</code> objects</li> 
                    </ul> 
                    <h4 id="http-header-service">HTTP header service</h4> 
                    <p>The HTTP header service is the main entry point for decoding and encoding HTTP headers.</p> 
                    <p>The <code>HeaderService</code> interface defines method to decode/encode <code>Header</code> object from/to <code>String</code> or <code>ByteBuf</code>.</p> 
                    <p>For instance, a <code>content-type</code> header can be parsed as follows:</p> 
                    <pre><code class="language-java">HeaderService headerService = ...

Headers.ContentType contentType = headerService.&lt;Headers.ContentType&gt;decode("content-type", "application/xml;charset=utf-8");

// application/xml
String mediaType = contentType.getMediaType();
// utf-8
Charset charset = contentType.getCharset();

</code></pre> 
                    <p>The <em>http-base</em> module provides a default implementation exposed as a bean which relies on a set of <code>HeaderCodec</code> to support specific headers. Custom header codecs can then be injected in the module to extend its capabilities.</p> 
                    <p>For instance, we can create an <code>ApplicationContextHeaderCodec</code> codec in order for the header service to decode custom <code>application-context</code> headers to <code>ApplicationContextHeader</code> instances. The codec must be injected in the <em>http-base</em> module either explicitly when creating the module or through dependency injection.</p> 
                    <pre><code class="language-java">Base httpBase = new Base.Builder()
    .setHeaderCodecs(List.of(new ApplicationContextHeaderCodec())
    .build();

httpBase.start();

ApplicationContextHeaderCodec decodedHeader = httpBase.headerService().&lt;ApplicationContextHeaderCodec&gt;.decode("...")
...

httpBase.stop();
</code></pre> 
                    <p>Most of the time the <em>http-base</em> module is composed in a composite module and as a result dependency injection should work just fine, so we simply need to declare the codec as a bean in the module composing the <em>http-base</em> module to extend the header service.</p> 
                    <p>By default, the <em>http-base</em> module provides codecs for the following headers:</p> 
                    <ul> 
                        <li><code>accept</code> as defined by <a href="https://tools.ietf.org/html/rfc7231#section-5.3.2">RFC 7231 Section 5.3.2</a></li> 
                        <li><code>accept-language</code> as defined by <a href="https://tools.ietf.org/html/rfc7231#section-5.3.5">RFC 7231 Section 5.3.5</a></li> 
                        <li><code>content-disposition</code> as defined by <a href="https://tools.ietf.org/html/rfc6266">RFC 6266</a></li> 
                        <li><code>content-type</code> as defined by <a href="https://tools.ietf.org/html/rfc7231#section-5.1.1.5">RFC 7231 Section 3.1.1.5</a></li> 
                        <li><code>cookie</code> as defined by <a href="https://tools.ietf.org/html/rfc6265#section-4.2">RFC 6265 Section 4.2</a></li> 
                        <li><code>set-cookie</code> as defined by <a href="https://tools.ietf.org/html/rfc6265#section-4.1">RFC 6265 Section 4.1</a></li> 
                    </ul> 
                    <h3 id="http-server">HTTP Server</h3> 
                    <p>The Inverno <em>http-server</em> module provides fully reactive HTTP/1.x and HTTP/2 server based on <a href="https://netty.io/">Netty</a>.</p> 
                    <p>It especially supports:</p> 
                    <ul> 
                        <li>HTTP/1.x pipelining</li> 
                        <li>HTTP/2 over cleartext</li> 
                        <li>HTTP Compression</li> 
                        <li>TLS</li> 
                        <li><code>application/x-www-form-urlencoded</code> body decoding</li> 
                        <li><code>multipart/form-data</code> body decoding</li> 
                        <li>Server-sent events</li> 
                        <li>Cookies</li> 
                        <li>zero-copy file transfer when supported for fast resource transfer</li> 
                        <li>parameter conversion</li> 
                    </ul> 
                    <p>The server is fully reactive, based on the reactor pattern and non-blocking sockets which means it requires a limited number of threads to supports thousands of connections with high end performances. This design offers multiple advantages starting with maximizing the usage of resources. It is also easy to scale the server up and down by specifying the number of threads we want to allocate to the server, which ideally corresponds to the number of CPU cores. All this makes it a perfect choice for microservices applications running in containers in the cloud.</p> 
                    <blockquote> 
                        <p>This module lays the foundational service and API for building HTTP servers with more complex and advanced features, that is why you might sometimes find it a little bit low level but that is the price of performance. If you require higher level functionalities like request routing, content negotiation and automatic payload conversion please consider the <a href="#web">web module</a>.</p> 
                    </blockquote> 
                    <p>This module requires basic services like a <a href="#net-service">net service</a> and a <a href="#resource-service">resource service</a> which are usually provided by the <em>boot</em> module, so in order to use the Inverno <em>http-server</em> module, we should declare the following dependencies in the module descriptor:</p> 
                    <pre><code class="language-java">@io.inverno.core.annotation.Module
module io.inverno.example.app_http {
    requires io.inverno.mod.boot;
    requires io.inverno.mod.http.server;
}
</code></pre> 
                    <p>The <em>http-base</em> module which provides the header service used by the HTTP server is composed as a transitive dependency in the <em>http-server</em> module and as a result it doesn't need to be specified here nor provided in an enclosing module.</p> 
                    <p>We also need to declare these dependencies in the build descriptor:</p> 
                    <p>Using Maven:</p> 
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-boot&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-http-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre> 
                    <p>Using Gradle:</p> 
                    <pre><code class="language-groovy">...
compile 'io.inverno.mod:inverno-boot:1.0.0'
compile 'io.inverno.mod:inverno-http-server:1.0.0'
...
</code></pre> 
                    <h4 id="http-server-exchange-api">HTTP Server exchange API</h4> 
                    <p>The module defines classes and interfaces to implement HTTP server exchange handlers used to handle HTTP requests sent by a client to the server.</p> 
                    <p>A server <code>ExchangeHandler</code> is defined to handle a server <code>Exchange</code> composed of the <code>Request</code> and <code>Response</code> pair in a HTTP communication between a client and a server. The API has been designed to be fluent and reactive in order for the request to be <em>streamed</em> down to the response.</p> 
                    <h5 id="basic-exchange">Basic exchange</h5> 
                    <p>The <code>ExchangeHandler</code> is a functional interface, a basic exchange handler can then be created as follows:</p> 
                    <pre><code class="language-java">ExchangeHandler&lt;Exchange&gt; handler = exchange -&gt; {
    exchange.response()
        .headers(headers -&gt; headers.contentType(MediaTypes.TEXT_PLAIN))
        .body().raw().value(Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("Hello, world!", Charsets.DEFAULT)));
};
</code></pre> 
                    <p>The above code creates an exchange handler sending a <code>Hello, world!</code> message in response to any request.</p> 
                    <p>We might also want to send the response in a reactive way in a stream of data in case the entire response payload is not available right away, if it doesn't fit in memory or if we simply want to send a response in multiple parts as soon as they become available (eg. progressive display).</p> 
                    <pre><code class="language-java">ExchangeHandler&lt;Exchange&gt; handler = exchange -&gt; {
    Flux&lt;ByteBuf&gt; dataStream = Flux.just(
        Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("Hello", Charsets.DEFAULT)),
        Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(", world!", Charsets.DEFAULT))
    );

    exchange.response()
        .body().raw().stream(dataStream);
};
</code></pre> 
                    <h5 id="request-body">Request body</h5> 
                    <p>Request body can be handled in a similar way. The reactive API allows to process the payload of a request as the server receives it and therefore progressively build and send the corresponding response.</p> 
                    <pre><code class="language-java">ExchangeHandler&lt;Exchange&gt; handler = exchange -&gt; {
    exchange.response()
        .body().raw().stream(exchange.request().body()
            .map(body -&gt; Flux.from(body.raw().stream()).map(chunk -&gt; Unpooled.unreleasableBuffer(Unpooled.buffer(4).writeInt(chunk.readableBytes()))))
            .orElse(Flux.just(Unpooled.unreleasableBuffer(Unpooled.buffer(4).writeInt(0))))
        );
};
</code></pre> 
                    <p>In the above example, if a client sends a payload in the request, the server responds with the number of bytes of each chunk of data it receives or it responds <code>0</code> if the request payload is empty. This simple example illustrates how we can process requests as flow of data</p> 
                    <h5 id="url-encoded-form">URL Encoded form</h5> 
                    <p>HTML form data are sent in the body of a POST request in the form of key/value pairs encoded in <a href="https://url.spec.whatwg.org/#application/x-www-form-urlencoded">application/x-www-form-urlencoded format</a>. The resulting list of <code>Parameter</code> can be obtained as follows:</p> 
                    <pre><code class="language-java">ExchangeHandler&lt;Exchange&gt; handler = exchange -&gt; {
    exchange.response()
        .body().raw().stream(Flux.from(exchange.request().body().get().urlEncoded().stream())
            .map(parameter -&gt; Unpooled.copiedBuffer(Unpooled.copiedBuffer("Received parameter " + parameter.getName() + " with value " + parameter.getValue(), Charsets.DEFAULT)))
        );
}
</code></pre> 
                    <p>In the above example, for each form parameters the server responds with a message describing the parameters it just received. Again this shows that the API is fully reactive and form parameters can be processed as they are decoded.</p> 
                    <p>A more traditional example though would be to obtained the map of parameters grouped by names (because multiple parameters with the same name can be sent):</p> 
                    <pre><code class="language-java">ExchangeHandler&lt;Exchange&gt; handler = exchange -&gt; {
    exchange.response()
        .body().raw().stream(Flux.from(exchange.request().body().get().urlEncoded().stream())
        .collectMultimap(Parameter::getName)
            .map(formParameters -&gt; Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("User selected options: " + formParameters.get("options").stream().map(Parameter::getValue).collect(Collectors.joining(", ")), Charsets.DEFAULT)))
        );
}
</code></pre> 
                    <blockquote> 
                        <p>Here we may think that the aggregation of parameters in a map could <em>block</em> the I/O thread but this is definitely not true, when a parameter is decoded, the reactive framework is notified and the parameter is stored in a map, after that the I/O thread can be reallocated. When the parameters publisher completes the resulting map is emitted to the mapping function which build the response. During all this process, no thread is ever waiting for anything.</p> 
                    </blockquote> 
                    <h5 id="multipart-form">Multipart form</h5> 
                    <p>A <a href="https://tools.ietf.org/html/rfc7578">multipart/form-data</a> request can be handled in a similar way. Form parts can be obtained as follows:</p> 
                    <pre><code class="language-java">ExchangeHandler&lt;Exchange&gt; handler = exchange -&gt; {
    exchange.response()
        .body().raw().stream(Flux.from(exchange.request().body().get().multipart().stream())
            .map(part -&gt; Unpooled.copiedBuffer(Unpooled.copiedBuffer("Received part " + part.getName(), Charsets.DEFAULT)))
        );
};
</code></pre> 
                    <p>In the above example, the server responds with the name of the part it just received. Parts are decoded and can be processed along the way, a part is like a body embedded in the request body with its own headers and payload.</p> 
                    <p>Multipart form data is most commonly used for uploading files over HTTP. Such handler can be implemented as follows using the <a href="#resource-api">resource API</a> to store uploaded files:</p> 
                    <pre><code class="language-java">ExchangeHandler&lt;Exchange&gt; handler = exchange -&gt; {
    exchange.response()
        .body().raw().stream(Flux.from(exchange.request().body().get().multipart().stream())                                                                                                                // 1
            .single()                                                                                                                                                                                       // 2
            .flatMapMany(part -&gt; part.getFilename()                                                                                                                                                         // 3
                .map(fileName -&gt; Flux.&lt;ByteBuf, FileResource&gt;using(                                                                                                                                         // 4
                        () -&gt; new FileResource("uploads/" + part.getFilename().get()),                                                                                                                      // 5
                        file -&gt; file.write(part.raw().stream()).map(Flux::from).get()                                                                                                                       // 6
                            .reduce(0, (acc, cur) -&gt; acc + cur) 
                            .map(size -&gt; Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("Uploaded " + fileName + "(" + part.headers().getContentType() + "): " + size + " Bytes\n", Charsets.DEFAULT))), 
                        FileResource::close                                                                                                                                                                 // 7
                    )
                )
                .orElseThrow(() -&gt; new BadRequestException("Not a file part"))                                                                                                                              // 8
            )
        );
};
</code></pre> 
                    <p>The above code uses multiple elements and deserves a detailed explanation:</p> 
                    <ol> 
                        <li>get the stream of parts</li> 
                        <li>make sure we only have one part in the request for the sake of simplicity</li> 
                        <li>map the part to the response stream by starting to determine whether the part is a file part</li> 
                        <li>if the part is a file part indeed, map the part to the response stream by creating a Flux with a file resource</li> 
                        <li>in this case the resource is the target file where the uploaded file will be stored</li> 
                        <li>stream the part's payload to the target file resource and eventually provides the response in the form of a message stating that a file with a given size and media type has been uploaded</li> 
                        <li>close the file resource when the publisher completes</li> 
                        <li>if the part is not a file part respond with a bad request error</li> 
                    </ol> 
                    <p>The <code>Flux.using()</code> construct is the reactive counterpart of a try-with-resource statement. It is interesting to note that the content of the file is streamed up to the file and it is then never entirely loaded in memory. From there, it is quite easy to stop the upload of a file if a given size threshold is exceeded. We can also imagine how we could create a progress bar in a client UI to show the progression of the upload.</p> 
                    <blockquote> 
                        <p>In the above code we uploaded a file and stored its content on the local file system and during all that process, the I/O thread was never blocked.</p> 
                    </blockquote> 
                    <h5 id="resource">Resource</h5> 
                    <p>A <a href="#resource-api">resource</a> can be sent as a response to a request. When this is possible the server uses low-level (<a href="https://en.wikipedia.org/wiki/Zero-copy">zero-copy</a>) API for fast resource transfer.</p> 
                    <pre><code class="language-java">ExchangeHandler&lt;Exchange&gt; handler = exchange -&gt; {
    exchange.response()
        .body().resource().value(new FileResource("/path/to/resource"));
};
</code></pre> 
                    <p>The media type of the resource is resolved using a <a href="#media-type-service">media type service</a> and automatically set in the response <code>content-type</code> header field.</p> 
                    <blockquote> 
                        <p>If a specific resource is created as in above example the media type service used is the one defined when creating the resource or a default implementation if none was specified. If the resource is obtained with the resource service provided in the <em>boot</em> module the media type service used is the one provided in the <em>boot</em> module.</p> 
                    </blockquote> 
                    <h5 id="server-sent-events">Server-sent events</h5> 
                    <p><a href="https://www.w3.org/TR/eventsource/">Server-sent events</a> provide a way to send server push notifications to a client. It is based on <a href="https://en.wikipedia.org/wiki/Chunked_transfer_encoding">chunked transfer encoding</a> over HTTP/1.x and regular streams over HTTP/2. The API provides an easy way to create SSE endpoints.</p> 
                    <pre><code class="language-java">ExchangeHandler&lt;Exchange&gt; handler = exchange -&gt; {
    exchange.response().body().sse().from(
        (events, data) -&gt; data.stream(Flux.interval(Duration.ofSeconds(1))
            .map(seq -&gt; events.create(event -&gt; event
                .id(Long.toString(seq))
                .event("seq")
                .comment("Some comment")
                .value(Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("Event #" + seq, Charsets.DEFAULT))))
            )
        )
    );
};
</code></pre> 
                    <p>In the above example, server-sent events are emitted every second and streamed to the response. This is done in a function accepting the server-sent event factory used to create events and the response data producer.</p> 
                    <h5 id="error-exchange-handler">Error exchange handler</h5> 
                    <p>An error exchange handler is a particular exchange handler which is defined to handle server error exchange. In other words it is used by the server to handle exceptions thrown during the processing of a regular exchange in order to send an appropriate response to the client when this is still possible (ie. assuming response headers haven't been sent yet).</p> 
                    <pre><code class="language-java">ErrorExchangeHandler&lt;Throwable&gt; errorHandler = errorExchange -&gt; {
    if(errorExchange.getError() instanceof BadRequestException) {
        errorExchange.response()
            .headers(headers -&gt; headers.status(Status.BAD_REQUEST))
            .body().raw().value(Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("client sent an invalid request", Charsets.DEFAULT)));
    }
    else {
        errorExchange.response()
            .headers(headers -&gt; headers.status(Status.INTERNAL_SERVER_ERROR))
            .body().raw().value(Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("Unknown server error", Charsets.DEFAULT)));
    }
};
</code></pre> 
                    <h5 id="misc">Misc</h5> 
                    <p>The API is fluent and mostly self-describing as a result it should be easy to find out how to do something in particular, even so here are some miscellaneous elements.</p> 
                    <h6 id="request-headers">Request headers</h6> 
                    <p>A particular request header can be obtained as follows, if there are multiple headers with the same name, the first one shall be returned:</p> 
                    <pre><code class="language-java">ExchangeHandler&lt;Exchange&gt; handler = exchange -&gt; {
    ...
    // get the raw value of a header
    String someHeader = exchange.request().headers().get("some-header").orElseThrow(() -&gt; new BadRequestException("Missing some-header"));
    
    // get a header as a parameter that can be converted using the parameter converter
    LocalDateTime someDateTime = exchange.request().headers().getParameter("some-date-time").map(Parameter::asLocalDateTime).orElseThrow(() -&gt; new BadRequestException("Missing some-date-time"));
    
    // get a decoded header using the header service
    CustomHeader customHeader = exchange.request().headers().&lt;CustomHeader&gt;getHeader("custom-header").orElseThrow(() -&gt; new BadRequestException("Missing some-date-time"));
    ...
};
</code></pre> 
                    <p>All headers with a particular names can be obtained as follows:</p> 
                    <pre><code class="language-java">ExchangeHandler&lt;Exchange&gt; handler = exchange -&gt; {
    ...
    // get all raw values defined for a given header
    List&lt;String&gt; someHeaderList = exchange.request().headers().getAll("some-header");
    
    // get all headers with a given header as parameters that can be converted using the parameter converter
    LocalDateTime someDateTime = exchange.request().headers().getParameter("some-date-time").map(Parameter::asLocalDateTime).orElseThrow(() -&gt; new BadRequestException("Missing some-date-time"));
    
    // get all headers with a given name decoded using the header service
    CustomHeader customHeader = exchange.request().headers().&lt;CustomHeader&gt;getHeader("custom-header").orElseThrow(() -&gt; new BadRequestException("Missing some-date-time"));
    ...
};
</code></pre> 
                    <p>Finally we can retrieve all headers as follows:</p> 
                    <pre><code class="language-java">ExchangeHandler&lt;Exchange&gt; handler = exchange -&gt; {
    ...
    // get all headers with raw values
    List&lt;Map.Entry&lt;String, String&gt;&gt; requestHeaders = exchange.request().headers().getAll();

    // get all headers as parameters that can be converted using the parameter converter
    List&lt;Parameter&gt; requestHeaderParameters = exchange.request().headers().getAllParameter();
    
    // get all headers decoded using the header service
    List&lt;Header&gt; requestDecodedHeaders = exchange.request().headers().getAllHeader();
    ...
};
</code></pre> 
                    <h6 id="query-parameters">Query parameters</h6> 
                    <p>Query parameters in the request can be obtained as follows:</p> 
                    <pre><code class="language-java">ExchangeHandler&lt;Exchange&gt; handler = exchange -&gt; {
    ...
    // get a specific query parameter, if there are multiple parameters with the same name, the first one is returned
    int someInteger = exchange.request().queryParameters().get("some-integer").map(Parameter::asInteger).orElseThrow(() -&gt; new BadRequestException("Missing some-integer"));

    // get all query parameters with a given name
    List&lt;Integer&gt; someIntergers = exchange.request().queryParameters().getAll("some-integer").stream().map(Parameter::asInteger).collect(Collectors.toList());

    // get all query parameters
    Map&lt;String, List&lt;Parameter&gt;&gt; queryParameters = exchange.request().queryParameters().getAll();
    ...
};
</code></pre> 
                    <h6 id="request-cookies">Request cookies</h6> 
                    <p>Request cookie can be obtained in a similar way as follows:</p> 
                    <pre><code class="language-java">ExchangeHandler&lt;Exchange&gt; handler = exchange -&gt; {
    ...
    // get a specific cookie, if there are multiple cookie with the same name, the first one is returned
    int someInteger = exchange.request().cookies().get("some-integer").map(Parameter::asInteger).orElseThrow(() -&gt; new BadRequestException("Missing some-integer"));

    // get all cookies with a given name
    List&lt;Integer&gt; someIntergers = exchange.request().cookies().getAll("some-integer").stream().map(Parameter::asInteger).collect(Collectors.toList());

    // get all cookies
    Map&lt;String, List&lt;CookieParameter&gt;&gt; queryParameters = exchange.request().cookies().getAll();
    ...
};
</code></pre> 
                    <p>Note that cookies can also be obtained as request headers.</p> 
                    <h6 id="request-components">Request components</h6> 
                    <p>The API also gives access to multiple request related information such as:</p> 
                    <ul> 
                        <li>the HTTP method</li> 
                        <li>the scheme (<code>http</code> or <code>https</code>)</li> 
                        <li>the authority part of the requested URI (<code>host</code> header in HTTP/1.x and <code>:authority</code> pseudo-header in HTTP/2)</li> 
                        <li>the requested path including query string</li> 
                        <li>the absolute path which is the normalized requested path without the query string</li> 
                        <li>the <code>URIBuilder</code> corresponding to the requested path to build relative paths</li> 
                        <li>the query string</li> 
                        <li>the socket address of the client or last proxy that sent the request</li> 
                    </ul> 
                    <h6 id="response-headerstrailers">Response headers/trailers</h6> 
                    <p>Response headers can be added or set fluently using a configurator as follows:</p> 
                    <pre><code class="language-java">ExchangeHandler&lt;Exchange&gt; handler = exchange -&gt; {
    exchange.response()
        .headers(headers -&gt; headers
            .contentType(MediaTypes.TEXT_PLAIN)
            .set(Headers.NAME_SERVER, "inverno")
            .add("custom-header", "abc")
        )
        .body().raw()...;
};
</code></pre> 
                    <p>Response trailers can be set in the exact same way:</p> 
                    <pre><code class="language-java">ExchangeHandler&lt;Exchange&gt; handler = exchange -&gt; {
    exchange.response()
        .trailers(headers -&gt; headers
            .add("some-trailer", "abc")
        )
        .body().raw()...;
};
</code></pre> 
                    <h6 id="response-status">Response status</h6> 
                    <p>The response status can be set in the response headers following HTTP/2 specification as defined by <a href="https://tools.ietf.org/html/rfc7540#section-8.1.2.4">RFC 7540 Section 8.1.2.4</a>.</p> 
                    <pre><code class="language-java">ExchangeHandler&lt;Exchange&gt; handler = exchange -&gt; {
    exchange.response()
        .headers(headers -&gt; headers.status(Status.OK))
        .body().raw();
};
</code></pre> 
                    <h6 id="response-cookies">Response cookies</h6> 
                    <p>Response cookies can be set fluently using a configurator as follows:</p> 
                    <pre><code class="language-java">ExchangeHandler&lt;Exchange&gt; handler = exchange -&gt; {
    exchange.response()
        .cookies(cookies -&gt; cookies
            .addCookie(cookie -&gt; cookie.name("cookie1")
                .httpOnly(true)
                .secure(true)
                .maxAge(3600)
                .value("abc")
            )
            .addCookie(cookie -&gt; cookie.name("cookie2")
                .httpOnly(true)
                .secure(true)
                .maxAge(3600)
                .value("def")
            )
        )
        .body().raw()...;
};
</code></pre> 
                    <p>Note that cookies can also be set or added as response headers.</p> 
                    <h4 id="http-server-1">HTTP Server</h4> 
                    <p>The HTTP server is started with the <em>http-server</em> module which requires a <code>NetService</code> and a <code>ResourceService</code> usually provided by the <em>boot</em> module, so one way to create an application with a HTTP server is to create an Inverno module composing the <em>boot</em> and <em>http-server</em> modules.</p> 
                    <pre><code class="language-java">@io.inverno.core.annotation.Module
module io.inverno.example.app_http {
    requires io.inverno.mod.boot;
    requires io.inverno.mod.http.server;
}
</code></pre> 
                    <p>The resulting <em>app_http</em> module, thus created, can then be started as an application as follows:</p> 
                    <pre><code class="language-java">package io.inverno.example.app_http;

import io.inverno.core.v1.Application;

public class Main {

    public static void main(String[] args) {
        Application.with(new App_http.Builder()).run();
    }
}
</code></pre> 
                    <p>The above example starts a HTTP/1.x server using default configuration and default root and error handlers.</p> 
                    <pre><code>2021-04-14 09:51:46,329 INFO  [main] i.w.c.v.Application - Inverno is starting...


     â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
     â•‘                      , ~~ ,                                                                â•‘
     â•‘                  , '   /\   ' ,                                                            â•‘
     â•‘                 , __   \/   __ ,      _                                                    â•‘
     â•‘                ,  \_\_\/\/_/_/  ,    | |  ___  _    _  ___   __  ___   ___                 â•‘
     â•‘                ,    _\_\/_/_    ,    | | / _ \\ \  / // _ \ / _|/ _ \ / _ \                â•‘
     â•‘                ,   __\_/\_\__   ,    | || | | |\ \/ /|  __/| | | | | | |_| |               â•‘
     â•‘                 , /_/ /\/\ \_\ ,     |_||_| |_| \__/  \___||_| |_| |_|\___/                â•‘
     â•‘                  ,     /\     ,                                                            â•‘
     â•‘                    ,   \/   ,                                  -- 1.2.0 --                 â•‘
     â•‘                      ' -- '                                                                â•‘
     â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
     â•‘ Java runtime        : OpenJDK Runtime Environment                                          â•‘
     â•‘ Java version        : 16+36-2231                                                           â•‘
     â•‘ Java home           : /home/jkuhn/Devel/jdk/jdk-16                                         â•‘
     â•‘                                                                                            â•‘
     â•‘ Application module  : io.inverno.example.app_http                                          â•‘
     â•‘ Application version : 1.0.0-SNAPSHOT                                                       â•‘
     â•‘ Application class   : io.inverno.example.app_http.Main                                     â•‘
     â•‘                                                                                            â•‘
     â•‘ Modules             :                                                                      â•‘
     â•‘  ....                                                                                      â•‘
     â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


2021-04-14 09:53:21,829 INFO  [main] i.w.e.a.App_http - Starting Module io.inverno.example.app_http...
2021-04-14 09:53:21,829 INFO  [main] i.w.m.b.Boot - Starting Module io.inverno.mod.boot...
2021-04-14 09:53:22,025 INFO  [main] i.w.m.b.Boot - Module io.inverno.mod.boot started in 195ms
2021-04-14 09:53:22,025 INFO  [main] i.w.m.h.s.Server - Starting Module io.inverno.mod.http.server...
2021-04-14 09:53:22,025 INFO  [main] i.w.m.h.b.Base - Starting Module io.inverno.mod.http.base...
2021-04-14 09:53:22,029 INFO  [main] i.w.m.h.b.Base - Module io.inverno.mod.http.base started in 3ms
2021-04-14 09:53:22,080 INFO  [main] i.w.m.h.s.i.HttpServer - HTTP Server (nio) listening on http://0.0.0.0:8080
2021-04-14 09:53:22,080 INFO  [main] i.w.m.h.s.Server - Module io.inverno.mod.http.server started in 55ms
2021-04-14 09:53:22,080 INFO  [main] i.w.e.a.App_http - Module io.inverno.example.app_http started in 252ms

</code></pre> 
                    <p>You should be able to send a request to the server:</p> 
                    <pre><code class="language-plaintext">$ curl -i http://localhost:8080/
HTTP/1.1 200
content-length: 5

Hello
</code></pre> 
                    <p>The HTTP server defines two handlers: the <strong>root handler</strong> which handles HTTP requests and the <strong>error handler</strong> which handles errors. The module provides default implementations as overridable beans, custom handlers can then be used instead when creating the <em>http-server</em> module.</p> 
                    <blockquote> 
                        <p>this module can also be used to embed a HTTP server in any application, unlike other application frameworks, Inverno core IoC/DI framework is not pervasive and any Inverno modules can be safely used in various contexts and applications.</p> 
                    </blockquote> 
                    <h5 id="configuration-2">Configuration</h5> 
                    <p>The first thing we might want to do is to create a configuration in the <em>app_http</em> module for easy <em>http-server</em> module setup. The HTTP server configuration is actually done in the <code>NetConfiguration</code> defined in the <em>boot</em> module for low level network configuration and <code>HttpServerConfiguration</code> in the <em>http-server</em> module configuration for the HTTP server itself.</p> 
                    <p>The following configuration can then be created in the <em>app_http</em> module:</p> 
                    <pre><code class="language-java">package io.inverno.example.app_http;

import io.inverno.core.annotation.NestedBean;
import io.inverno.mod.boot.NetConfiguration;
import io.inverno.mod.configuration.Configuration;
import io.inverno.mod.http.server.HttpServerConfiguration;

@Configuration
public interface App_httpConfiguration {

    @NestedBean
    NetConfiguration net();

    @NestedBean
    HttpServerConfiguration http_server();
}
</code></pre> 
                    <p>This should be enough for exposing a configuration in the <em>app_http</em> module, that let us setup the server:</p> 
                    <pre><code class="language-java">package io.inverno.example.app_http;

import io.inverno.core.v1.Application;

public class Main {

    public static void main(String[] args) {
        Application.with(new App_http.Builder()
            .setApp_httpConfiguration(
                App_httpConfigurationLoader.load(configuration -&gt; configuration
                    .http_server(server -&gt; server
                        .server_port(8081)
                        .h2c_enabled(true)
                    )
                    .net(net -&gt; net
                        .root_event_loop_group_size(4)
                    )
                )
            )
        ).run();
    }
}
</code></pre> 
                    <p>In the above code, we have set the server port to 8081, enabled HTTP/2 over cleartext and set the number of thread allocated to the root event loop group to 4.</p> 
                    <p>Please refer to the <a href="javadoc">API documentation</a> to have an exhaustive description of the different configuration properties. We can for instance configure low level network settings like TCP keep alive or TCP no delay as well as HTTP related settings like compression or TLS.</p> 
                    <blockquote> 
                        <p>You can also refer to the <a href="#configuration-1">configuration module documentation</a> to get more details on how configuration works and more especially how you can from here define the HTTP server configuration in command line arguments, property files...</p> 
                    </blockquote> 
                    <p>By default, the HTTP server uses the Java NIO transport, but it is possible to use native <a href="https://en.wikipedia.org/wiki/Epoll">epoll</a> transport on Linux or <a href="https://en.wikipedia.org/wiki/Kqueue">kqueue</a> transport on BSD-like systems for optimized performances. This can be done by adding the corresponding Netty dependency with the right classifier in the project descriptor:</p> 
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.netty&lt;/groupId&gt;
            &lt;artifactId&gt;netty-transport-native-epoll&lt;/artifactId&gt;
            &lt;classifier&gt;linux-x86_64&lt;/classifier&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre> 
                    <p>or</p> 
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.netty&lt;/groupId&gt;
            &lt;artifactId&gt;netty-transport-native-kqueue&lt;/artifactId&gt;
            &lt;classifier&gt;osx-x86_64&lt;/classifier&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre> 
                    <blockquote> 
                        <p>When these dependencies are declared on the JVM module path, the corresponding Java modules must be added explicitly when running the application. This is typically the case when the application is run or packaged as an application image using the Inverno Maven plugin.</p> 
                        <p>This can be done by defining the corresponding dependencies in the module descriptor:</p> 
                        <pre><code class="language-java">@io.inverno.core.annotation.Module
module io.inverno.example.app {
    ...
    requires io.netty.transport.unix.common;
    requires io.netty.transport.epoll;
}
</code></pre> 
                        <p>This approach is fine as long as we are sure the application will run on Linux, but in order to create a properly portable application, we should prefer adding the modules explicitly when running the application:</p> 
                        <pre><code class="language-plaintext">$ java --add-modules io.netty.transport.unix.common,io.netty.transport.epoll ...
</code></pre> 
                        <p>When building an application image, this can be specified in the Inverno Maven plugin configuration:</p> 
                        <pre><code class="language-xml">&lt;project&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;io.inverno.tool&lt;/groupId&gt;
                &lt;artifactId&gt;inverno-maven-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;configuration&gt;
                            &lt;vmOptions&gt;--add-modules io.netty.transport.unix.common,io.netty.transport.epoll&lt;/vmOptions&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre> 
                    </blockquote> 
                    <h5 id="root-handler">Root handler</h5> 
                    <p>The HTTP server defines a root exchange handler to handle all HTTP requests. By default, it uses a basic handler implementation which returns <code>Hello</code> when a request is made to the root path <code>/</code> and return (404) not found errors otherwise.</p> 
                    <p>In order to use our own handler, we must define an exchange handler bean in the <em>app_http</em> module:</p> 
                    <pre><code class="language-java">package io.inverno.example.app_http;

import io.netty.buffer.Unpooled;
import io.inverno.core.annotation.Bean;
import io.inverno.mod.base.Charsets;
import io.inverno.mod.http.base.HttpException;
import io.inverno.mod.http.server.Exchange;
import io.inverno.mod.http.server.ExchangeHandler;

@Bean
public class CustomHandler implements ExchangeHandler&lt;Exchange&gt; {

    @Override
    public void handle(Exchange exchange) throws HttpException {
        exchange.response()
            .body().raw()
            .value(Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("Hello from app_http module!", Charsets.DEFAULT)));
    }
}
</code></pre> 
                    <p>This bean will be automatically wired to the root handler socket defined by the <em>http-server</em> module overriding the default root handler. If we don't want to provide a handler implementation inside the <em>app_http</em> module, we can also define a socket bean for the root handler and provide an instance when creating the <em>app_http</em> module.</p> 
                    <pre><code class="language-java">package io.inverno.example.app_http;

import java.util.function.Supplier;

import io.netty.buffer.Unpooled;
import io.inverno.core.annotation.Bean;
import io.inverno.core.v1.Application;
import io.inverno.mod.base.Charsets;
import io.inverno.mod.http.server.Exchange;
import io.inverno.mod.http.server.ExchangeHandler;

public class Main {

    @Bean
    public static interface Handler extends Supplier&lt;ExchangeHandler&lt;Exchange&gt;&gt; {}

    public static void main(String[] args) {
        Application.with(new App_http.Builder()
            .setHandler(exchange -&gt; {
                exchange.response()
                    .body().raw()
                    .value(Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("Hello from main!", Charsets.DEFAULT)));
                }
            )
        ).run();
    }
}
</code></pre> 
                    <p>Note that this socket bean is optional since the root handler socket on the <em>http-server</em> module to which it is wired is itself optional.</p> 
                    <h5 id="error-handler">Error handler</h5> 
                    <p>The HTTP server defines an error exchange handler to handle exceptions thrown when processing HTTP requests when this is still possible, basically when the response headers haven't been sent yet to the client. By default, it uses a basic error handler implementation which handles standard <code>HttpException</code> and responds empty body messages with HTTP error status corresponding to the exception.</p> 
                    <p>This default implementation should be enough for a basic HTTP server but a custom handler can be provided to produce custom error pages for specific types of error. This can be done in the exact same way as the <a href="#root-handler">root handler</a> by defining an error exchange handler bean:</p> 
                    <pre><code class="language-java">package io.inverno.example.app_http;

import io.inverno.core.annotation.Bean;
import io.inverno.mod.http.base.HttpException;
import io.inverno.mod.http.server.ErrorExchange;
import io.inverno.mod.http.server.ExchangeHandler;

@Bean
public class CustomErrorHandler implements ExchangeHandler&lt;ErrorExchange&lt;Throwable&gt;&gt; {

    @Override
    public void handle(ErrorExchange&lt;Throwable&gt; exchange) throws HttpException {
        if(exchange.getError() instanceof SomeCustomException) {
            ...
        }
        else if(...) {
            ...
        }
        ...
        else {
            ...
        }
    }
}
</code></pre> 
                    <p>Or by defining a socket bean:</p> 
                    <pre><code class="language-java">package io.inverno.example.app_http;

import java.util.function.Supplier;

import io.netty.buffer.Unpooled;
import io.inverno.core.annotation.Bean;
import io.inverno.core.v1.Application;
import io.inverno.mod.base.Charsets;
import io.inverno.mod.http.server.ErrorExchange;
import io.inverno.mod.http.server.Exchange;
import io.inverno.mod.http.server.ExchangeHandler;

public class Main {

    @Bean
    public static interface Handler extends Supplier&lt;ExchangeHandler&lt;Exchange&gt;&gt; {}
    
    @Bean
    public static interface ErrorHandler extends Supplier&lt;ErrorExchangeHandler&lt;Throwable&gt;&gt; {}

    public static void main(String[] args) {
        Application.with(new App_http.Builder()
            .setErrorHandler(exchange -&gt; {
                exchange.response()
                    .headers(headers -&gt; headers.status(500))
                    .body().raw()
                    .value(Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("Error: " + exchange.getError().getMessage(), Charsets.DEFAULT)));
        })).run();
    }
}
</code></pre> 
                    <h5 id="http-compression">HTTP compression</h5> 
                    <p>HTTP compression can be activated by configuration for request and/or response. For instance:</p> 
                    <pre><code class="language-java">public class Main {

    public static void main(String[] args) {
        Application.with(new App_http.Builder()
            .setApp_httpConfiguration(
                App_httpConfigurationLoader.load(configuration -&gt; configuration
                    .http_server(server -&gt; server
                        .decompression_enabled(true)
                        .compression_enabled(true)
                        .compression_level(6)
                    )
                )
            )
        ).run();
    }
}
</code></pre> 
                    <p>Now if we send a request which accepts compression to the server, we should now receive a compressed response:</p> 
                    <pre><code class="language-plaintext">$ curl -i --compressed -H 'accept-encoding: gzip, deflate' http://localhost:8080
HTTP/1.1 200 OK
content-type: text/plain
server: inverno
content-encoding: gzip
content-length: 39

Hello
</code></pre> 
                    <h5 id="tls-configuration">TLS configuration</h5> 
                    <p>In order to activate TLS, we need first to obtain a private key and a certificate stored in a keystore.</p> 
                    <p>A self-signed certificate can be generated using <code>keytool</code>, the resulting keystore should be placed in <code>src/main/resources</code> to make it available as a module resource:</p> 
                    <pre><code class="language-plaintext">$ keytool -genkey -keyalg RSA -alias selfsigned -keystore keystore.jks -storepass password -validity 360 -keysize 2048
</code></pre> 
                    <p>Then we need to configure the server to activate TLS using the certificate:</p> 
                    <pre><code class="language-java">public class Main {

    public static void main(String[] args) {
        Application.with(new App_http.Builder()
            .setApp_httpConfiguration(
                App_httpConfigurationLoader.load(configuration -&gt; configuration
                    .http_server(server -&gt; server
                        .server_port(8443)
                        .tls_enabled(true)
                        .key_store(URI.create("module://io.inverno.example.app_http/keystore.jks"))
                        .key_alias("selfsigned")
                        .key_store_password("password")
                    )
                )
            )
        ).run();
    }
}
</code></pre> 
                    <blockquote> 
                        <p>When an application using the <em>http-server</em> module is packaged as an application image, you'll need to make sure TLS related modules from the JDK are included in the runtime image otherwise TLS might not work. You can refer to the <a href="https://docs.oracle.com/en/java/javase/11/security/oracle-providers.html">JDK providers documentation</a> in the security developer's guide to find out which modules should be added depending on your needs. Most of the time you'll simply add <code>jdk.crypto.ec</code> module in the Inverno Maven plugin configuration:</p> 
                        <pre><code class="language-xml">&lt;project&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;io.inverno.tool&lt;/groupId&gt;
                &lt;artifactId&gt;inverno-maven-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;configuration&gt;
                            &lt;addModules&gt;jdk.crypto.ec&lt;/addModules&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre> 
                    </blockquote> 
                    <h5 id="extend-http-services">Extend HTTP services</h5> 
                    <p>The HTTP server relies on a header service and a parameter converter to respectively decode HTTP headers and convert parameter values.</p> 
                    <p>The <em>http-server</em> module defines a socket to plug custom <code>HeaderCodec</code> instances so the HTTP header service can be extended to decode custom HTTP headers as described in the <a href="#http-header-service">HTTP header service documentation</a>.</p> 
                    <p>It also defines a socket to plug a custom parameter converter which is a basic <code>StringConverter</code> by default. Since we created the <em>app_http</em> module by composing <em>boot</em> and <em>http-server</em> modules, the parameter converter provided by the <em>boot</em> module should then override the default. This converter is a <code>StringCompositeConverter</code> which can be extended by injecting custom <code>CompoundDecoder</code> and/or <code>CompoundEncoder</code> instances in the <em>boot</em> module as described in the <a href="#composite-converter">composite converter documentation</a>.</p> 
                    <p>To sum up, all we have to do to extend these services is to provide <code>HeaderCodec</code>, <code>CompoundDecoder</code> or <code>CompoundEncoder</code> beans in the <em>app_http</em> module.</p> 
                    <h4 id="wrap-up">Wrap-up</h4> 
                    <p>If we put all we've just seen together, here is a complete example showing how to create a HTTP/2 server with HTTP compression using custom root and error handlers:</p> 
                    <pre><code class="language-java">package io.inverno.example.app_http;

import java.net.URI;
import java.util.function.Supplier;

import io.netty.buffer.Unpooled;
import io.inverno.core.annotation.Bean;
import io.inverno.core.v1.Application;
import io.inverno.mod.base.Charsets;
import io.inverno.mod.http.server.ErrorExchange;
import io.inverno.mod.http.server.Exchange;
import io.inverno.mod.http.server.ExchangeHandler;

public class Main {

    @Bean
    public static interface Handler extends Supplier&lt;ExchangeHandler&lt;Exchange&gt;&gt; {}
    
    @Bean
    public static interface ErrorHandler extends Supplier&lt;ErrorExchangeHandler&lt;Throwable&gt;&gt; {}

    public static void main(String[] args) {
        Application.with(new App_http.Builder()
            .setApp_httpConfiguration(
                    App_httpConfigurationLoader.load(configuration -&gt; configuration
                    .http_server(server -&gt; server
                        // HTTP compression
                        .decompression_enabled(true)
                        .compression_enabled(true)
                        // TLS
                        .server_port(8443)
                        .tls_enabled(true)
                        .key_store(URI.create("module://io.inverno.example.app_http/keystore.jks"))
                        .key_alias("selfsigned")
                        .key_store_password("password")
                        // Enable HTTP/2
                        .h2_enabled(true)
                    )
                )
            )
            .setHandler(exchange -&gt; {
                exchange.response()
                    .body().raw().value(Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("Hello from main!", Charsets.DEFAULT)));
            })
            .setErrorHandler(exchange -&gt; {
                exchange.response()
                   .headers(headers -&gt; headers.status(500))
                   .body().raw().value(Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("Error: " + exchange.getError().getMessage(), Charsets.DEFAULT)));
            })
        ).run();
    }
}
</code></pre> 
                    <pre><code class="language-plaintext">$ curl -i --insecure https://localhost:8443/
HTTP/2 200 
content-length: 16

Hello from main!
</code></pre> 
                    <h3 id="web">Web</h3> 
                    <p>The Inverno <em>web</em> module provides extended functionalities on top of the <em>http-server</em> module for developing Web and RESTfull applications.</p> 
                    <p>It especially provides:</p> 
                    <ul> 
                        <li>HTTP request routing</li> 
                        <li>content negotiation</li> 
                        <li>automatic message payload conversion</li> 
                        <li>path parameters</li> 
                        <li>static handler for serving static resources</li> 
                        <li>version agnostic <a href="https://www.webjars.org/">WebJars</a> support</li> 
                        <li>easy Web/REST controller development</li> 
                        <li><a href="https://www.openapis.org/">OpenAPI</a> specifications generation using Web controllers JavaDoc comments</li> 
                        <li>SwaggerUI integration</li> 
                        <li>an Inverno compiler plugin providing static validation of the routes and generation of Web router configurers</li> 
                    </ul> 
                    <p>The <em>web</em> module composes the <em>http-server</em> module and therefore starts a HTTP server. Just like the <em>http-server</em> module, it requires a net service and a resource service as well as a list of <a href="#media-type-converter">media type converters</a> for message payload conversion. Basic implementations of these services are provided by the <em>boot</em> module which provides <code>application/json</code>, <code>application/x-ndjson</code> and <code>text/plain</code> media type converters. Additional media type converters can surely be provided by implementing the <code>MediaTypeConverter</code> interface.</p> 
                    <p>In order to use the Inverno <em>web</em> module, we should declare the following dependencies in the module descriptor:</p> 
                    <pre><code class="language-java">@io.inverno.core.annotation.Module
module io.inverno.example.app_web {
    requires io.inverno.mod.boot;
    requires io.inverno.mod.web;
}
</code></pre> 
                    <p>We also need to declare these dependencies in the build descriptor:</p> 
                    <p>Using Maven:</p> 
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-boot&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.inverno.mod&lt;/groupId&gt;
            &lt;artifactId&gt;inverno-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre> 
                    <p>Using Gradle:</p> 
                    <pre><code class="language-groovy">...
compile 'io.inverno.mod:inverno-boot:1.0.0'
compile 'io.inverno.mod:inverno-web:1.0.0'
...
</code></pre> 
                    <h4 id="routing">Routing</h4> 
                    <p>The <em>web</em> module also defines an API for routing HTTP requests to the right handlers.</p> 
                    <p>A <strong>router</strong> is a standard server exchange handler as defined by the <em>http-server</em> module API which can be used as root handler or error handler in the HTTP server, its role is to route an exchange to a handler based on a set of rules applied to the exchange.</p> 
                    <p>A <strong>route</strong> specifies the rules that an exchange must matched to be routed to a particular handler.</p> 
                    <p>A <strong>route manager</strong> is used to manage the routes in a router or, more explicitly, to list, create, enable or disable routes in a router.</p> 
                    <blockquote> 
                        <p>The module defines a high level routing API with <code>Router</code>, <code>Route</code>, <code>RouteManager</code> and <code>RouterConfigurer</code> that can be used as a base to implement custom routing implementations in addition to the provided Web and error routing implementations. Nevertheless, it is more of a guideline, one can choose a totally different approach to implement routing, in the end the HTTP server expects a <code>ExchangeHandler&lt;ByteBuf&gt;</code> what is done inside is completely opaque, the Web API only shows one way to do it.</p> 
                    </blockquote> 
                    <h5 id="web-routing">Web routing</h5> 
                    <p>A <code>WebRouter</code> is used to route a <code>WebExchange</code> to the right <code>WebExchangeHandler</code>, it implements <code>ExchangeHandler&lt;ByteBuf&gt;</code> and it is typically used as root handler in the HTTP server.</p> 
                    <h6 id="web-server-exchange">Web Server exchange</h6> 
                    <p>The <em>web</em> module API extends the <a href="#http-server-exchange-api">server exchange API</a> defined in the <em>http-server</em> module and defines the server <code>WebExchangeHandler</code> to handle a server <code>WebExchange</code> composed of the <code>WebRequest</code> and <code>WebResponse</code> pair in a HTTP communication between a client and a server. These interfaces respectively extends the <code>ExchangeHandler</code>, <code>Exchange</code>, <code>Request</code> and <code>Response</code> interfaces which are defined in the <em>http-server</em> module. A Web exchange handler is typically attached to one or more Web routes defined in a <code>WebRouter</code>.</p> 
                    <p>** Exchange attributes** Exchange attributes</p> 
                    <p>Attributes can be set on a <code>WebExchange</code> to propagate contextual information such as a security or functional context in a chain of Web exchange handlers:</p> 
                    <pre><code class="language-java">WebExchangeHandler&lt;WebExchange&gt; handler = exchange -&gt; {
    exchange.&lt;SecurityContext&gt;getAttribute("security_context")
        .filter(SecurityContext::isAuthenticated)
        .ifPresentOrElse(
            securityContext -&gt; {
                ...
            },
            () -&gt; exchange.response().headers(headers -&gt; headers.status(Status.UNAUTHORIZED)).body().empty()
        );
};

WebExchangeHandler&lt;WebExchange&gt; securityInterceptor = exchange -&gt; {
    SecurityContext securityContext = ...;
    exchange.setAttribute("security_context", securityContext);
    
    handler.handle(exchange);
};
</code></pre> 
                    <p>** Path parameters** Path parameters</p> 
                    <p>Path parameters are exposed in the <code>WebRequest</code>, they are extracted from the requested path by the <a href="#web-router">Web router</a> when the handler is attached to a route matching a parameterized path as defined in a <a href="#uris">URI builder</a>.</p> 
                    <p>For instance, if the handler is attached to a route matching <code>/book/{id}</code>, the <code>id</code> path parameter can be retrieved as follows:</p> 
                    <pre><code class="language-java">WebExchangeHandler&lt;WebExchange&gt; handler = exchange -&gt; {
    exchange.request().pathParameters().get("id")
        .ifPresentOrElse(
            id -&gt; {
                ...
            },
            () -&gt; exchange.response().headers(headers -&gt; headers.status(Status.NOT_FOUND)).body().empty()
        );
};
</code></pre> 
                    <p>** Request body decoder** Request body decoder</p> 
                    <p>The request body can be decoded based on the content type defined in the request headers.</p> 
                    <pre><code class="language-java">WebExchangeHandler&lt;WebExchange&gt; handler = exchange -&gt; {
    Mono&lt;Result&gt; storeBook = exchange.request().body().get()
        .decoder(Book.class)
        .one()
        .map(book -&gt; storeBook(book));
    exchange.response().body()
        .raw().stream(storeBook.map(result -&gt; Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(result.getMessage(), Charsets.DEFAULT))));
};
</code></pre> 
                    <p>When invoking the <code>decoder()</code> method, a <a href="#media-type-converter">media type converter</a> corresponding to the request content type is selected to decode the payload. The <code>content-type</code> header MUST be specified in the request, otherwise (400) bad request error is returned indicating an empty media type. If there is no converter corresponding to the media type, an (415) unsupported media type error is returned indicating that no decoder was found matching the content type.</p> 
                    <p>A decoder is obtained by specifying the type of the object to decode in the <code>decoder()</code> method, the type can be a <code>Class&lt;T&gt;</code> or a <code>java.lang.reflect.Type</code> which allows to decode parameterized types at runtime bypassing type erasure. Parameterized Types can be built at runtime using the <a href="#reflection-api">reflection API</a>.</p> 
                    <p>As you can see in the above example the decoder is fully reactive, a request payload can be decoded in a single object by invoking method <code>one()</code> on the decoder which returns a <code>Mono&lt;T&gt;</code> publisher or in a stream of objects by invoking method <code>many()</code> on the decoder which returns a <code>Flux&lt;T&gt;</code> publisher.</p> 
                    <p>Decoding multiple payload objects is indicated when a client streams content to the server. For instance, it can send a request with <code>application/x-ndjson</code> content type in order to send multiple messages in a single request. Since everything is reactive the server doesn't have to wait for the full request and it can process a message as soon as it is received. What is remarkable is that the code is largely unchanged.</p> 
                    <pre><code class="language-java">WebExchangeHandler&lt;WebExchange&gt; handler = exchange -&gt; {
    Flux&lt;Result&gt; storeBook = exchange.request().body().get()
        .decoder(Book.class)
        .many()
        .map(book -&gt; storeBook(book));
    exchange.response().body()
        .raw().stream(storeBook.map(result -&gt; Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(result.getMessage(), Charsets.DEFAULT))));
};
</code></pre> 
                    <p>Conversion of a multipart form data request body is also supported, the payload of each part being decoded independently based on the content type of the part. For instance we can upload multiple books in multiple files in a <code>multipart/form-data</code> request and decode them on the fly as follows:</p> 
                    <pre><code class="language-java">WebExchangeHandler&lt;WebExchange&gt; handler = exchange -&gt; {
    exchange.response()
        .body().raw().stream(Flux.from(exchange.request().body().get().multipart().stream())                          // 1
            .flatMap(part -&gt; part.decoder(Book.class).one())                                                          // 2
            .map(book -&gt; storeBook(book))                                                                             // 3
            .map(result -&gt; Unpooled.unreleasableBuffer(Unpooled.copiedBuffer(result.getMessage(), Charsets.DEFAULT))) // 4
        );
};
</code></pre> 
                    <p>In the previous example:</p> 
                    <ol> 
                        <li>A stream of files is received in a <code>multipart/form-data</code> request (note that we assume all parts are file parts).</li> 
                        <li>Each part is decoded to a <code>Book</code> object, the media type must be specified in the <code>content-type</code> header field of the part.</li> 
                        <li>The book object so obtained is processed.</li> 
                        <li>The result for each upload is returned to the client.</li> 
                    </ol> 
                    <p>All this process is done in a reactive way, the first chunk of response can be sent before all parts have been processed.</p> 
                    <p>** Response body encoder** Response body encoder</p> 
                    <p>As for the request body, the response body can be encoded based on the content type defined in the response headers. Considering previous example we can do the following:</p> 
                    <pre><code class="language-java">WebExchangeHandler&lt;WebExchange&gt; handler = exchange -&gt; {
    Mono&lt;Result&gt; storeBook = exchange.request().body().get()
        .decoder(Book.class)
        .one()
        .map(book -&gt; storeBook(book));
    exchange.response()
        .headers(headers -&gt; headers.contentType(MediaTypes.APPLICATION_JSON))
        .body()
            .encoder(Result.class)
            .one(storeBook);
};
</code></pre> 
                    <p>When invoking the <code>encoder()</code> method, a <a href="#media-type-converter">media type converter</a> corresponding to the response content type is selected to encode the payload. The <code>content-type</code> header MUST be specified in the response, otherwise a (500) internal server error is returned indicating an empty media type. If there is no converter corresponding to the media type, a (500) internal server error is returned indicating that no encoder was found matching the content type.</p> 
                    <p>A single object is encoded by invoking method <code>one()</code> on the encoder or multiple objects can be encoded by invoking method <code>many()</code> on the encoder. Returning multiple objects in a stream is particularly suitable to implement progressive display in a Web application, for example to display search results as soon as some are available.</p> 
                    <pre><code class="language-java">WebExchangeHandler&lt;WebExchange&gt; handler = exchange -&gt; {
    Flux&lt;SearchResult&gt; searchResults = ...;
    exchange.response()
        .headers(headers -&gt; headers.contentType(MediaTypes.APPLICATION_X_NDJSON))
        .body()
            .encoder(SearchResult.class)
            .many(searchResults);
};
</code></pre> 
                    <h6 id="web-router">Web router</h6> 
                    <p>A <code>WebRouter</code> routes a Web server exchange to an exchange handler attached to a Web route by matching it against a combination of routing rules specified in the route. A Web route can combine the following routing rules which are matched in that order: the path, method and content type of the request, the media ranges and language ranges accepted by the client. For instance, the Web router matches an exchange against the path routing rule first, then the method routing rule... Multiples routes can then match a given exchange but only one will be retained to actually process the exchange which is the one matching the highest routing rules.</p> 
                    <p>If a route doesn't define a particular routing rule, the routing rule is simply ignored and matches all exchanges. For instance, if a route doesn't define any method routing rule, exchanges are matched regardless of the method.</p> 
                    <p>The following is an example of a Web route which matches all exchanges, this is the simplest route that can be defined on a router:</p> 
                    <pre><code class="language-java">router
    .route()                                                   // 1
        .handler(exchange -&gt; {                                 // 2
            exchange.response()
                .headers(headers -&gt; 
                    headers.contentType(MediaTypes.TEXT_PLAIN)
                )
                .body()
                .encoder()
                .value("Hello, world!");
        });
</code></pre> 
                    <ol> 
                        <li>A new <code>WebRouteManager</code> instance is obtained from the Web router to configure a <code>WebRoute</code></li> 
                        <li>We only define the handler of the route as a result any exchange might be routed to that particular route unless a more specific route matching the exchange exists.</li> 
                    </ol> 
                    <blockquote> 
                        <p>A <code>WebRouter</code> is exposed in the <em>web</em> module and wired to the <em>http-server</em> module to override the HTTP server's root handler, it can be configured in a <code>WebRouterConfigurer</code> as defined in the <a href="#web-server">Web Server documentation</a>.</p> 
                    </blockquote> 
                    <p>An exchange handler can be attached to multiple routes at once by providing multiple routing rules to the route manager, the following example actually results in 8 individual routes being created in the Web router:</p> 
                    <pre><code class="language-java">router
    .route()
        .path("/doc")
        .path("/document")
        .method(Method.GET)
        .method(Method.POST)
        .consumes(MediaTypes.APPLICATION_JSON)
        .consumes(MediaTypes.APPLICATION_XML)
        .handler(exchange -&gt; {
            ...
        });
</code></pre> 
                    <p>The Web routes defined in a Web router can be queried as they are defined by invoking the <code>findRoutes()</code> method instead of the <code>handler()</code> method on the route manager. The following example select all routes matching <code>GET</code> method:</p> 
                    <pre><code class="language-java">Set&lt;WebRoute&lt;WebExchange&gt;&gt; routes = router
    .route()
        .method(Method.GET)
        .findRoutes();
</code></pre> 
                    <p>It is also possible to enable, disable or remove a set of routes in a similar way:</p> 
                    <pre><code class="language-java">// Disables all GET routes
router
    .route()
        .method(Method.GET)
        .disable();

// Enables all GET routes
router
    .route()
        .method(Method.GET)
        .enable();

// remove all GET routes
router
    .route()
        .method(Method.GET)
        .remove();
</code></pre> 
                    <p>Individual routes can also be enabled, disabled or removed as follows:</p> 
                    <pre><code class="language-java">// Disables all GET routes producing 'application/json'
router
    .route()
        .method(Method.GET)
        .findRoutes()
        .stream()
        .filter(route -&gt; route.getProduce().equals(MediaTypes.APPLICATION_JSON))
        .forEach(WebRoute::disable);

// Enables all GET routes producing 'application/json'
router
    .route()
        .method(Method.GET)
        .findRoutes()
        .stream()
        .filter(route -&gt; route.getProduce().equals(MediaTypes.APPLICATION_JSON))
        .forEach(WebRoute::enable);

// Removes all GET routes producing 'application/json'
router
    .route()
        .method(Method.GET)
        .findRoutes()
        .stream()
        .filter(route -&gt; route.getProduce().equals(MediaTypes.APPLICATION_JSON))
        .forEach(WebRoute::remove);
</code></pre> 
                    <p>** Path routing rule** Path routing rule</p> 
                    <p>The path routing rule matches exchanges whose request targets a specific path or a path that matches against a particular pattern. The path or path pattern of a routing rule must be absolute (ie. start with <code>/</code>).</p> 
                    <p>We can for instance define a route to handle all requests to <code>/bar/foo</code> as follows:</p> 
                    <pre><code class="language-java">router
    .route()
        .path("/foo/bar")
        .handler(exchange -&gt; {
            ...
        });
</code></pre> 
                    <p>The route in the preceding example specifies an exact match for the exchange request path, it is also possible to make the route match the path with or without a trailing slash as follows:</p> 
                    <pre><code class="language-java">router
    .route()
        .path("/foo/bar", true)
        .handler(exchange -&gt; {
            ...
        });
</code></pre> 
                    <p>A path pattern following the <a href="#uris">parameterized URIs notation</a> can also be specified to create a routing rule matching multiple paths. This also allows to specify <a href="#path-parameters">path parameters</a> that can be retrieved from the <code>WebExchange</code>.</p> 
                    <p>In the following example, the route will match exchanges whose request path is <code>/book/1</code>, <code>/book/abc</code>... and store the extracted parameter value in path parameter <code>id</code>:</p> 
                    <pre><code class="language-java">router
    .route()
        .path("/book/{id}")
        .handler(exchange -&gt; {
            exchange.request().pathParameters().get("id")...
        });
</code></pre> 
                    <p>A parameter is matched against a regular expression set to <code>[^/]*</code> by default which is why previous route does not match <code>/book/a/b</code>. Parameterized URIs allow to specify the pattern matched by a particular path parameter using <code>{[&lt;name&gt;][:&lt;pattern&gt;]}</code> notation, we can then put some constraints on path parameters value. For instance, we can make sure the <code>id</code> parameter is a number between 1 and 999:</p> 
                    <pre><code class="language-java">router
    .route()
        .path("/book/{id:[1-9][0-9]{0,2}}")
        .handler(exchange -&gt; {
            ...
        });
</code></pre> 
                    <p>If we just want to match a particular path without extracting path parameters, we can omit the parameter name and simply write:</p> 
                    <pre><code class="language-java">router
    .route()
        .path("/book/{}")
        .handler(exchange -&gt; {
            ...
        });
</code></pre> 
                    <p>** Method routing rule** Method routing rule</p> 
                    <p>The method routing rule matches exchanges that have been sent with a particular HTTP method.</p> 
                    <p>In order to handle all <code>GET</code> exchanges, we can do:</p> 
                    <pre><code class="language-java">router
    .route()
        .method(Method.GET)
        .handler(exchange -&gt; {
            ...
        });
</code></pre> 
                    <p>** Consume routing rule** Consume routing rule</p> 
                    <p>The consume routing rule matches exchanges whose request body content type matches a particular media range as defined by <a href="https://tools.ietf.org/html/rfc7231#section-5.3.2">RFC 7231 Section 5.3.2</a>.</p> 
                    <p>For instance, in order to match all exchanges with a <code>application/json</code> request payload, we can do:</p> 
                    <pre><code class="language-java">router
    .route()
        .method(Method.POST)
        .consumes(MediaTypes.APPLICATION_JSON)
        .handler(exchange -&gt; {
            ...
        });
</code></pre> 
                    <p>We can also specify a media range to match, for example, all exchanges with a <code>*/json</code> request payload:</p> 
                    <pre><code class="language-java">router
    .route()
        .method(Method.POST)
        .consumes("*/json")
        .handler(exchange -&gt; {
            ...
        });
</code></pre> 
                    <p>The two previous routes are different and as a result they can be both defined in the router, a content negotiation algorithm is used to determine which route should process a particular exchange as defined in <a href="https://tools.ietf.org/html/rfc7231#section-5.3">RFC 7231 Section 5.3</a>.</p> 
                    <p>Routes are sorted by consumed media ranges as follows:</p> 
                    <ul> 
                        <li>quality value is compared first as defined by <a href="https://tools.ietf.org/html/rfc7231#section-5.3.1">RFC7231 Section 5.3.1</a>, the default quality value is 1.</li> 
                        <li>type and subtype wildcards are considered after: <code>a/b</code> &gt; <code>a/*</code> &gt; <code>*/b</code> &gt; <code>*/*</code></li> 
                        <li>parameters are considered last, the most precise media range which is the one with the most parameters with values gets the highest priority (eg. <code>application/json;p1=a;p2=2</code> &gt; <code>application/json;p1=b</code> &gt; <code>application/json;p1</code>)</li> 
                    </ul> 
                    <p>The Web router then selects the first route whose media range matches the request <code>content-type</code> header field.</p> 
                    <p>If we consider previous routes, an exchange with a <code>application/json</code> request payload will be matched by the first route while an exchange with a <code>text/json</code> request will be matched by the second route.</p> 
                    <p>A media range can also be parameterized which allows for interesting setup such as:</p> 
                    <pre><code class="language-java">router
    .route()
        .path("/document")
        .method(Method.POST)
        .consumes("application/json;version=1")
        .handler(exchange -&gt; {
            ...
        });
    
router
    .route()
        .path("/document")
        .method(Method.POST)
        .consumes("application/json;version=2")
        .handler(exchange -&gt; {
            ...
        });

router
    .route()
        .path("/document")
        .method(Method.POST)
        .consumes("application/json")
        .handler(exchange -&gt; {
            ...
        });
</code></pre> 
                    <p>In the above example, an exchange with a <code>application/json;version=1</code> request payload is matched by the first route, <code>application/json;version=2</code> request payload is matched by the second route and any other <code>application/json</code> request payload is matched by the third route.</p> 
                    <p>If there is no route matching the content type of a request of an exchange matched by previous routing rules, a (415) unsupported media type error is returned.</p> 
                    <blockquote> 
                        <p>As described before, if no route is defined with a consume routing rule, exchanges are matched regardless of the request content type, content negotiation is then eventually delegated to the handler which must be able to process the payload whatever the format.</p> 
                    </blockquote> 
                    <p>** Produce routing rule** Produce routing rule</p> 
                    <p>The produce routing rule matches exchanges based on the acceptable media ranges supplied by the client in the <code>accept</code> header field of the request as defined by <a href="https://tools.ietf.org/html/rfc7231#section-5.3.2">RFC 7231 Section 5.3.2</a>.</p> 
                    <p>A HTTP client (eg. Web browser) typically sends a <code>accept</code> header to indicate the server which response media types are acceptable in the response. The Web router determines the best matching route based on the media types produced by the routes matching previous routing rules.</p> 
                    <p>We can for instance define the following routes:</p> 
                    <pre><code class="language-java">router
    .route()
        .path("/doc")
        .produces(MediaTypes.APPLICATION_JSON)
        .handler(exchange -&gt; {
            ...
        });
    
router
    .route()
        .path("/doc")
        .produces(MediaTypes.TEXT_XML)
        .handler(exchange -&gt; {
            ...
        });

</code></pre> 
                    <p>Now let's consider the following <code>accept</code> request header field:</p> 
                    <pre><code class="language-http">accept: application/json, application/xml;q=0.9, */xml;q=0.8
</code></pre> 
                    <p>This field basically tells the server that the client wants to receive first a <code>application/json</code> response payload, if not available a <code>application/xml</code> response payload and if not available any <code>*/xml</code> response payload.</p> 
                    <p>The content negotiation algorithm is similar as the one described in the <a href="#consume-routing-rule">consume routing rule</a>, it is simply reversed in the sense that it is the acceptable media ranges defined in the <code>accept</code> header field that are sorted and the route producing the media type matching the media range with the highest priority is selected.</p> 
                    <p>Considering previous routes, a request with previous <code>accept</code> header field is then matched by the first route.</p> 
                    <p>A request with the following <code>accept</code> header field is matched by the second route:</p> 
                    <pre><code class="language-http">accept: application/xml;q=0.9, */xml;q=0.8
</code></pre> 
                    <p>The exchange is also matched by the second route with the following <code>accept</code> header field:</p> 
                    <pre><code class="language-http">accept: application/json;q=0.5, text/xml;q=1.0
</code></pre> 
                    <p>If there is no route producing a media type that matches any of the acceptable media ranges, then a (406) not acceptable error is returned.</p> 
                    <blockquote> 
                        <p>As described before, if no route is defined with a produce routing rule, exchanges are matched regardless of the acceptable media ranges, content negotiation is then eventually delegated to the handler which becomes responsible to return an acceptable response to the client.</p> 
                    </blockquote> 
                    <p>** Language routing rule** Language routing rule</p> 
                    <p>Finally, the language routing rule matches exchanges based on the acceptable languages supplied by client in the <code>accept-language</code> header field of the request as defined by <a href="https://tools.ietf.org/html/rfc7231#section-5.3.5">RFC 7231 Section 5.3.5</a>.</p> 
                    <p>A HTTP client (eg. Web browser) typically sends a <code>accept-language</code> header to indicate the server which languages are acceptable for the response. The Web router determines the best matching route based on the language tags produced by the routes matching previous routing rules.</p> 
                    <p>We can defines the following routes to return a particular resource in English or in French:</p> 
                    <pre><code class="language-java">router
    .route()
        .path("/doc")
        .language("en-US")
        .handler(exchange -&gt; {
            ...
        });

router
    .route()
        .path("/doc")
        .language("fr-FR")
        .handler(exchange -&gt; {
            ...
        });
</code></pre> 
                    <p>The content negotiation is similar to the one described in the <a href="#produce-routing-rule">produce routing rule</a> but using language ranges and language types instead of media ranges and media types. Acceptable language ranges are sorted as follows:</p> 
                    <ul> 
                        <li>quality value is compared first as defined by <a href="https://tools.ietf.org/html/rfc7231#section-5.3.1">RFC 7231 Section 5.3.1</a>, the default quality value is 1.</li> 
                        <li>primary and secondary language tags and wildcards are considered after: <code>fr-FR</code> &gt; <code>fr</code> &gt; <code>*</code></li> 
                    </ul> 
                    <p>The Web router then selects the route whose produced language tag matches the language range with the highest priority.</p> 
                    <p>As for the produce routing rule, if there is no route defined with a language tag that matches any of the acceptable language ranges, then a (406) not acceptable error is returned. However, unlike the produce routing rule, a default route can be defined to handle such unmatched exchanges.</p> 
                    <p>For instance, we can add the following default route to the router:</p> 
                    <pre><code class="language-java">router
    .route()
        .path("/doc")
        .handler(exchange -&gt; {
            ...
        });
</code></pre> 
                    <p>A request with the following <code>accept-language</code> header field is then matched by the default route:</p> 
                    <pre><code class="language-http">accept-language: it-IT
</code></pre> 
                    <h5 id="error-routing">Error routing</h5> 
                    <p>An <code>ErrorRouter</code> is used to route an <code>ErrorWebExchange</code> to the right <code>ErrorWebExchangeHandler</code> when an exception is thrown during the normal processing of an exchange, it implements <code>ExchangeHandler&lt;ErrorExchange&lt;Throwable&gt;&gt;</code> and it is typically used as error handler in the HTTP server.</p> 
                    <h6 id="error-web-exchange">Error web exchange</h6> 
                    <p>The <em>web</em> module API extends the <a href="#http-server-exchange-api">server exchange API</a> defined in the <em>http-server</em> module and defines the server <code>ErrorWebExchangeHandler</code> to handle a server <code>ErrorWebExchange</code>. These interfaces respectively extends the <code>ExchangeHandler</code> and <code>Exchange</code> interfaces which are defined in the <em>http-server</em> module. An error Web exchange handler is typically attached to one or more error Web routes defined in an <code>ErrorWebRouter</code>.</p> 
                    <p>The <code>ErrorWebExchange</code> provides a response body encoder which can be used to encode error response body based on the content type specified in the response headers. The usage is exactly the same as for the Web server exchange <a href="#response-body-encoder">response body encoder</a>.</p> 
                    <pre><code class="language-java">errorRouter
    .route()
        .error(IllegalArgumentException.class)
        .produces(MediaTypes.APPLICATION_JSON)
        .handler(errorExchange -&gt; 
            errorExchange.response()
                .body()
                .encoder(Message.class)
                .value(new Message("IllegalArgumentException"))
        );
</code></pre> 
                    <h6 id="error-router">Error router</h6> 
                    <p>An <code>ErrorWebRouter</code> routes an error exchange to an error exchange handler attached to an <code>ErrorWebRoute</code> by matching it against a combination of routing rules specified in the route. An error route can combine the following routing rules which are matched in that order: the type of the error, the media ranges and language ranges accepted by the client. For instance, the error router matches an error exchange against the error type routing rule first, then the produce routing rule... Multiples routes can then match a given exchange but only one will be retained to actually process the exchange which is the one matching the highest routing rules.</p> 
                    <p>If a route doesn't define a particular routing rule, the routing rule is simply ignored and matches all exchanges. For instance, if a route doesn't define any error type routing rule, it matches error exchanges regardless of the error.</p> 
                    <p>The following is an example of an error route which matches all error exchanges and as a result handles all types of error:</p> 
                    <pre><code class="language-java">errorRouter
    .route()
        .handler(errorExchange -&gt; 
            errorExchange.response()
                .headers(headers -&gt; 
                    headers
                        .status(Status.INTERNAL_SERVER_ERROR)
                        .contentType(MediaTypes.TEXT_PLAIN)
                )
                .body()
                .empty()
        );
</code></pre> 
                    <blockquote> 
                        <p>An <code>ErrorWebRouter</code> is exposed in the <em>web</em> module and wired to the <em>http-server</em> module to override the HTTP server's error handler. It defines error routes to <em>whitelabel</em> error handlers for standard <code>HTTPexception</code> as defined by <a href="#http-base-api">HTTP base API</a> and producing <code>application/json</code> or <code>text/html</code> payloads. It can be configured to override these routes or defines others using an <code>ErrorWebRouterConfigurer</code> as defined in the <a href="#web-server">Web Server documentation</a>.</p> 
                    </blockquote> 
                    <p>The creation, activation, deactivation or removal of routes in an error router is done in the exact same way as for the <a href="#web-router">Web router</a>.</p> 
                    <p>In the following example, we define an error route to handle <code>SomeCustomException</code> producing <code>text/html</code> response in English for the clients that accept it:</p> 
                    <pre><code class="language-java">errorRouter
    .route()
        .error(SomeCustomException.class)
        .produces(MediaTypes.TEXT_HTML)
        .language("en-US")
        .handler(errorExchange -&gt; 
            ...
        );
</code></pre> 
                    <p>Error routes can be queried as follows:</p> 
                    <pre><code class="language-java">Set&lt;ErrorWebRoute&gt; errorRoutes = errorRouter
    .route()
        .error(SomeCustomException.class)
        .findRoutes();
</code></pre> 
                    <p>They can be enabled, disabled or removed as follows:</p> 
                    <pre><code class="language-java">// Disables all SomeCustomException routes
errorRouter
    .route()
        .error(SomeCustomException.class)
        .disable();

// Enables all SomeCustomException routes
errorRouter
    .route()
        .error(SomeCustomException.class)
        .enable();

// remove all SomeCustomException routes
errorRouter
    .route()
        .error(SomeCustomException.class)
        .remove();
</code></pre> 
                    <p>Individual error routes are enabled, disabled or removed as follows:</p> 
                    <pre><code class="language-java">// Disables all SomeCustomException routes producing 'application/json'
router
    .route()
        .error(SomeCustomException.class)
        .findRoutes()
        .stream()
        .filter(route -&gt; route.getProduce().equals(MediaTypes.APPLICATION_JSON))
        .forEach(WebRoute::disable);

// Enables all SomeCustomException routes producing 'application/json'
router
    .route()
        .error(SomeCustomException.class)
        .findRoutes()
        .stream()
        .filter(route -&gt; route.getProduce().equals(MediaTypes.APPLICATION_JSON))
        .forEach(WebRoute::enable);

// Removes all SomeCustomException routes producing 'application/json'
router
    .route()
        .error(SomeCustomException.class)
        .findRoutes()
        .stream()
        .filter(route -&gt; route.getProduce().equals(MediaTypes.APPLICATION_JSON))
        .forEach(WebRoute::remove);
</code></pre> 
                    <p>** Error type routing rule** Error type routing rule</p> 
                    <p>The error type routing rule matches error exchanges whose error is of a particular type.</p> 
                    <p>For instance, in order to handle all error exchanges whose error is an instance of <code>SomeCustomException</code>, we can do:</p> 
                    <pre><code class="language-java">errorRouter
    .route()
        .method(SomeCustomException.class)
        .handler(exchange -&gt; {
            ...
        });
</code></pre> 
                    <p>** Produce routing rule** Produce routing rule</p> 
                    <p>The produce routing rule, when applied to an error route behaves exactly the same as for a <a href="#produce-routing-rule">Web route</a>. It allows to define error handlers that produce responses of different types based on the set of media range accepted by the client.</p> 
                    <p>This is particularly useful to returned specific error responses to a particular client in a particular context. For instance, a backend application might want to receive errors in a parseable format like <code>application/json</code> whereas a Web browser might want to receive errors in a human readable format like <code>text/html</code>.</p> 
                    <p>** Language routing rule** Language routing rule</p> 
                    <p>The language routing rule, when applied to an error route behaves exactly the same as for a <a href="#language-routing-rule">Web route</a>. It allows to define error handlers that produce responses with different languages based on the set of language range accepted by the client fallbacking to the default route when content negotiation did not give any match.</p> 
                    <h4 id="static-handler">Static handler</h4> 
                    <p>The <code>StaticHandler</code> is a specific <code>WebExchangeHandler&lt;WebExchange&gt;</code> implementation that can be used to define routes for serving static resources resolved with the <a href="#resource-api">Resource API</a>.</p> 
                    <p>For instance, we can create a route to serve files stored in a <code>web-root</code> directory as follows:</p> 
                    <pre><code class="language-java">router
    .route()
        .path("/static/{path:.*}")                            // 1
        .handler(new StaticHandler(new FileResource("web-root/"))) // 2
</code></pre> 
                    <ol> 
                        <li>The path must be parameterized with a <code>path</code> parameter which can include <code>/</code>, for the static handler to be able to determine the relative path of the resource in the <code>web-root</code> directory</li> 
                        <li>The base resource is defined directly as a <code>FileResource</code>, although it is also possible to use a <code>ResourceService</code> to be more flexible in terms of the kind of resource</li> 
                    </ol> 
                    <p>The static handler relies on the resource abstraction to resolve resources, as a result, these can be located on the file system, on the class path, on the module path...</p> 
                    <p>The static handler also looks for a welcome page when a directory resource is requested. For instance considering the following <code>web-root</code> directory:</p> 
                    <pre><code class="language-plaintext">web-root/
â”œâ”€â”€ index.html
â””â”€â”€ snowflake.svg
</code></pre> 
                    <p>A request to <code>http://127.0.0.1/static/</code> would return the <code>index.html</code> file.</p> 
                    <h4 id="web-server">Web Server</h4> 
                    <p>The <em>web</em> module composes the <em>http-server</em> module and as a result it requires a <code>NetService</code> and a <code>ResourceService</code>. A set of <a href="#media-type-converter">media type converters</a> is also required for message payload conversion. All these services are provided by the <em>boot</em> module, so one way to create an application with a Web server is to create an Inverno module composing <em>boot</em> and <em>web</em> modules.</p> 
                    <pre><code class="language-java">@io.inverno.core.annotation.Module
module io.inverno.example.app_web {
    requires io.inverno.mod.boot;
    requires io.inverno.mod.web;
}
</code></pre> 
                    <p>The resulting <em>app_web</em> module, thus created, can then be started as an application as follows:</p> 
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.core.v1.Application;

public class Main {

    public static void main(String[] args) {
        Application.with(new App_web.Builder()).run();
    }
}
</code></pre> 
                    <p>The above example starts a Web server using default configuration which is a HTTP/1.x server with a Web router as root handler and an error router as error handler.</p> 
                    <pre><code class="language-plaintext">2021-04-14 11:00:18,308 INFO  [main] i.w.c.v.Application - Inverno is starting...


     â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
     â•‘                      , ~~ ,                                                                â•‘
     â•‘                  , '   /\   ' ,                                                            â•‘
     â•‘                 , __   \/   __ ,      _                                                    â•‘
     â•‘                ,  \_\_\/\/_/_/  ,    | |  ___  _    _  ___   __  ___   ___                 â•‘
     â•‘                ,    _\_\/_/_    ,    | | / _ \\ \  / // _ \ / _|/ _ \ / _ \                â•‘
     â•‘                ,   __\_/\_\__   ,    | || | | |\ \/ /|  __/| | | | | | |_| |               â•‘
     â•‘                 , /_/ /\/\ \_\ ,     |_||_| |_| \__/  \___||_| |_| |_|\___/                â•‘
     â•‘                  ,     /\     ,                                                            â•‘
     â•‘                    ,   \/   ,                                  -- 1.2.0 --                 â•‘
     â•‘                      ' -- '                                                                â•‘
     â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
     â•‘ Java runtime        : OpenJDK Runtime Environment                                          â•‘
     â•‘ Java version        : 16+36-2231                                                           â•‘
     â•‘ Java home           : /home/jkuhn/Devel/jdk/jdk-16                                         â•‘
     â•‘                                                                                            â•‘
     â•‘ Application module  : io.inverno.example.app_web                                           â•‘
     â•‘ Application version : 1.0.0-SNAPSHOT                                                       â•‘
     â•‘ Application class   : io.inverno.example.app_web.Main                                      â•‘
     â•‘                                                                                            â•‘
     â•‘ Modules             :                                                                      â•‘
     â•‘  ...                                                                                       â•‘
     â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


2021-04-14 11:00:18,313 INFO  [main] i.w.e.a.App_web - Starting Module io.inverno.example.app_web...
2021-04-14 11:00:18,313 INFO  [main] i.w.m.b.Boot - Starting Module io.inverno.mod.boot...
2021-04-14 11:00:18,494 INFO  [main] i.w.m.b.Boot - Module io.inverno.mod.boot started in 181ms
2021-04-14 11:00:18,494 INFO  [main] i.w.m.w.Web - Starting Module io.inverno.mod.web...
2021-04-14 11:00:18,495 INFO  [main] i.w.m.h.s.Server - Starting Module io.inverno.mod.http.server...
2021-04-14 11:00:18,495 INFO  [main] i.w.m.h.b.Base - Starting Module io.inverno.mod.http.base...
2021-04-14 11:00:18,499 INFO  [main] i.w.m.h.b.Base - Module io.inverno.mod.http.base started in 4ms
2021-04-14 11:00:18,570 INFO  [main] i.w.m.h.s.i.HttpServer - HTTP Server (nio) listening on http://0.0.0.0:8080
2021-04-14 11:00:18,570 INFO  [main] i.w.m.h.s.Server - Module io.inverno.mod.http.server started in 75ms
2021-04-14 11:00:18,571 INFO  [main] i.w.m.w.Web - Module io.inverno.mod.web started in 76ms
2021-04-14 11:00:18,571 INFO  [main] i.w.e.a.App_web - Module io.inverno.example.app_web started in 259ms

</code></pre> 
                    <p>The Web router doesn't define any routes by default so if we hit the server, a (404) not found error is returned showing the error router in action:</p> 
                    <pre><code class="language-plaintext">$ curl -i -H 'accept: application/json' http://locahost:8080
HTTP/1.1 404 Not Found
content-type: application/json
content-length: 47

{"status":"404","path":"/","error":"Not Found"}
</code></pre> 
                    <p>If you open <code>http://locahost:8080</code> in a Web browser, you should see the following (404) whitelabel error page:</p> 
                    <img class="img-fluid shadow mb-4" src="img/404_whitelabel.png" alt="HTTP 404 whitelabel error page" /> 
                    <h5 id="configuration-3">Configuration</h5> 
                    <p>The Web server configuration is done in the the <em>web</em> module configuration <code>WebConfiguration</code> which includes the <em>http-server</em> module configuration <code>HttpServerConfiguration</code>. As for the <em>http-server</em> module, the net service configuration can also be considered to set low level network configuration in the <em>boot</em> module.</p> 
                    <p>The following configuration can then be created in the <em>app_http</em> module:</p> 
                    <p>Let's create the following configuration in the <em>app_web</em> module:</p> 
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.core.annotation.NestedBean;
import io.inverno.mod.boot.NetConfiguration;
import io.inverno.mod.configuration.Configuration;
import io.inverno.mod.web.WebConfiguration;

@Configuration
public interface App_webConfiguration {

    @NestedBean
    NetConfiguration net();

    @NestedBean
    WebConfiguration web();
}
</code></pre> 
                    <p>The Web server can then be configured. For instance, we can enable HTTP/2 over cleartext, TLS, HTTP compression... as described in the <a href="#http-server-1">http-server module documentation</a>.</p> 
                    <p>For instance:</p> 
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.core.v1.Application;

public class Main {

    public static void main(String[] args) {
        Application.with(new App_web.Builder()
            .setApp_webConfiguration(
                    App_webConfigurationLoader.load(configuration -&gt; configuration
                        .web(web -&gt; web
                            .http_server(server -&gt; server
                                .server_port(8081)
                                .h2c_enabled(true)
                                .server_event_loop_group_size(4)
                            )
                        )
                    )
                )
        ).run();
    }
}
</code></pre> 
                    <h5 id="configuring-the-web-router">Configuring the Web router</h5> 
                    <p>As explained before, a <a href="#web-router">Web router</a> is used to route a request to the right handler based on a set of rules defined in a route. The <em>web</em> module provides a <code>WebRouter</code> bean which is wired to the <em>http-server</em> module to override the default root handler and handle all incoming requests to the server. Unlike the root handler in the <em>http-server</em> module, this bean is not overridable but it can be configured in order to define Web routes for the <em>app_web</em> module.</p> 
                    <p>This can be done by defining a <code>WebRouterConfigurer</code> bean in the <em>app_web</em> module. A Web router configurer is basically a <code>Consumer&lt;WebRouter&gt;</code> invoked after the initialization of the Web router and more precisely after the default configuration has been applied.</p> 
                    <p>Using what we've learned from the <a href="#web-routing">Web routing documentation</a>, routes can then be defined as follows:</p> 
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.core.annotation.Bean;
import io.inverno.mod.base.resource.MediaTypes;
import io.inverno.mod.web.WebExchange;
import io.inverno.mod.web.WebRouter;
import io.inverno.mod.web.WebRouterConfigurer;

@Bean
public class App_webWebRouterConfigurer implements WebRouterConfigurer&lt;WebExchange&gt; {

    @Override
    public void accept(WebRouter&lt;WebExchange&gt; router) {
        router
            .route()
                .path("/hello")
                .produces(MediaTypes.TEXT_PLAIN)
                .language("en-US")
                .handler(exchange -&gt; exchange
                    .response()
                        .body()
                        .encoder(String.class)
                        .value("Hello!")
                )
            .route()
                .path("/hello")
                .produces(MediaTypes.TEXT_PLAIN)
                .language("fr-FR")
                .handler(exchange -&gt; exchange
                    .response()
                        .body()
                        .encoder(String.class)
                        .value("Bonjour!")
                );
    }
}

</code></pre> 
                    <p>Now we can test the application:</p> 
                    <pre><code class="language-plaintext">$ curl -i http://locahost:8080/
HTTP/1.1 404 Not Found
content-length: 0
</code></pre> 
                    <pre><code class="language-plaintext">$ curl -i http://locahost:8080/hello
HTTP/1.1 200 OK
content-type: text/plain
content-length: 6

Hello!
</code></pre> 
                    <pre><code class="language-plaintext">$ curl -i -H 'accept-language: fr' http://locahost:8080/hello
HTTP/1.1 200 OK
content-type: text/plain
content-length: 8

Bonjour!
</code></pre> 
                    <pre><code class="language-plaintext">$ curl -i -H 'accept: application/json' http://locahost:8080/hello
HTTP/1.1 406 Not Acceptable
content-type: application/json
content-length: 81

{"status":"406","path":"/hello","error":"Not Acceptable","accept":["text/plain"]}
</code></pre> 
                    <h5 id="configuring-the-error-router">Configuring the error router</h5> 
                    <p>The <em>web</em> module also provides an error router bean wired to the <em>http-server</em> module to override the default error handler and handle all errors thrown when processing an exchange. As a reminder, an <a href="#error-router">error router</a> is used to route an error exchange to the right error handler based on a set of rules defined in an error route.</p> 
                    <p>As for the Web router, the error router can't be overridden, it is rather configured by defining an <code>ErrorWebRouterConfigurer</code> bean invoked after the initialization of the error router and more precisely after the default configuration has been applied which means default error routes remain although they can be overridden in the configurer.</p> 
                    <p>The error router implemented in the <em>web</em> module provides default error routes for handling base <code>HttpException</code>, whitelabel error pages are returned in particular when a client request <code>text/html</code> responses. More generally, <code>Throwable</code> errors are also handled by default, returning a generic (500) internal server error.</p> 
                    <p>Now let's assume, we have created a route which might throw a particular custom exception for which we want to return a particular response. For instance, we might have defined the following route in the <code>App_webWebRouterConfigurer</code>:</p> 
                    <pre><code class="language-java">@Bean
public class App_webWebRouterConfigurer implements WebRouterConfigurer&lt;WebExchange&gt; {

    @Override
    public void accept(WebRouter&lt;WebExchange&gt; router) {
        router
            ...
            .route()
                .path("custom_exception")
                .handler(exchange -&gt; {
                    throw new SomeCustomException();
                });
    }
}
</code></pre> 
                    <blockquote> 
                        <p>Note that an exchange handler is defined to throw checked <code>HttpException</code> only which actually makes sense since a Http error is eventually what will be returned to the client. In our example, the <code>SomeCustomException</code> is then either unchecked or extends <code>HttpException</code>.</p> 
                    </blockquote> 
                    <p>Now using what we've learned from the <a href="#error-routing">error routing documentation</a>, we can define an error route to handle that particular exception as follows:</p> 
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.core.annotation.Bean;
import io.inverno.mod.base.resource.MediaTypes;
import io.inverno.mod.http.base.Status;
import io.inverno.mod.web.ErrorWebRouter;
import io.inverno.mod.web.ErrorWebRouterConfigurer;

@Bean
public class App_webErrorWebRouterConfigurer implements ErrorWebRouterConfigurer {

    @Override
    public void accept(ErrorWebRouter errorRouter) {
        errorRouter
            .route()
                .error(SomeCustomException.class)
                .handler(errorExchange -&gt; errorExchange
                    .response()
                    .headers(headers -&gt; headers
                        .status(Status.BAD_REQUEST)
                        .contentType(MediaTypes.TEXT_PLAIN)
                    )
                    .body()
                    .encoder()
                    .value("A custom exception was raised")
                );
    }
}
</code></pre> 
                    <p>Now if we hit <code>http://locahost:8080/custom_exception</code> we should receive a custom error:</p> 
                    <pre><code class="language-plaintext">$ curl -i http://locahost:8080/custom_exception
HTTP/1.1 400 Bad Request
content-type: text/plain
content-length: 29

A custom exception was raised
</code></pre> 
                    <h5 id="webjars">WebJars</h5> 
                    <p>The Web server can also be configured to automatically serve static resources from <a href="https://www.webjars.org/">WebJars dependencies</a> using a version agnostic path: <code>/webjars/{webjar_module}/{path:.*}</code> where <code>{webjar_module}</code> corresponds to the <em>modularized</em> name of the WebJar minus <code>org.webjars</code>. For example the location of the Swagger UI WebJar would be <code>/webjars/swagger.ui/</code>.</p> 
                    <p>This feature can be activated with the following configuration:</p> 
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.core.v1.Application;

public class Main {

    public static void main(String[] args) {
        Application.with(new App_web.Builder()
                .setApp_webConfiguration(
                        App_webConfigurationLoader.load(configuration -&gt; configuration
                            .web(web -&gt; web
                                .enable_webjars(true)
                            )
                        )
                    )
            ).run();
    }
}
</code></pre> 
                    <p>Then we can declare WebJars dependencies such as the Swagger UI in the build descriptor:</p> 
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.webjars&lt;/groupId&gt;
            &lt;artifactId&gt;swagger-ui&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre> 
                    <p>The Swagger UI should now be accessible at <code>http://locahost:8080/webjars/swagger.ui/</code>.</p> 
                    <p>Sadly WebJars are not modular JARs, they are not even named modules which causes several issues when dependencies are specified on the module path. That's why when an application is run or packaged using <a href="https://github.com/inverno-io/inverno-tools">Inverno tools</a>, such dependencies and WebJars in particular are <em>modularized</em>. A WebJar such as <code>swagger-ui</code> is modularized into <code>org.webjars.swagger.ui</code> module which explains why it is referred by its module name: <code>swagger.ui</code> in the WebJars resource path (the <code>org.webjars</code> part is omitted since the context is known).</p> 
                    <p>When running a fully modular Inverno application, <em>modularized</em> WebJars modules must be added explicitly to the JVM using the <code>--add-modules</code> option, otherwise they are not resolved when the JVM starts. For instance:</p> 
                    <pre><code class="language-plaintext">$ java --add-modules org.webjars.swagger.ui ...
</code></pre> 
                    <p>Hopefully, the Inverno Maven plugin adds unnamed modules by default when running or packaging an application, so you shouldn't have to worry about it. The following command automatically adds the unnamed modules when running the JVM:</p> 
                    <pre><code class="language-plaintext">$ mvn inverno:run
</code></pre> 
                    <p>This can be disabled in order to manually control which modules should be added:</p> 
                    <pre><code class="language-plaintext">$ mvn inverno:run -Dinverno.exec.addUnnamedModules=false -Dinverno.exec.vmOptions="--add-modules org.webjars.swagger.ui"
</code></pre> 
                    <blockquote> 
                        <p>It might also be possible to define the dependency in the module descriptor, unfortunately since WebJars modules are unnamed, they are named against the name of the JAR file which is greatly unstable and can't be trusted, so previous approach is by far the safest. If you need to create a WebJar you should make it a named module with the <code>Automatic-Module-Name</code> attribute sets to <code>org.webjars.{webjar_module}</code> in the manifest file and with resources located under <code>META-INF/resources/webjars/{webjar_module}/{webjar_version}/</code>.</p> 
                    </blockquote> 
                    <p>Note that when the application is run with non-modular WebJars specified on the class path, they can be accessed without any particular configuration as part of the UNNAMED module using the same path notation.</p> 
                    <h5 id="openapi-specification">OpenAPI specification</h5> 
                    <p>The Web server can also be configured to expose <a href="https://www.openapis.org/">OpenAPI specifications</a> defined in <code>/META-INF/inverno/web/openapi.yml</code> resource in application modules.</p> 
                    <p>This feature can be activated with the following configuration:</p> 
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.core.v1.Application;

public class Main {

    public static void main(String[] args) {
        Application.with(new App_web.Builder()
                .setApp_webConfiguration(
                        App_webConfigurationLoader.load(configuration -&gt; configuration
                            .web(web -&gt; web
                                .enable_open_api(true)
                            )
                        )
                    )
            ).run();
    }
}
</code></pre> 
                    <p>When the server starts, it will scan for OpenAPI specifications files <code>/META-INF/inverno/web/openapi.yml</code> in the application modules and configure the following routes:</p> 
                    <ul> 
                        <li><code>/open-api</code> returning the list of available OpenAPI specifications in <code>application/json</code></li> 
                        <li><code>/open-api/{moduleName}</code> returning the OpenAPI specifications defined for the specified module name or (404) not found error if there is no OpenAPI specification defined in the module or no module with that name.</li> 
                    </ul> 
                    <p>If the server is also configured to serve <a href="#webjars">WebJars</a>, previous routes can also be used to display OpenAPI specifications in a <a href="https://swagger.io/tools/swagger-ui/">Swagger UI</a> assuming the Swagger UI WebJar dependency is present:</p> 
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.webjars&lt;/groupId&gt;
            &lt;artifactId&gt;swagger-ui&lt;/artifactId&gt;
            &lt;version&gt;3.46.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre> 
                    <blockquote> 
                        <p>OpenAPI specifications are usually automatically generated by the Web Inverno compiler plugin for routes defined in a <a href="#web-controller">Web controller</a> but you can provide manual or generated specifications using the tool of your choice, as long as it is not conflicting with the Web compiler plugin.</p> 
                    </blockquote> 
                    <h4 id="web-controller">Web Controller</h4> 
                    <p>The <a href="#web-router">Web router</a> and <a href="#web-server">Web server</a> documentations describe a <em>programmatic</em> way of defining the Web routes of a Web server but the <em>web</em> module API also provides a set of annotations for defining Web routes in a more declarative way.</p> 
                    <p>A <strong>Web controller</strong> is a regular module bean annotated with <code>@WebController</code> which defines methods annotated with <code>@WebRoute</code> describing Web routes. These beans are scanned at compile time by the Web Inverno compiler plugin in order to generate a single <code>WebRouterConfigurer</code> bean configuring the routes in the Web router.</p> 
                    <p>For instance, we can create a book resource with basic CRUD operations, to do so we must define a <code>Book</code> model in a dedicated <code>*.dto</code> package, we'll see later why this matters:</p> 
                    <pre><code class="language-java">package io.inverno.example.app_web.dto;

public class Book {

    private String isbn;
    private String title;
    private String author;
    private int pages;
    
    // Constructor, getters, setters, hashcode, equals...
}
</code></pre> 
                    <p>Now we can define a <code>BookResource</code> Web controller as follows:</p> 
                    <pre><code class="language-java">package io.inverno.example.app_web;

import java.util.Set;

import io.inverno.core.annotation.Bean;
import io.inverno.example.app_web.dto.Book;
import io.inverno.mod.base.resource.MediaTypes;
import io.inverno.mod.http.base.Method;
import io.inverno.mod.web.annotation.Body;
import io.inverno.mod.web.annotation.PathParam;
import io.inverno.mod.web.annotation.WebController;
import io.inverno.mod.web.annotation.WebRoute;

@Bean                                                                                          // 1
@WebController( path = "/book" )                                                               // 2
public class BookResource {

    @WebRoute( method = Method.POST, consumes = MediaTypes.APPLICATION_JSON )                  // 3
    public void create(@Body Book book) {                                                      // 4
        ...
    }
    
    @WebRoute( path = "/{isbn}", method = Method.PUT, consumes = MediaTypes.APPLICATION_JSON )
    public void update(@PathParam String isbn, @Body Book book) {
        ...
    }
    
    @WebRoute( method = Method.GET, produces = MediaTypes.APPLICATION_JSON )
    public Set&lt;Book&gt; list() {
        ...
    }
    
    @WebRoute( path = "/{isbn}", method = Method.GET, produces = MediaTypes.APPLICATION_JSON )
    public Book get(@PathParam String isbn) {
        ...
    }
    
    @WebRoute( path = "/{isbn}", method = Method.DELETE )
    public void delete(@PathParam String isbn) {
        ...
    }
}
</code></pre> 
                    <p>Implementations details have been omitted for clarity, here is what's important:</p> 
                    <ol> 
                        <li>A Web controller must be a module bean because it will be wired into the generated Web router configurer and used to invoke the right handler method attached to a Web route. Besides it is anyway convenient for implementation, a repository could be wired into the <code>BookResource</code> bean for instance.</li> 
                        <li>The <code>@WebController</code> annotation tells the Web compiler plugin to process the bean as a Web controller. The controller root path can also be specified in the annotation, if not specified it defaults to <code>/</code> which is the root path of the Web server.</li> 
                        <li>The <code>@WebRoute</code> annotation on a method tells the Web compiler plugin to define a route whose handler invokes that method. The set of routing rules (ie. path, method, consume, produce, language) describing the route are specified in the annotation.</li> 
                        <li>Parameters and request body are specified as method parameters annotated with <code>@CookieParam</code>, <code>@FormParam</code>, <code>@HeaderParam</code>, <code>@PathParam</code>, <code>@QueryParam</code> and <code>@Body</code> annotations.</li> 
                    </ol> 
                    <p>Some other contextual objects like the underlying <code>WebExchange</code> can also be injected in the Web controller method.</p> 
                    <p>Assuming we have provided proper implementations to create, update, list, get and delete a book in a data store, we can compile the module. A new module bean <code>io.inverno.example.app_web.WebRouterConfigurer</code> implementing <code>WebRouterConfigurer</code> should have been generated in <code>target/generated-sources/annotations</code>. It basically configures the routes corresponding to the Web controller's annotated methods in the Web router. This class uses the APIs described before and it is perfectly readable and debuggable and above all it eliminates the overhead of resolving Web controllers or Web routes at runtime.</p> 
                    <p>Now let's go back to the <code>Book</code> DTO, we said earlier that it must be created in a dedicated package, the reason is actually quite simple. Since above routes consume and produce <code>application/json</code> payloads, the <code>application/json</code> media type converter will be invoked to convert <code>Book</code> objects from/to JSON data. This converter uses an <code>ObjectMapper</code> object from module <code>com.fasterxml.jackson.databind</code> which uses reflection to instantiate the objects and populate them from a parsed JSON tree. Unfortunately or hopefully the Java modular system prevents unauthorized reflective access and as a result the <code>ObjectMapper</code> can't access the <code>Book</code> class unless we explicitly export the package containing DTOs to module <code>com.fasterxml.jackson.databind</code> in the module descriptor as follows:</p> 
                    <pre><code class="language-java">module io.inverno.example.app_web {
    ...    
    exports io.inverno.example.app_web.dto to com.fasterxml.jackson.databind;
}
</code></pre> 
                    <p>Using a dedicated package for DTOs allows then to limit and control the access to the module classes.</p> 
                    <blockquote> 
                        <p>If you're not familiar with the Java modular system and used to Java 8&lt;, you might find this a bit distressing but if you want to better structure and secure your applications, this is the way.</p> 
                    </blockquote> 
                    <p>We can now run the application and test the book resource:</p> 
                    <pre><code class="language-plaintext">$ curl -i http://locahost:8080/book
HTTP/1.1 200 OK
content-type: application/json
content-length: 2

[]
</code></pre> 
                    <pre><code class="language-plaintext">$ curl -i -X POST -H 'content-type: application/json' -d '{"isbn":"978-0132143011","title":"Distributed Systems: Concepts and Design","author":"George Coulouris, Jean Dollimore, Tim Kindberg, Gordon Blair","pages":1080}' http://locahost:8080/book
HTTP/1.1 200 OK
content-length: 0

</code></pre> 
                    <pre><code class="language-plaintext">$ curl -i http://locahost:8080/book
HTTP/1.1 200 OK
content-type: application/json
content-length: 163

[{"isbn":"978-0132143011","title":"Distributed Systems: Concepts and Design","author":"George Coulouris, Jean Dollimore, Tim Kindberg, Gordon Blair","pages":1080}]
</code></pre> 
                    <pre><code class="language-plaintext">$ curl -i http://locahost:8080/book/978-0132143011
HTTP/1.1 200 OK
content-type: application/json
content-length: 161

{"isbn":"978-0132143011","title":"Distributed Systems: Concepts and Design","author":"George Coulouris, Jean Dollimore, Tim Kindberg, Gordon Blair","pages":1080}
</code></pre> 
                    <blockquote> 
                        <p>If you have carefully followed the <em>web</em> module documentation, you should have noticed that we have previously created a Web router configurer bean in the <em>app_web</em> module which is indeed conflicting with the generated Web router configurer resulting in the following self-explanatory compilation error:</p> 
                        <pre><code class="language-plaintext">[ERROR] /home/jkuhn/Devel/git/frmk/io.inverno.example.app_web/src/main/java/module-info.java:[4,1] Multiple beans matching socket io.inverno.mod.web:webRouterConfigurer were found
 - io.inverno.example.app_web:app_webWebRouterConfigurer of type io.inverno.example.app_web.App_webWebRouterConfigurer
 - io.inverno.example.app_web:webRouterConfigurer of type io.inverno.example.app_web.WebRouterConfigurer
 
 Consider specifying an explicit wiring in module io.inverno.example.app_web (eg. @io.inverno.core.annotation.Wire(beans="io.inverno.example.app_web:app_webWebRouterConfigurer", into="io.inverno.mod.web:webRouterConfigurer") )
</code></pre> 
                        <p>In order to resolve that conflict, you can remove the first router configurer or define an explicit wire in the module definition:</p> 
                        <pre><code class="language-java">@io.inverno.core.annotation.Module
@io.inverno.core.annotation.Wire(beans="io.inverno.example.app_web:webRouterConfigurer", into="io.inverno.mod.web:webRouterConfigurer")
module io.inverno.example.app_web {
  ...
}
</code></pre> 
                        <p>Such situation can also occur when you are composing multiple modules defining Web controller beans and thus exposing multiple Web router configurers in the module. Hopefully it is safe to resolve these conflicts by wiring the Web router configurer of the module composing the <em>web</em> module as it aggregates all Web router configurers annotated with <code>@WebRoutes</code>. Please look at <a href="#composite-web-module">Composite Web module documentation</a> for further details.</p> 
                    </blockquote> 
                    <p>It is possible to separate the API from the implementation by defining the Web controller and the Web routes in an interface implemented in a module bean. For instance,</p> 
                    <pre><code class="language-java">package io.inverno.example.app_web;

import java.util.Set;

import io.inverno.example.app_web.dto.Book;
import io.inverno.mod.base.resource.MediaTypes;
import io.inverno.mod.http.base.Method;
import io.inverno.mod.web.annotation.Body;
import io.inverno.mod.web.annotation.PathParam;
import io.inverno.mod.web.annotation.WebController;
import io.inverno.mod.web.annotation.WebRoute;

@WebController(path = "/book")
public interface BookResource {

    @WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_JSON)
    void create(@Body Book book);
    
    @WebRoute(path = "/{isbn}", method = Method.PUT, consumes = MediaTypes.APPLICATION_JSON)
    void update(@PathParam String isbn, @Body Book book);
    
    @WebRoute(method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
    Set&lt;Book&gt; list();
    
    @WebRoute(path = "/{isbn}", method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
    Book get(@PathParam String isbn);
    
    @WebRoute(path = "/{isbn}", method = Method.DELETE)
    void delete(@PathParam String isbn);
}
</code></pre> 
                    <p>This provides better modularity allowing to define the API in a dedicated module which can later be used to implement various server and/or client implementations in different modules. Another advantage is that it allows to split a Web controller interface into multiple interfaces.</p> 
                    <p>Generics are also supported, we can for instance create a generic <code>CRUD&lt;T&gt;</code> interface as follows:</p> 
                    <pre><code class="language-java">package io.inverno.example.app_web;

import java.util.Set;

import io.inverno.mod.base.resource.MediaTypes;
import io.inverno.mod.http.base.Method;
import io.inverno.mod.web.annotation.Body;
import io.inverno.mod.web.annotation.PathParam;
import io.inverno.mod.web.annotation.WebRoute;

public interface CRUD&lt;T&gt; {

    @WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_JSON)
    void create(@Body T resource);
    
    @WebRoute(path = "/{id}", method = Method.PUT, consumes = MediaTypes.APPLICATION_JSON)
    void update(@PathParam String id, @Body T resource);
    
    @WebRoute(method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
    Set&lt;T&gt; list();
    
    @WebRoute(path = "/{id}", method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
    T get(@PathParam String id);
    
    @WebRoute(path = "/{id}", method = Method.DELETE)
    void delete(@PathParam String id);
}
</code></pre> 
                    <p>And then create specific resources sharing the same interface:</p> 
                    <pre><code class="language-java">package io.inverno.example.app_web;

import java.util.Set;

import io.inverno.example.app_web.dto.Book;
import io.inverno.mod.web.annotation.WebController;

@WebController(path = "/book")
public interface BookResource extends CRUD&lt;Book&gt; {

    void create(Book book);
    
    void update(String id, Book book);
    
    Set&lt;Book&gt; list();
    
    Book get(String id);
    
    void delete(String id);
}
</code></pre> 
                    <p>The book resource as we defined it doesn't seem very reactive, this statement is both true and untrue: the API and the Web server are fully reactive, as a result Web routes declared in the book resource Web controller are configured using a reactive API in the Web router configurer, nonetheless the methods in the Web controller are not reactive.</p> 
                    <p>Luckily, we can transform previous interfaces to make them fully reactive:</p> 
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.mod.base.resource.MediaTypes;
import io.inverno.mod.http.base.Method;
import io.inverno.mod.web.annotation.Body;
import io.inverno.mod.web.annotation.PathParam;
import io.inverno.mod.web.annotation.WebRoute;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

public interface CRUD&lt;T&gt; {

    @WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_JSON)
    Mono&lt;Void&gt; create(@Body Mono&lt;T&gt; resource);
    
    @WebRoute(path = "/{id}", method = Method.PUT, consumes = MediaTypes.APPLICATION_JSON)
    Mono&lt;Void&gt; update(@PathParam String id, @Body Mono&lt;T&gt; resource);
    
    @WebRoute(method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
    Flux&lt;T&gt; list();
    
    @WebRoute(path = "/{id}", method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
    Mono&lt;T&gt; get(@PathParam String id);
    
    @WebRoute(path = "/{id}", method = Method.DELETE)
    Mono&lt;Void&gt; delete(@PathParam String id);
}
</code></pre> 
                    <p>There is one remaining thing to do to make the book resource a proper REST resource. When creating a book we must return a 201 Created HTTP code with a <code>location</code> header as defined by <a href="https://tools.ietf.org/html/rfc7231#section-7.1.2">RFC7231 Section 7.1.2</a>. This can be done by injecting the <code>WebExchange</code> in the <code>create()</code> method:</p> 
                    <pre><code class="language-java">public interface CRUD&lt;T&gt; {

    @WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_JSON, produces = MediaTypes.APPLICATION_JSON)
    Mono&lt;Void&gt; create(@Body Mono&lt;T&gt; resource, WebExchange exchange);
    ...
}
</code></pre> 
                    <p>We can then do the following in the book resource implementation class:</p> 
                    <pre><code class="language-java">package io.inverno.example.app_web;

import io.inverno.core.annotation.Bean;
import io.inverno.example.app_web.dto.Book;
import io.inverno.mod.http.base.Status;
import io.inverno.mod.http.base.header.Headers;
import io.inverno.mod.web.WebExchange;
import reactor.core.publisher.Mono;

@Bean
public class BookResourceImpl implements BookResource {

    @Override
    public Mono&lt;Void&gt; create(Mono&lt;Book&gt; book, WebExchange exchange) {
        ...
        exchange.response().headers(headers -&gt; headers
            .status(Status.CREATED)
            .add(Headers.NAME_LOCATION, exchange.request().getPathBuilder().segment(b.getIsbn()).buildPath())
        );
        ...
    }
    ...
}
</code></pre> 
                    <p>Now if we run the application and create a book resource we should get the following:</p> 
                    <pre><code class="language-plaintext">$ curl -i -X POST -H 'content-type: application/json' -d '{"isbn":"978-0132143011","title":"Distributed Systems: Concepts and Design","author":"George Coulouris, Jean Dollimore, Tim Kindberg, Gordon Blair","pages":1080}' http://locahost:8080/book
HTTP/1.1 201 Created
content-type: application/json
location: /book/978-0132143012
content-length: 0

</code></pre> 
                    <h5 id="web-route">Web route</h5> 
                    <p>So far, we have described a concrete Web controller use case which should already give a good idea of what can be done with the <em>web</em> module. Now, let's examine in details how a Web route is declared in a Web controller.</p> 
                    <p>A Web route or HTTP endpoint or REST endpoint... in short an HTTP request/response exchange is essentially defined by:</p> 
                    <ul> 
                        <li>an input, basically an HTTP request characterized by the following components: path, method, query parameters, headers, cookies, path parameters, request body</li> 
                        <li>a normal output, basically a successful HTTP response and more especially: status (2xx or 3xx), headers, response body</li> 
                        <li>a set of error outputs, basically unsuccessful HTTP responses and more especially: status (4xx or 5xx), headers, response body</li> 
                    </ul> 
                    <p>Web routes are defined as methods in a Web controller which match this definition: the Web route input is defined in the parameters of the method, the Web route normal output is defined by the return type of the method and finally the exceptions thrown by the method define the Web route error outputs.</p> 
                    <p>It then remains to bind the Web route semantic to the method, this is done within various annotations on the method and its parameters.</p> 
                    <h6 id="routing-rules">Routing rules</h6> 
                    <p>Routing rules, as defined in the <a href="#web-router">Web router documentation</a>, are specified in a single <code>@WebRoute</code> annotation on a Web controller method. It allows to define the paths, the methods, the consumed media ranges, the produced media types and the produced languages of the Web routes that route a matching request to the handler implemented in the method.</p> 
                    <p>For instance, we can define multiple paths and/or multiple produced media types in order to expose a resource at different locations in different formats:</p> 
                    <pre><code class="language-java">@WebRoute( path = { "/book/current", "/book/v1" }, produces = { MediaTypes.APPLICATION_JSON, MediaTypes.APPLICATION_XML } )
Flux&lt;T&gt; list();
</code></pre> 
                    <blockquote> 
                        <p>Note that this exactly corresponds to the <em>web</em> module API</p> 
                    </blockquote> 
                    <p>The <code>matchTrailingSlash</code> parameter can be used to indicate that the defined path should be matched taking the trailing slash into account or not.</p> 
                    <h6 id="parameter-bindings">Parameter bindings</h6> 
                    <p>As stated above, a <code>@WebRoute</code> annotated method must be bound to the Web exchange. In particular, method parameters are bound to the various elements of the request using <code>@*Param</code> annotations defined in the <em>web</em> module API.</p> 
                    <p>Such parameters can be of any type, as long as the parameter converter plugged into the <em>web</em> module can convert it, otherwise a <code>ConverterException</code> is thrown. The default parameter converter provided in the <em>boot</em> module is able to convert primitive and common types including arrays and collections. Please refer to the <a href="#extend-http-services">HTTP server documentation</a> to learn how to extend the parameter converter to convert custom types.</p> 
                    <p>In the following example, the value or values of query parameter <code>isbns</code> is converted to an array of strings:</p> 
                    <pre><code class="language-java">@WebRoute( path = { "/book/byIsbn" }, produces = { MediaTypes.APPLICATION_JSON } )
Flux&lt;T&gt; getBooksByIsbn(@QueryParam String[] isbns);
</code></pre> 
                    <p>If the above route is queried with <code>/book/byIsbn?isbns=978-0132143011,978-0132143012,978-0132143013&amp;isbns=978-0132143014</code> the <code>isbns</code> parameter is then: <code>["978-0132143011", "978-0132143012", "978-0132143013", "978-0132143014"]</code>.</p> 
                    <p>A parameter defined like this is required by default and a <code>MissingRequiredParameterException</code> is thrown if one or more parameters are missing from the request but it can be declared as optional by defining it as an <code>Optional&lt;T&gt;</code>:</p> 
                    <p>In the following example, query parameter <code>limit</code> is optional and no exception will be thrown if it is missing from the request:</p> 
                    <pre><code class="language-java">@WebRoute( path = { "/book" }, produces = { MediaTypes.APPLICATION_JSON } )
Flux&lt;T&gt; getBooks(@QueryParam Optional&lt;Integer&gt; limit);
</code></pre> 
                    <p>** Query parameter** Query parameter</p> 
                    <p>Query parameters are declared using the <code>@QueryParam</code> annotation as follows:</p> 
                    <pre><code class="language-java">@WebRoute( path = { "/book/byIsbn" }, produces = { MediaTypes.APPLICATION_JSON } )
Flux&lt;T&gt; getBooksByIsbn(@QueryParam String[] isbns);
</code></pre> 
                    <p>Note that the name of the method parameter actually specifies the name of the query parameter.</p> 
                    <blockquote> 
                        <p>This contrasts with other RESTful API, such as JAX-RS, which requires to specify the parameter name, again, in the annotation. Since the Web Inverno compiler plugin works at compile time, it has access to actual method parameter names defined in the source.</p> 
                    </blockquote> 
                    <p>** Path parameter** Path parameter</p> 
                    <p>Path parameters are declared using the <code>@PathParam</code> annotation as follows:</p> 
                    <pre><code class="language-java">@WebRoute(path = "/{id}", method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
Mono&lt;T&gt; get(@PathParam String id);
</code></pre> 
                    <p>Note that the name of the method parameter must match the name of the path parameter of the route path defined in the <code>@WebRoute</code> annotation.</p> 
                    <p>** Cookie parameter** Cookie parameter</p> 
                    <p>It is possible to bind cookie values as well using the <code>@cookieParam</code> annotation as follows:</p> 
                    <pre><code class="language-java">@WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_JSON)
Mono&lt;Void&gt; create(@CookieParam String book_store, @Body Mono&lt;T&gt; book, WebExchange exchange);
</code></pre> 
                    <p>In previous example, the route must be queried with a <code>book_store</code> cookie:</p> 
                    <pre><code class="language-plaintext">$ curl -i -X POST -H 'cookie: book_store=store1' -H 'content-type: application/json' -d '...' http://locahost:8080/book
...
</code></pre> 
                    <p>** Header parameter** Header parameter</p> 
                    <p>Header field can also be bound using the <code>@HeaderParam</code> annotation as follows:</p> 
                    <pre><code class="language-java">@WebRoute(method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
Flux&lt;T&gt; list(@HeaderParam Optional&lt;Format&gt; format);
</code></pre> 
                    <p>In previous example, the <code>Format</code> type is an enumeration indicating how book references must be returned (eg. <code>SHORT</code>, <code>FULL</code>...), a <code>format</code> header may or may not be added to the request since it is declared as optional:</p> 
                    <pre><code class="language-plaintext">$ curl -i -H 'format: SHORT' http://locahost:8080/book
...
</code></pre> 
                    <p>** Form parameter** Form parameter</p> 
                    <p>Form parameters are bound using the <code>@FormParam</code> annotation as follows:</p> 
                    <pre><code class="language-java">@WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_X_WWW_FORM_URLENCODED)
Mono&lt;Void&gt; createAuthor(
    @FormParam String forename, 
    @FormParam Optional&lt;String&gt; middlename, 
    @FormParam String surname, 
    @FormParam LocalDate birthdate, 
    @FormParam Optional&lt;LocalDate&gt; deathdate, 
    @FormParam String nationality);
</code></pre> 
                    <p>Form parameters are sent in a request body using <code>application/x-www-form-urlencoded</code> format as defined by <a href="https://url.spec.whatwg.org/#application/x-www-form-urlencoded">living standard</a>. They can be sent using a HTML form submitted to the server resulting in the following request body:</p> 
                    <pre><code class="language-http">forename=Leslie,middlename=B.,surname=Lamport,birthdate=19410207,nationality=US
</code></pre> 
                    <p>Previous route can then be queried as follows:</p> 
                    <pre><code class="language-plaintext">$ curl -i -X POST -H 'content-type:application/x-www-form-urlencoded' -d 'forename=Leslie,middlename=B.,surname=Lamport,birthdate=19410207,nationality=US' http://locahost:8080/author
</code></pre> 
                    <p>Form parameters results from the parsing of the request body and as such, <code>@FormParam</code> annotations can't be used together with <code>@Body</code> on route method parameters.</p> 
                    <h6 id="contextual-parameters">Contextual parameters</h6> 
                    <p>A contextual parameter is directly related to the context into which an exchange is processed in the route method, it can be injected in the route method by specifying a method parameter of a supported contextual parameter type.</p> 
                    <p>** Exchange** Exchange</p> 
                    <p>Currently the only supported contextual parameter is the exchange which can be provided by specifying a method parameter of a type assignable from <code>WebExchange</code>.</p> 
                    <pre><code class="language-java">@WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_JSON)
Mono&lt;Void&gt; create(@Body Mono&lt;T&gt; book, WebExchange exchange);
</code></pre> 
                    <blockquote> 
                        <p>The exchange gives a full access to the underlying request and response. Although it allows to manipulate the request and response bodies, this might conflict with the generated Web route and as a result the exchange should only be used to specify a specific response status, response cookies or headers...</p> 
                    </blockquote> 
                    <h6 id="request-body-1">Request body</h6> 
                    <p>The request body can be bound to a route method parameter using the <code>@Body</code> annotation. Request body is automatically converted based on the media type declared in the <code>content-type</code> header field of the request as described in the <a href="#request-body-decoder">Web server exchange documentation</a>. The body parameter method can then be of any type as long as there is a media type converter for the media type specified in the request that can convert it.</p> 
                    <p>In the following example, the request body is bound to parameter <code>book</code> of type <code>Book</code>, it is then converted from <code>application/json</code> into a <code>Book</code> instance:</p> 
                    <pre><code class="language-java">@WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_JSON)
void create(@Body Book book);
</code></pre> 
                    <p>Unlike parameters, the request body can be provided in a non-blocking/reactive way, the previous example can then be rewritten using a <code>Mono&lt;T&gt;</code>, a <code>Flux&lt;T&gt;</code> or more broadly a <code>Publisher&lt;T&gt;</code> as body parameter type as follows:</p> 
                    <pre><code class="language-java">@WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_JSON)
Mono&lt;Void&gt; create(@Body Mono&lt;Book&gt; book);
</code></pre> 
                    <p>A stream of objects can be processed when the media type converter supports it. For instance, the <code>application/x-ndjson</code> converter can emit converted objects each time a new line is encountered, this allows to process content without having to wait for the entire message resulting in better response time and reduced memory consumption.</p> 
                    <pre><code class="language-java">@WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_X_NDJSON)
Mono&lt;Void&gt; create(@Body Flux&lt;Book&gt; book);
</code></pre> 
                    <blockquote> 
                        <p>The <code>application/json</code> also supports such streaming capability by emitting converted objects while parsing a JSON array.</p> 
                    </blockquote> 
                    <p>The <code>@Body</code> annotation can't be used together with the <code>@FormParam</code> annotation on route method parameters because the request body can only be consumed once.</p> 
                    <p>** Multipart form data** Multipart form data</p> 
                    <p>Multipart form data request body can be bound by defining a body parameter of type <code>Mono&lt;WebPart&gt;</code> if one part is expected, <code>Flux&lt;WebPart&gt;</code> if multiple parts are expected or more broadly of type <code>Publisher&lt;WebPart&gt;</code>.</p> 
                    <p>We can then rewrite the example described in <a href="#request-body-decoder">Web server exchange documentation</a> as follows:</p> 
                    <pre><code class="language-java">@WebRoute( path = "/bulk", method = Method.POST, consumes = MediaTypes.MULTIPART_FORM_DATA)
Flux&lt;Result&gt; createBulk(@Body Flux&lt;WebPart&gt; parts) {
    return parts
        .flatMap(part -&gt; part.decoder(Book.class).one())
        .map(book -&gt; storeBook(book));
}
</code></pre> 
                    <blockquote> 
                        <p>It is not possible to bind particular parts to a route method parameter. This design choice has been motivated by performance and resource consumption considerations. Indeed, this would require to consume and store the entire request body in memory before invoking the method. As a result, multipart data must still be handled <em>manually</em> using the <em>web</em> module API.</p> 
                    </blockquote> 
                    <h6 id="response-body">Response body</h6> 
                    <p>The response body is specified by the return type of the route method.</p> 
                    <pre><code class="language-java">@WebRoute(path = "/{id}", method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
Book get(@PathParam String id);
</code></pre> 
                    <p>As for the request body, the response body can be reactive if specified as a <code>Mono&lt;T&gt;</code>, a <code>Flux&lt;T&gt;</code> or more broadly as a <code>Publisher&lt;T&gt;</code>:</p> 
                    <pre><code class="language-java">@WebRoute(path = "/{id}", method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
Mono&lt;Book&gt; get(@PathParam String id);
</code></pre> 
                    <p>Depending on the media type converter, partial responses can be sent to the client as soon as they are complete. For instance a stream of responses can be sent to a client as follows:</p> 
                    <pre><code class="language-java">@WebRoute(path = "/", method = Method.GET, produces = MediaTypes.APPLICATION_X_NDJSON)
Stream&lt;Book&gt; list();
</code></pre> 
                    <p>In the preceding example, as soon as a book is retrieved from a data store it can be sent to the client which can then process responses as soon as possible reducing the latency and resource consumption on both client and server. The response content type is <code>application/x-ndjson</code>, so each book is encoded in JSON before a newline delimiter to let the client detects partial responses as defined by <a href="http://ndjson.org/">the ndjon format</a>.</p> 
                    <p>** Server-sent events** Server-sent events</p> 
                    <p>Server-sent events can be streamed in the response body when declared together with a server-sent event factory route method parameter. A server-sent event factory can be bound to a route method parameter using the <code>@SseEventFactory</code> annotation.</p> 
                    <p>In the following example, we declare a basic server-sent events Web route producing events with a <code>String</code> message:</p> 
                    <pre><code class="language-java">@WebRoute(path = "/event", method = Method.GET)
Publisher&lt;WebResponseBody.SseEncoder.Event&lt;String&gt;&gt; getBookEvents(@SseEventFactory WebResponseBody.SseEncoder.EventFactory&lt;String&gt; events);
</code></pre> 
                    <p>Server-sent event return type can be any of <code>Mono&lt;WebResponseBody.SseEncoder.Event&lt;T&gt;&gt;</code> if only one event is expected, <code>Flux&lt;WebResponseBody.SseEncoder.Event&lt;T&gt;&gt;</code> if multiple events are expected and more broadly <code>Publisher&lt;WebResponseBody.SseEncoder.Event&lt;T&gt;&gt;</code>.</p> 
                    <p>By default, the media type of a server-sent event message is <code>text/plain</code> but it can be encoded using a specific media type converter as well by specifying a media type in the <code>@SseEventFactory</code> annotation.</p> 
                    <p>We can rewrite previous <a href="#server-sent-events">SSE example</a> with a message of a custom type as follows:</p> 
                    <pre><code class="language-java">@WebRoute(path = "/event", method = Method.GET)
public Publisher&lt;WebResponseBody.SseEncoder.Event&lt;BookEvent&gt;&gt; getBookEvents(@SseEventFactory(MediaTypes.APPLICATION_JSON) WebResponseBody.SseEncoder.EventFactory&lt;BookEvent&gt; events) {
    return Flux.interval(Duration.ofSeconds(1))
        .map(seq -&gt; events.create(
                event -&gt; event
                    .id(Long.toString(seq))
                    .event("bookEvent")
                    .value(new BookEvent("some book event"))
            )
        );
}
</code></pre> 
                    <h5 id="composite-web-module">Composite Web module</h5> 
                    <p>The Web Inverno compiler plugin generates a single Web router configurer bean aggregating all route definitions specified in Web controllers beans in the module. When the module composes the <em>web</em> module, this bean is then plugged in the <em>web</em> module to configure the Web server router.</p> 
                    <p>Now if the module doesn't compose the <em>web</em> module, the Web router configurer bean is simply exposed by the module waiting for the module to be composed within other modules until a top module eventually composes the <em>web</em> module.</p> 
                    <p>This raises two issues:</p> 
                    <ul> 
                        <li>First if multiple modules exposing web router configurers are composed together with the <em>web</em> module, we'll end up with dependency injection conflicts since multiple web router configurer beans can be wired to the <em>web</em> module. Selecting one of them with a <code>@Wire</code> annotation doesn't really solve the problem since we expect all routes to be configured in the Web server router.</li> 
                        <li>Then if such module is composed in another module defining other Web controllers, we still need to expose one Web router configurer providing all route definitions to a top module composing the <em>web</em> module.</li> 
                    </ul> 
                    <p>In order to solve these issues, the Web Inverno compiler plugin aggregates all Web router configurer beans annotated with <code>@WebRoutes</code> into the generated Web router configurer of the module so that it can be used to configure all defined routes. This includes Web router configurer exposed in component modules as well as user defined Web router configurer beans within the module.</p> 
                    <p>A generated Web router configurer is always annotated with a <code>@WebRoutes</code> annotation specifying the Web routes it configures. For instance, the Web router configurer generated for the module defining the book Web controller looks like:</p> 
                    <pre><code class="language-java">@WebRoutes({
    @WebRoute(path = { "/book/{id}" }, method = { Method.GET }, produces = { "application/json" }),
    @WebRoute(path = { "/book" }, method = { Method.POST }, consumes = { "application/json" }),
    @WebRoute(path = { "/book/{id}" }, method = { Method.PUT }, consumes = { "application/json" }),
    @WebRoute(path = { "/book" }, method = { Method.GET }, produces = { "application/json" }),
    @WebRoute(path = { "/book/{id}" }, method = { Method.DELETE })
})
@Bean
public final class WebRouterConfigurer implements io.inverno.mod.web.WebRouterConfigurer&lt;WebExchange&gt; {
    ...
}
</code></pre> 
                    <p>This information is used by the compiler plugin to statically check that there is no conflicting routes when generating the Web router configurer.</p> 
                    <p>Now let's imagine we have created a modular Web application with a <em>book</em> module defining the book Web controller, an <em>admin</em> module defining some admin Web controllers and a top <em>app</em> module composing these modules together with the <em>web</em> module.</p> 
                    <p>The module descriptors for each of these modules should look like:</p> 
                    <pre><code class="language-java">@io.inverno.core.annotation.Module( excludes = { "io.inverno.mod.web" } )
module io.inverno.example.web_modular.admin {
    requires io.inverno.core;
    requires io.inverno.mod.web;

    exports io.inverno.example.web_modular.admin to io.inverno.example.web_modular.app;
}
</code></pre> 
                    <pre><code class="language-java">@io.inverno.core.annotation.Module( excludes = { "io.inverno.mod.web" } )
module io.inverno.example.web_modular.book {
    requires io.inverno.core;
    requires io.inverno.mod.web;
    
    exports io.inverno.example.web_modular.book to io.inverno.example.web_modular.app;
    exports io.inverno.example.web_modular.book.dto to com.fasterxml.jackson.databind;
}
</code></pre> 
                    <pre><code class="language-java">@io.inverno.core.annotation.Module
module io.inverno.example.web_modular.app {
    requires io.inverno.mod.boot;
    requires io.inverno.mod.web;
    
    requires io.inverno.example.web_modular.admin;
    requires io.inverno.example.web_modular.book;
}
</code></pre> 
                    <p>The first thing to notice is that the <em>web</em> module is excluded from <em>admin</em> and <em>book</em> modules since we don't want to start a Web server in these modules, we only need the Web API to define Web controllers and generate Web router configurer beans. As a consequence, the <em>boot</em> module which provides converters and net service required to create and start the <em>web</em> module is also not required but the <code>io.inverno.core</code> module is still required. Finally we must export packages containing the generated module classes to the <em>app</em> module so it can compose them.</p> 
                    <p>The <em>admin</em> and <em>book</em> modules should compile just fine resulting in two Web router configurer beans being generated and exposed in each module. But the compilation of <em>app</em> module should raise some dependency injection errors since multiple Web router configurer beans exist whereas only one can be wired to the <em>web</em> module. There are actually three Web configurer beans, how so? There are those exposed by the <em>admin</em> and <em>book</em> modules and one Web router configurer bean generated in the <em>app</em> module and aggregating the previous two. In order to solve the conflict, we should then define the following explicit wire in the <em>app</em> module:</p> 
                    <pre><code class="language-java">@io.inverno.core.annotation.Module
@io.inverno.core.annotation.Wire(beans="io.inverno.example.web_modular.app:webRouterConfigurer", into="io.inverno.mod.web:webRouterConfigurer")
module io.inverno.example.web_modular.app {
    ...
}
</code></pre> 
                    <blockquote> 
                        <p>One could rightfully argue that this explicit wiring is useless and cumbersome, but it is consistent with the IoC/DI core framework principles. Keeping things simple and explicit limits possible side effects induced by the fact that what's happening with <em>automatic</em> conflict resolution is often specific and might not be obvious. This is all the more true when such behavior is manually overridden.</p> 
                    </blockquote> 
                    <p>The same principles applies if multiple modules like <em>admin</em> or <em>book</em> are cascaded into one another: the Web router configurer beans at a given level are aggregated in the Web router configurer bean in the next level.</p> 
                    <h5 id="automatic-openapi-specifications">Automatic OpenAPI specifications</h5> 
                    <p>Besides facilitating the development of REST and Web resources in general, Web controllers also simplify documentation. The Web Inverno compiler plugin can be setup to generate <a href="https://www.openapis.org/">Open API</a> specifications from the Web controller classes defined in a module and their JavaDoc comments.</p> 
                    <blockquote> 
                        <p>Writing JavaDoc comments is something natural when developing in the Java language, with this approach, a REST API can be documented just as you document a Java class or method, documentation is written once and can be used in both Java and other languages and technologies using the generated Open API specification.</p> 
                    </blockquote> 
                    <p>In order to activate this feature the <code>inverno.web.generateOpenApiDefinition</code> annotation processor option must be enabled when compiling a Web module. This can be done on the command line: <code>java -Ainverno.web.generateOpenApiDefinition=true ...</code> or in the Maven compiler plugin configuration in the build descriptor:</p> 
                    <pre><code class="language-java">&lt;project&gt;
    &lt;build&gt;
        &lt;pluginManagement&gt;
            &lt;plugins&gt;
                &lt;plugin&gt;
                    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                    &lt;configuration&gt;
                        &lt;compilerArgs combine.children="append"&gt;
                            &lt;arg&gt;-Ainverno.web.generateOpenApiDefinition=true&lt;/arg&gt;
                        &lt;/compilerArgs&gt;
                    &lt;/configuration&gt;
                &lt;/plugin&gt;
            &lt;/plugins&gt;
        &lt;/pluginManagement&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre> 
                    <p>The compiler then generates an Open API specification in <code>META-INF/inverno/web/openapi.yml</code> for any module defining one or more Web controllers.</p> 
                    <p>The previous <a href="#web-controller">book resource</a> could then be documented as follows:</p> 
                    <pre><code class="language-java">/**
 * The book resource.
 */
@Bean
@WebController(path = "/book")
public class BookResource {
    
    /**
     * Creates a book resource.
     * 
     * @param book a book
     * @param exchange the web exchange
     * 
     * @return the book resource has been successfully created
     * @throws BadRequestException A book with the same ISBN reference already exist
     */
    @WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_JSON)
    public Mono&lt;Void&gt; create(@Body Mono&lt;Book&gt; book, WebExchange exchange) throws BadRequestException { ... }
    
    /**
     * Updates a book resource.
     * 
     * @param isbn the reference of the book resource to update
     * @param book the updated book resource
     * 
     * @return the book resource has been successfully updated
     * @throws NotFoundException if the specified reference does not exist
     */
    @WebRoute(path = "/{isbn}", method = Method.PUT, consumes = MediaTypes.APPLICATION_JSON)
    public Mono&lt;Void&gt; update(@PathParam String isbn, @Body Mono&lt;Book&gt; book) throws NotFoundException { ... }
    
    /**
     * Returns the list of book resources.
     * 
     * @return a list of book resources
     */
    @WebRoute(method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
    public Flux&lt;Book&gt; list();
    
    /**
     * Returns the book resource identified by the specified ISBN.
     * 
     * @param isbn an ISBN
     * 
     * @return the requested book resource
     * @throws NotFoundException if the specified reference does not exist
     */
    @WebRoute(path = "/{isbn}", method = Method.GET, produces = MediaTypes.APPLICATION_JSON)
    public Mono&lt;Book&gt; get(@PathParam String isbn) throws NotFoundException { ... }
    
    /**
     * Deletes the book resource identified by the specified ISBN.
     * 
     * @param isbn an ISBN
     * 
     * @return the book resource has been successfully deleted
     * @throws NotFoundException if the specified reference does not exist
     */
    @WebRoute(path = "/{isbn}", method = Method.DELETE)
    public Mono&lt;Void&gt; delete(@PathParam String isbn) { ... }
}
</code></pre> 
                    <p>Note that just like the <code>javadoc</code> tool, the Web compiler plugin takes inheritance into account when resolving JavaDoc comments and as a result, it is possible to define JavaDoc comments in an interface and enrich or override them in the implementation classes.</p> 
                    <p>By default, the normal HTTP status code responded by a route is assumed to be <code>200</code> but it is possible to specify a custom status code using the <code>@inverno.web.status</code> tag. For instance the book creation route which actually responds with a <code>201</code> status should be documented as follows:</p> 
                    <pre><code class="language-java">public class BookResource {

    /**
     * Creates a book resource.
     * 
     * @param book a book
     * @param exchange the web exchange
     * 
     * @return {@inverno.web.status 201} the book resource has been successfully created
     * @throws BadRequestException A book with the same ISBN reference already exist
     */
    @WebRoute(method = Method.POST, consumes = MediaTypes.APPLICATION_JSON)
    public Mono&lt;Void&gt; create(@Body Mono&lt;Book&gt; book, WebExchange exchange) throws BadRequestException { ... }
    
    ...
}
</code></pre> 
                    <blockquote> 
                        <p>Multiple <code>@return</code> statements can be specified if multiple response statuses are expected, however this might raise issues during the generation of the JavaDoc, you can bypass this by disabling the linter with <code>-Xdoclint:none</code> option.</p> 
                    </blockquote> 
                    <p>This tag can also be used to specify error status code in <code>@throws</code> statements, but this is usually not necessary since the Web compiler plugin automatically detects status code for regular <code>HTTPException</code> such as <code>BadRequestException</code> (400) or <code>NotFoundException</code> (404).</p> 
                    <p>The Web compiler plugin generates, per module, one Open API specification and one Web router configurer bean aggregating all routes from all Web controllers. As a result the general API documentation corresponds to the general documentation of the module and defined in the module descriptor JavaDoc comment.</p> 
                    <p>For instance, we can describe the API exposed by the <em>book</em> module in the module descriptor including the API version which should normally match the module version:</p> 
                    <pre><code class="language-java">/**
 * This is a sample Book API which demonstrates Inverno Web module capabilities.
 * 
 * @author &lt;a href="mailto:jeremy.kuhn@inverno.io"&gt;Jeremy Kuhn&lt;/a&gt;
 * 
 * @version 1.2.3
 */
@io.inverno.core.annotation.Module( excludes = { "io.inverno.mod.web" } )
module io.inverno.example.web_modular.book {
    requires io.inverno.core;
    requires io.inverno.mod.web;
    
    exports io.inverno.example.web_modular.book to io.inverno.example.web_modular.app;
    exports io.inverno.example.web_modular.book.dto to com.fasterxml.jackson.databind;
}
</code></pre> 
                    <p>These specifications can also be exposed in the Web server as described in the <a href="#web-server">Web server documentation</a>.</p> 
                    <p>If we build and run the <a href="#composite-web-module">modular book application</a> and access <code>http://locahost:8080/open-api</code> in a Web browser we should see a Swagger UI loaded with the Open API specifications of the <em>admin</em> and <em>book</em> modules:</p> 
                    <img class="img-fluid shadow mb-4" src="img/swaggerUI_root.png" alt="General Swagger UI" /> 
                    <p>It is also possible to target a single specification by specifying the module name in the URI, for instance <code>http://locahost:8080/open-api/io.inverno.example.web_modular.book</code>:</p> 
                    <img class="img-fluid shadow mb-4" src="img/swaggerUI_module.png" alt="Module Swagger UI" /> 
                    <p>Finally, Open API specifications formatted in <a href="https://en.wikipedia.org/wiki/YAML">YAML</a> can be retrieved as follows:</p> 
                    <pre><code class="language-plaintext">$ curl http://locahost:8080/open-api/io.inverno.example.web_modular.admin

openapi: 3.0.3
info:
    title: 'io.inverno.example.web_modular.admin'
    version: ''
...
</code></pre> 
                    <h2 id="inverno-maven-plugin-1">Inverno Maven Plugin</h2> 
                    <p>The Inverno Maven Plugin is used to run, package and distribute modular applications and Inverno applications in particular. It relies on a set of Java tools to build native runtime or application images as well as Docker or OCI images for modular Java projects.</p> 
                    <h3 id="usage">Usage</h3> 
                    <p>The Inverno Maven plugin can be used to run a modular application project or build an image for a modular project. There are three types of images that can be build using the plugin:</p> 
                    <ul> 
                        <li><strong>runtime image</strong> is a custom Java runtime containing a set of modules and their dependencies.</li> 
                        <li><strong>application image</strong> is a native self-contained Java application including all the necessary dependencies to run the application without the need of a Java runtime.</li> 
                        <li><strong>container image</strong> is a Docker or CLI container image that can be packaged as a TAR archive or directly deployed on a Docker daemon or container registry.</li> 
                    </ul> 
                    <h4 id="run-a-module-application-project">Run a module application project</h4> 
                    <p>The <code>inverno:run</code> goal is used to execute the modular application defined in the project from the command line.</p> 
                    <pre><code class="language-plaintext">$ mvn inverno:run
</code></pre> 
                    <p>The application is first <em>modularized</em> which means that any non-modular dependency is modularized by generating an appropriate module descriptor using the <code>jdeps</code> tool in order for the application to be run with a module path and not a class path (and certainly not both).</p> 
                    <p>The application is executed in a forked process, application arguments can be passed on the command line:</p> 
                    <pre><code class="language-plaintext">$ mvn inverno:run -Dinverno.run.arguments='--some.configuration=\"hello\"'
</code></pre> 
                    <blockquote> 
                        <p>Actual arguments are determined by splitting the parameter value around spaces. There are several options to declare an argument which contains spaces:</p> 
                        <ul> 
                            <li>it can be escaped: <code>Hello\ World</code></li> 
                            <li>it can be quoted: <code>"Hello World"</code> or <code>'Hello World'</code></li> 
                        </ul> 
                        <p>Since quotes or double quotes are used as delimiters, they might need to be escaped as well to declare an argument that contains some: <code>I\'m\ happy</code>, <code>"I'm happy"</code>, <code>'I\'m happy'</code>.</p> 
                    </blockquote> 
                    <p>In order to debug the application, we need to specify the appropriate options to the JVM:</p> 
                    <pre><code class="language-plaintext">$ mvn inverno:run -Dinverno.exec.vmOptions="-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000"
</code></pre> 
                    <p>By default the plugin will detect the main class of the application, but it is also possible to specify it explicitly in case multiple main classes exist in the project module.</p> 
                    <pre><code class="language-plaintext">$ mvn inverno:run -Dinverno.exec.mainClass=io.inverno.example.Main
</code></pre> 
                    <p>A pidfile is created when the application is started under <code>${project.build.directory}/maven-inverno</code> directory, it indicates the pid of the process running the application. If the build exits while the application is still running or if the pidfile was not properly removed after the application has exited, it might be necessary to manually kill the process and/or remove the pidfile.</p> 
                    <h4 id="start-and-stop-the-application-for-integration-testing">Start and stop the application for integration testing</h4> 
                    <p>The <code>inverno:start</code> and <code>inverno:stop</code> goals are used together to start and stop the application while not blocking the Maven build process which can then execute other goals targeting the running application such as integration tests.</p> 
                    <p>They are bound to the <code>pre-integration-test</code> and <code>pre-integration-test</code> phases respectively:</p> 
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;io.inverno.tool&lt;/groupId&gt;
                &lt;artifactId&gt;inverno-maven-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;start&lt;/id&gt;
                        &lt;phase&gt;pre-integration-test&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;start&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                    &lt;execution&gt;
                        &lt;id&gt;stop&lt;/id&gt;
                        &lt;phase&gt;post-integration-test&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;stop&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre> 
                    <h4 id="build-a-runtime-image">Build a runtime image</h4> 
                    <p>A runtime image is a custom Java runtime distribution containing specific modules and their dependencies. Such image is used as a base for generating application image but it can also be distributed as a lightweight Java runtime.</p> 
                    <p>The <code>inverno:build-runtime</code> goal uses <code>jlink</code> tool to assemble the project module and its dependencies.</p> 
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;io.inverno.tool&lt;/groupId&gt;
                &lt;artifactId&gt;inverno-maven-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;build-project-runtime&lt;/id&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;build-runtime&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;vm&gt;server&lt;/vm&gt;
                            &lt;addModules&gt;jdk.jdwp.agent,jdk.crypto.ec&lt;/addModules&gt;
                            &lt;vmOptions&gt;-Xms2G -Xmx2G -XX:+UseNUMA -XX:+UseParallelGC&lt;/vmOptions&gt;
                            &lt;formats&gt;
                                &lt;format&gt;zip&lt;/format&gt;
                                &lt;format&gt;tar.gz&lt;/format&gt;
                                &lt;format&gt;tar.bz2&lt;/format&gt;
                            &lt;/formats&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre> 
                    <p>By default, the project module and its dependencies are included in the resulting image, this include JDK's modules such as <code>java.base</code>, in the previous example we've also explicitly added the <code>jdk.jdwp.agent</code> to support remote debugging and <code>jdk.crypto.ec</code> to support TLS communications.</p> 
                    <p>The resulting image is packaged to the formats defined in the configuration and attached, by default, to the Maven project.</p> 
                    <h4 id="build-an-application-image">Build an application image</h4> 
                    <p>An application image is built using the <code>inverno:build-app</code> goal which basically generates a runtime image and uses <code>jpackage</code> tool to generate a native platform-specific application package.</p> 
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;io.inverno.tool&lt;/groupId&gt;
                &lt;artifactId&gt;inverno-maven-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;build-application&lt;/id&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;build-app&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;vm&gt;server&lt;/vm&gt;
                            &lt;addModules&gt;jdk.jdwp.agent,jdk.crypto.ec&lt;/addModules&gt;
                            &lt;vmOptions&gt;-Xms2G -Xmx2G -XX:+UseNUMA -XX:+UseParallelGC&lt;/vmOptions&gt;
                            &lt;formats&gt;
                                &lt;format&gt;zip&lt;/format&gt;
                                &lt;format&gt;deb&lt;/format&gt;
                            &lt;/formats&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre> 
                    <p>The <code>inverno:build-app</code> goal is very similar to the <code>inverno:build-runtime</code> goal except that the resulting image provides an application launcher and it can be packaged in a platform-specific format. For instance, we can generate a <code>.deb</code> on a Linux platform or a <code>.exe</code> or <code>.msi</code> on a Windows platform or a <code>.dmg</code> on a MacOS platform. The resulting package can be installed on these platforms in a standard way.</p> 
                    <blockquote> 
                        <p>This goal uses <code>jpackage</code> tool which is an incubating feature in JDK&lt;16, if you intend to build an application image with an old JDK, you'll need to explicitly add the <code>jdk.incubator.jpackage</code> module in <code>MAVEN_OPTS</code>:</p> 
                        <pre><code class="language-plaintext">$ export MAVEN_OPTS="--add-modules jdk.incubator.jpackage"
</code></pre> 
                    </blockquote> 
                    <h4 id="build-a-container-image-tarball">Build a container image tarball</h4> 
                    <p>A container image can be built in a TAR archive using the <code>inverno:build-image-tar</code> goal which basically build an application package and package it in a container image.</p> 
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;io.inverno.tool&lt;/groupId&gt;
                &lt;artifactId&gt;inverno-maven-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;build-image-tar&lt;/id&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;build-image-tar&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;vm&gt;server&lt;/vm&gt;
                            &lt;addModules&gt;jdk.jdwp.agent,jdk.crypto.ec&lt;/addModules&gt;
                            &lt;vmOptions&gt;-Xms2G -Xmx2G -XX:+UseNUMA -XX:+UseParallelGC&lt;/vmOptions&gt;
                            &lt;repository&gt;example&lt;/repository&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre> 
                    <p>The resulting image reference is defined by <code>${registry}/${repository}/${name}:${project.version}</code>, the registry and the repository are optional and the name default to the project artifact id.</p> 
                    <p>The resulting image can then be loaded in a docker daemon:</p> 
                    <pre><code class="language-plaintext">$ docker load --input target/example-1.0.0-SNAPSHOT-container_linux_amd64.tar
</code></pre> 
                    <blockquote> 
                        <p>As for <code>build-app</code> goal, this goal uses <code>jpackage</code> tool so if you intend to use a JDK&lt;16 you'll need to explicitly add the <code>jdk.incubator.jpackage</code> module in <code>MAVEN_OPTS</code>:</p> 
                        <pre><code class="language-plaintext">$ export MAVEN_OPTS="--add-modules jdk.incubator.jpackage"
</code></pre> 
                    </blockquote> 
                    <h4 id="build-and-deploy-a-container-image-to-a-docker-daemon">Build and deploy a container image to a Docker daemon</h4> 
                    <p>The <code>inverno:build-image-docker</code> goal is used to build a container image and deploy it to a Docker daemon using the Docker CLI.</p> 
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;io.inverno.tool&lt;/groupId&gt;
                &lt;artifactId&gt;inverno-maven-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;build-image-docker&lt;/id&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;build-image-docker&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;vm&gt;server&lt;/vm&gt;
                            &lt;addModules&gt;jdk.jdwp.agent,jdk.crypto.ec&lt;/addModules&gt;
                            &lt;vmOptions&gt;-Xms2G -Xmx2G -XX:+UseNUMA -XX:+UseParallelGC&lt;/vmOptions&gt;
                            &lt;repository&gt;example&lt;/repository&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre> 
                    <p>By default the <code>docker</code> command is used but it is possible to specify the path to the Docker CLI in the <code>inverno.container.docker.executable</code> parameter.</p> 
                    <blockquote> 
                        <p>As for <code>build-app</code> goal, this goal uses <code>jpackage</code> tool so if you intend to use a JDK&lt;16 you'll need to explicitly add the <code>jdk.incubator.jpackage</code> module in <code>MAVEN_OPTS</code>:</p> 
                        <pre><code class="language-plaintext">$ export MAVEN_OPTS="--add-modules jdk.incubator.jpackage"
</code></pre> 
                    </blockquote> 
                    <h4 id="build-and-deploy-a-container-image-to-a-remote-repository">Build and deploy a container image to a remote repository</h4> 
                    <p>The <code>inverno:build-image</code> goal builds a container image and deploy it to a remote repository.</p> 
                    <pre><code class="language-xml">&lt;project&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;io.inverno.tool&lt;/groupId&gt;
                &lt;artifactId&gt;inverno-maven-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;build-image-docker&lt;/id&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;build-image-docker&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;vm&gt;server&lt;/vm&gt;
                            &lt;addModules&gt;jdk.jdwp.agent,jdk.crypto.ec&lt;/addModules&gt;
                            &lt;vmOptions&gt;-Xms2G -Xmx2G -XX:+UseNUMA -XX:+UseParallelGC&lt;/vmOptions&gt;
                            &lt;registryUsername&gt;user&lt;/registryUsername&gt;
                            &lt;registryPassword&gt;password&lt;/registryPassword&gt;
                            &lt;registry&gt;gcr.io&lt;/registry&gt;
                            &lt;repository&gt;example&lt;/repository&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre> 
                    <p>By default the registry points to the Docker hub <code>registry-1.docker.io</code> but another registry can be specified, <code>gcr.io</code> in our example.</p> 
                    <blockquote> 
                        <p>As for <code>build-app</code> goal, this goal uses <code>jpackage</code> tool so if you intend to use a JDK&lt;16 you'll need to explicitly add the <code>jdk.incubator.jpackage</code> module in <code>MAVEN_OPTS</code>:</p> 
                        <pre><code class="language-plaintext">$ export MAVEN_OPTS="--add-modules jdk.incubator.jpackage"
</code></pre> 
                    </blockquote> 
                    <h3 id="goals">Goals</h3> 
                    <h4 id="overview-3">Overview</h4> 
                    <ul> 
                        <li><a href="#invernobuild-app">inverno:build-app</a> Builds the project application package.</li> 
                        <li><a href="#invernobuild-image">inverno:build-image</a> Builds a container image and publishes it to a registry.</li> 
                        <li><a href="#invernobuild-image-docker">inverno:build-image-docker</a> Builds a Docker container image to a local Docker daemon.</li> 
                        <li><a href="#invernobuild-image-tar">inverno:build-image-tar</a> Builds a container image to a TAR archive that can be later loaded into Docker:</li> 
                        <li><a href="#invernobuild-runtime">inverno:build-runtime</a> Builds the project runtime image.</li> 
                        <li><a href="#invernohelp">inverno:help</a> Display help information on inverno-maven-plugin.</li> 
                        <li><a href="#invernorun">inverno:run</a> Runs the project application.</li> 
                        <li><a href="#invernostart">inverno:start</a> Starts the project application without blocking the Maven build.</li> 
                        <li><a href="#invernostop">inverno:stop</a> Stops the project application that has been previously started using the start goal.</li> 
                    </ul> 
                    <h4 id="invernobuild-app">inverno:build-app</h4> 
                    <p><strong>Full name:</strong></p> 
                    <p>io.inverno.tool:inverno-maven-plugin:1.1.0:build-app</p> 
                    <p><strong>Description:</strong></p> 
                    <p>Builds the project application package.</p> 
                    <p>A project application package is a native self-contained Java application including all the necessary dependencies. It can be used to distribute a complete application.</p> 
                    <p><strong>Attributes:</strong></p> 
                    <ul> 
                        <li>Requires a Maven project to be executed.</li> 
                        <li>Requires dependency resolution of artifacts in scope: compile+runtime.</li> 
                        <li>Requires dependency collection of artifacts in scope: compile+runtime.</li> 
                        <li>Since version: 1.0.</li> 
                        <li>Binds by default to the lifecycle phase: package.</li> 
                    </ul> 
                    <h5 id="required-parameters">Required parameters</h5> 
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered "> 
                            <tbody>
                                <tr> 
                                    <th>Name</th> 
                                    <th>Type</th> 
                                    <th>Description</th> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#attach">attach</a> </td> 
                                    <td>boolean</td> 
                                    <td> Attach the resulting image archives to the project to install them in the local Maven repository and deploy them to remote repositories. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.attach </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#formats">formats</a> </td> 
                                    <td>Set</td> 
                                    <td> A list of archive formats to generate (eg. zip, tar.gz...) 
                                        <ul> 
                                            <li> <em>Default</em> : zip </li> 
                                        </ul> </td> 
                                </tr> 
                            </tbody>
                        </table>
                    </div> 
                    <h5 id="optional-parameters">Optional parameters</h5> 
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered "> 
                            <tbody>
                                <tr> 
                                    <th>Name</th> 
                                    <th>Type</th> 
                                    <th>Description</th> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#addModules">addModules</a> </td> 
                                    <td>String</td> 
                                    <td> The modules to add to the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.addModules </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#addOptions">addOptions</a> </td> 
                                    <td>String</td> 
                                    <td> The options to prepend before any other options when invoking the JVM in the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.addOptions </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#automaticLaunchers">automaticLaunchers</a> </td> 
                                    <td>boolean</td> 
                                    <td> Enables the automatic generation of launchers based on the main classes extracted from the application module. If enabled, a launcher is generated for all main classes other than the main launcher. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.automaticLaunchers </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#bindServices">bindServices</a> </td> 
                                    <td>boolean</td> 
                                    <td> Link in service provider modules and their dependencies. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.bindServices </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#compress">compress</a> </td> 
                                    <td>String</td> 
                                    <td> The compress level of the resulting image: 0=No compression, 1=constant string sharing, 2=ZIP. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.compress </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#configurationDirectory">configurationDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing user-editable configuration files that will be copied to the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.configurationDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/main/conf/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#copyright">copyright</a> </td> 
                                    <td>String</td> 
                                    <td> The application copyright. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.copyright </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#description">description</a> </td> 
                                    <td>String</td> 
                                    <td> The description of the application. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.description </li> 
                                            <li> <em>Default</em> : ${project.description} </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#excludeArtifactIds">excludeArtifactIds</a> </td> 
                                    <td>String</td> 
                                    <td> Comma separated list of Artifact names to exclude. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.excludeArtifactIds </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#excludeClassifiers">excludeClassifiers</a> </td> 
                                    <td>String</td> 
                                    <td> Comma Separated list of Classifiers to exclude. Empty String indicates don't exclude anything (default). 
                                        <ul> 
                                            <li> <em>User property</em> : excludeClassifiers </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#excludeGroupIds">excludeGroupIds</a> </td> 
                                    <td>String</td> 
                                    <td> Comma separated list of GroupId Names to exclude. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.excludeGroupIds </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#excludeScope">excludeScope</a> </td> 
                                    <td>String</td> 
                                    <td> Scope to exclude. An Empty string indicates no scopes (default). 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.excludeScope </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#ignoreSigningInformation">ignoreSigningInformation</a> </td> 
                                    <td>boolean</td> 
                                    <td> Suppress a fatal error when signed modular JARs are linked in the image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.ignoreSigningInformation </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#includeArtifactIds">includeArtifactIds</a> </td> 
                                    <td>String</td> 
                                    <td> Comma separated list of Artifact names to include. Empty String indicates include everything (default). 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.includeArtifactIds </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#includeClassifiers">includeClassifiers</a> </td> 
                                    <td>String</td> 
                                    <td> Comma Separated list of Classifiers to include. Empty String indicates include everything (default). 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.includeClassifiers </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#includeGroupIds">includeGroupIds</a> </td> 
                                    <td>String</td> 
                                    <td> Comma separated list of GroupIds to include. Empty String indicates include everything (default). 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.includeGroupIds </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#includeScope">includeScope</a> </td> 
                                    <td>String</td> 
                                    <td> Scope to include. An Empty string indicates all scopes (default). The scopes being interpreted are the scopes as Maven sees them, not as specified in the pom. In summary: 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.includeScope </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#installDirectory">installDirectory</a> </td> 
                                    <td>String</td> 
                                    <td> Absolute path of the installation directory of the application on OS X or Linux. Relative sub-path of the installation location of the application such as 'Program Files' or 'AppData' on Windows. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.installDirectory </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#jmodsOverrideDirectory">jmodsOverrideDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.jmodsOverrideDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/jmods/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#launchers">launchers</a> </td> 
                                    <td>List</td> 
                                    <td> A list of extra launchers to include in the resulting application. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#legalDirectory">legalDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing legal notices that will be copied to the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.legalDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/main/legal/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#licenseFile">licenseFile</a> </td> 
                                    <td>File</td> 
                                    <td> The path to the application license file. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.licenseFile </li> 
                                            <li> <em>Default</em> : ${project.basedir}/LICENSE </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#linuxConfiguration">linuxConfiguration</a> </td> 
                                    <td>LinuxConfiguration</td> 
                                    <td> Linux specific configuration. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#macOSConfiguration">macOSConfiguration</a> </td> 
                                    <td>MacOSConfiguration</td> 
                                    <td> MacOS specific configuration. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#manDirectory">manDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing man pages that will be copied to the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.manDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/main/man/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#overWriteIfNewer">overWriteIfNewer</a> </td> 
                                    <td>boolean</td> 
                                    <td> Overwrite dependencies that don't exist or are older than the source. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.overWriteIfNewer </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#projectMainClass">projectMainClass</a> </td> 
                                    <td>String</td> 
                                    <td> The main class in the project module to use when building the project JMOD package. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.runtime.projectMainClass </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#resolveProjectMainClass">resolveProjectMainClass</a> </td> 
                                    <td>boolean</td> 
                                    <td> Resolve the project main class when not specified explicitly. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.runtime.projectMainClass </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#resourceDirectory">resourceDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> The path to resources that override resulting package resources. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.resourceDirectory </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#skip">skip</a> </td> 
                                    <td>boolean</td> 
                                    <td> Skips the generation of the application. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.skip </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#stripDebug">stripDebug</a> </td> 
                                    <td>boolean</td> 
                                    <td> Strip debug information from the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.stripDebug </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#stripNativeCommands">stripNativeCommands</a> </td> 
                                    <td>boolean</td> 
                                    <td> Strip native command (eg. java...) from the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.stripNativeCommands </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#vendor">vendor</a> </td> 
                                    <td>String</td> 
                                    <td> The application vendor. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.vendor </li> 
                                            <li> <em>Default</em> : ${project.organization.name} </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#verbose">verbose</a> </td> 
                                    <td>boolean</td> 
                                    <td> Enables verbose logging. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.verbose </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#vm">vm</a> </td> 
                                    <td>String</td> 
                                    <td> Select the HotSpot VM in the output image defined as: 'client' / 'server' / 'minimal' / 'all' 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.vm </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#windowsConfiguration">windowsConfiguration</a> </td> 
                                    <td>WindowsConfiguration</td> 
                                    <td> Windows specific configuration. 
                                        <ul></ul> </td> 
                                </tr> 
                            </tbody>
                        </table>
                    </div> 
                    <h5 id="parameter-details">Parameter details</h5> 
                    <h6 id="addmodules">&lt;addModules&gt;</h6> 
                    <p>The modules to add to the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.addModules</li> 
                    </ul> 
                    <h6 id="addoptions">&lt;addOptions&gt;</h6> 
                    <p>The options to prepend before any other options when invoking the JVM in the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.addOptions</li> 
                    </ul> 
                    <h6 id="attach">&lt;attach&gt;</h6> 
                    <p>Attach the resulting image archives to the project to install them in the local Maven repository and deploy them to remote repositories.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: yes</li> 
                        <li><strong>User property</strong>: inverno.image.attach</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="automaticlaunchers">&lt;automaticLaunchers&gt;</h6> 
                    <p>Enables the automatic generation of launchers based on the main classes extracted from the application module. If enabled, a launcher is generated for all main classes other than the main launcher.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.automaticLaunchers</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="bindservices">&lt;bindServices&gt;</h6> 
                    <p>Link in service provider modules and their dependencies.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.bindServices</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="compress">&lt;compress&gt;</h6> 
                    <p>The compress level of the resulting image: 0=No compression, 1=constant string sharing, 2=ZIP.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.compress</li> 
                    </ul> 
                    <h6 id="configurationdirectory">&lt;configurationDirectory&gt;</h6> 
                    <p>A directory containing user-editable configuration files that will be copied to the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.configurationDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/main/conf/</li> 
                    </ul> 
                    <h6 id="copyright">&lt;copyright&gt;</h6> 
                    <p>The application copyright.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.copyright</li> 
                    </ul> 
                    <h6 id="description">&lt;description&gt;</h6> 
                    <p>The description of the application.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.description</li> 
                        <li><strong>Default</strong>: ${project.description}</li> 
                    </ul> 
                    <h6 id="excludeartifactids">&lt;excludeArtifactIds&gt;</h6> 
                    <p>Comma separated list of Artifact names to exclude.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.excludeArtifactIds</li> 
                    </ul> 
                    <h6 id="excludeclassifiers">&lt;excludeClassifiers&gt;</h6> 
                    <p>Comma Separated list of Classifiers to exclude. Empty String indicates don't exclude anything (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: excludeClassifiers</li> 
                    </ul> 
                    <h6 id="excludegroupids">&lt;excludeGroupIds&gt;</h6> 
                    <p>Comma separated list of GroupId Names to exclude.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.excludeGroupIds</li> 
                    </ul> 
                    <h6 id="excludescope">&lt;excludeScope&gt;</h6> 
                    <p>Scope to exclude. An Empty string indicates no scopes (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.excludeScope</li> 
                    </ul> 
                    <h6 id="formats">&lt;formats&gt;</h6> 
                    <p>A list of archive formats to generate (eg. zip, tar.gz...)</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.util.Set</li> 
                        <li><strong>Required</strong>: yes</li> 
                        <li><strong>Default</strong>: zip</li> 
                    </ul> 
                    <h6 id="ignoresigninginformation">&lt;ignoreSigningInformation&gt;</h6> 
                    <p>Suppress a fatal error when signed modular JARs are linked in the image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.ignoreSigningInformation</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="includeartifactids">&lt;includeArtifactIds&gt;</h6> 
                    <p>Comma separated list of Artifact names to include. Empty String indicates include everything (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.includeArtifactIds</li> 
                    </ul> 
                    <h6 id="includeclassifiers">&lt;includeClassifiers&gt;</h6> 
                    <p>Comma Separated list of Classifiers to include. Empty String indicates include everything (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.includeClassifiers</li> 
                    </ul> 
                    <h6 id="includegroupids">&lt;includeGroupIds&gt;</h6> 
                    <p>Comma separated list of GroupIds to include. Empty String indicates include everything (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.includeGroupIds</li> 
                    </ul> 
                    <h6 id="includescope">&lt;includeScope&gt;</h6> 
                    <p>Scope to include. An Empty string indicates all scopes (default). The scopes being interpreted are the scopes as Maven sees them, not as specified in the pom. In summary:</p> 
                    <ul> 
                        <li> <p>runtime scope gives runtime and compile dependencies,</p> </li> 
                        <li> <p>compile scope gives compile, provided, and system dependencies,</p> </li> 
                        <li> <p>test (default) scope gives all dependencies,</p> </li> 
                        <li> <p>provided scope just gives provided dependencies,</p> </li> 
                        <li> <p>system scope just gives system dependencies.</p> </li> 
                        <li> <p><strong>Type</strong>: java.lang.String</p> </li> 
                        <li> <p><strong>Required</strong>: no</p> </li> 
                        <li> <p><strong>User property</strong>: inverno.image.includeScope</p> </li> 
                    </ul> 
                    <h6 id="installdirectory">&lt;installDirectory&gt;</h6> 
                    <p>Absolute path of the installation directory of the application on OS X or Linux. Relative sub-path of the installation location of the application such as 'Program Files' or 'AppData' on Windows.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.installDirectory</li> 
                    </ul> 
                    <h6 id="jmodsoverridedirectory">&lt;jmodsOverrideDirectory&gt;</h6> 
                    <p>A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.jmodsOverrideDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/jmods/</li> 
                    </ul> 
                    <h6 id="launchers">&lt;launchers&gt;</h6> 
                    <p>A list of extra launchers to include in the resulting application.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.util.List</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="legaldirectory">&lt;legalDirectory&gt;</h6> 
                    <p>A directory containing legal notices that will be copied to the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.legalDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/main/legal/</li> 
                    </ul> 
                    <h6 id="licensefile">&lt;licenseFile&gt;</h6> 
                    <p>The path to the application license file.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.licenseFile</li> 
                        <li><strong>Default</strong>: ${project.basedir}/LICENSE</li> 
                    </ul> 
                    <h6 id="linuxconfiguration">&lt;linuxConfiguration&gt;</h6> 
                    <p>Linux specific configuration.</p> 
                    <ul> 
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$LinuxConfiguration</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="macosconfiguration">&lt;macOSConfiguration&gt;</h6> 
                    <p>MacOS specific configuration.</p> 
                    <ul> 
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$MacOSConfiguration</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="mandirectory">&lt;manDirectory&gt;</h6> 
                    <p>A directory containing man pages that will be copied to the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.manDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/main/man/</li> 
                    </ul> 
                    <h6 id="overwriteifnewer">&lt;overWriteIfNewer&gt;</h6> 
                    <p>Overwrite dependencies that don't exist or are older than the source.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.overWriteIfNewer</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="projectmainclass">&lt;projectMainClass&gt;</h6> 
                    <p>The main class in the project module to use when building the project JMOD package.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.runtime.projectMainClass</li> 
                    </ul> 
                    <h6 id="resolveprojectmainclass">&lt;resolveProjectMainClass&gt;</h6> 
                    <p>Resolve the project main class when not specified explicitly.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.runtime.projectMainClass</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="resourcedirectory">&lt;resourceDirectory&gt;</h6> 
                    <p>The path to resources that override resulting package resources.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.resourceDirectory</li> 
                    </ul> 
                    <h6 id="skip">&lt;skip&gt;</h6> 
                    <p>Skips the generation of the application.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.skip</li> 
                    </ul> 
                    <h6 id="stripdebug">&lt;stripDebug&gt;</h6> 
                    <p>Strip debug information from the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.stripDebug</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="stripnativecommands">&lt;stripNativeCommands&gt;</h6> 
                    <p>Strip native command (eg. java...) from the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.stripNativeCommands</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="vendor">&lt;vendor&gt;</h6> 
                    <p>The application vendor.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.vendor</li> 
                        <li><strong>Default</strong>: ${project.organization.name}</li> 
                    </ul> 
                    <h6 id="verbose">&lt;verbose&gt;</h6> 
                    <p>Enables verbose logging.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.verbose</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="vm">&lt;vm&gt;</h6> 
                    <p>Select the HotSpot VM in the output image defined as: 'client' / 'server' / 'minimal' / 'all'</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.vm</li> 
                    </ul> 
                    <h6 id="windowsconfiguration">&lt;windowsConfiguration&gt;</h6> 
                    <p>Windows specific configuration.</p> 
                    <ul> 
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$WindowsConfiguration</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h4 id="invernobuild-image">inverno:build-image</h4> 
                    <p><strong>Full name:</strong></p> 
                    <p>io.inverno.tool:inverno-maven-plugin:1.1.0:build-image</p> 
                    <p><strong>Description:</strong></p> 
                    <p>Builds a container image and publishes it to a registry.</p> 
                    <p><strong>Attributes:</strong></p> 
                    <ul> 
                        <li>Requires a Maven project to be executed.</li> 
                        <li>Requires dependency resolution of artifacts in scope: compile+runtime.</li> 
                        <li>Requires dependency collection of artifacts in scope: compile+runtime.</li> 
                        <li>Since version: 1.0.</li> 
                        <li>Binds by default to the lifecycle phase: install.</li> 
                    </ul> 
                    <h5 id="required-parameters-1">Required parameters</h5> 
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered "> 
                            <tbody>
                                <tr> 
                                    <th>Name</th> 
                                    <th>Type</th> 
                                    <th>Description</th> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#attach1">attach</a> </td> 
                                    <td>boolean</td> 
                                    <td> Attach the resulting image archives to the project to install them in the local Maven repository and deploy them to remote repositories. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.attach </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#executable">executable</a> </td> 
                                    <td>String</td> 
                                    <td> The executable in the application image to use as image entry point. The specified name should correspond to a declared application image launchers or the project artifact id if no launcher was specified. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.executable </li> 
                                            <li> <em>Default</em> : ${project.artifactId} </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#formats1">formats</a> </td> 
                                    <td>Set</td> 
                                    <td> A list of archive formats to generate (eg. zip, tar.gz...) 
                                        <ul> 
                                            <li> <em>Default</em> : zip </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#from">from</a> </td> 
                                    <td>String</td> 
                                    <td> The base container image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.container.from </li> 
                                            <li> <em>Default</em> : debian:buster-slim </li> 
                                        </ul> </td> 
                                </tr> 
                            </tbody>
                        </table>
                    </div> 
                    <h5 id="optional-parameters-1">Optional parameters</h5> 
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered "> 
                            <tbody>
                                <tr> 
                                    <th>Name</th> 
                                    <th>Type</th> 
                                    <th>Description</th> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#addModules1">addModules</a> </td> 
                                    <td>String</td> 
                                    <td> The modules to add to the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.addModules </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#addOptions1">addOptions</a> </td> 
                                    <td>String</td> 
                                    <td> The options to prepend before any other options when invoking the JVM in the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.addOptions </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#automaticLaunchers1">automaticLaunchers</a> </td> 
                                    <td>boolean</td> 
                                    <td> Enables the automatic generation of launchers based on the main classes extracted from the application module. If enabled, a launcher is generated for all main classes other than the main launcher. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.automaticLaunchers </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#bindServices1">bindServices</a> </td> 
                                    <td>boolean</td> 
                                    <td> Link in service provider modules and their dependencies. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.bindServices </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#compress1">compress</a> </td> 
                                    <td>String</td> 
                                    <td> The compress level of the resulting image: 0=No compression, 1=constant string sharing, 2=ZIP. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.compress </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#configurationDirectory1">configurationDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing user-editable configuration files that will be copied to the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.configurationDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/main/conf/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#copyright1">copyright</a> </td> 
                                    <td>String</td> 
                                    <td> The application copyright. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.copyright </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#description1">description</a> </td> 
                                    <td>String</td> 
                                    <td> The description of the application. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.description </li> 
                                            <li> <em>Default</em> : ${project.description} </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#environment">environment</a> </td> 
                                    <td>Map</td> 
                                    <td> The container's environment variables. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#excludeArtifactIds1">excludeArtifactIds</a> </td> 
                                    <td>String</td> 
                                    <td> Comma separated list of Artifact names to exclude. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.excludeArtifactIds </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#excludeClassifiers1">excludeClassifiers</a> </td> 
                                    <td>String</td> 
                                    <td> Comma Separated list of Classifiers to exclude. Empty String indicates don't exclude anything (default). 
                                        <ul> 
                                            <li> <em>User property</em> : excludeClassifiers </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#excludeGroupIds1">excludeGroupIds</a> </td> 
                                    <td>String</td> 
                                    <td> Comma separated list of GroupId Names to exclude. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.excludeGroupIds </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#excludeScope1">excludeScope</a> </td> 
                                    <td>String</td> 
                                    <td> Scope to exclude. An Empty string indicates no scopes (default). 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.excludeScope </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#ignoreSigningInformation1">ignoreSigningInformation</a> </td> 
                                    <td>boolean</td> 
                                    <td> Suppress a fatal error when signed modular JARs are linked in the image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.ignoreSigningInformation </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#imageFormat">imageFormat</a> </td> 
                                    <td>ImageFormat</td> 
                                    <td> The format of the container image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.container.imageFormat </li> 
                                            <li> <em>Default</em> : Docker </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#includeArtifactIds1">includeArtifactIds</a> </td> 
                                    <td>String</td> 
                                    <td> Comma separated list of Artifact names to include. Empty String indicates include everything (default). 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.includeArtifactIds </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#includeClassifiers1">includeClassifiers</a> </td> 
                                    <td>String</td> 
                                    <td> Comma Separated list of Classifiers to include. Empty String indicates include everything (default). 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.includeClassifiers </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#includeGroupIds1">includeGroupIds</a> </td> 
                                    <td>String</td> 
                                    <td> Comma separated list of GroupIds to include. Empty String indicates include everything (default). 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.includeGroupIds </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#includeScope1">includeScope</a> </td> 
                                    <td>String</td> 
                                    <td> Scope to include. An Empty string indicates all scopes (default). The scopes being interpreted are the scopes as Maven sees them, not as specified in the pom. In summary: 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.includeScope </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#installDirectory1">installDirectory</a> </td> 
                                    <td>String</td> 
                                    <td> Absolute path of the installation directory of the application on OS X or Linux. Relative sub-path of the installation location of the application such as 'Program Files' or 'AppData' on Windows. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.installDirectory </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#jmodsOverrideDirectory1">jmodsOverrideDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.jmodsOverrideDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/jmods/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#labels">labels</a> </td> 
                                    <td>Map</td> 
                                    <td> The labels to apply to the container image. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#launchers1">launchers</a> </td> 
                                    <td>List</td> 
                                    <td> A list of extra launchers to include in the resulting application. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#legalDirectory1">legalDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing legal notices that will be copied to the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.legalDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/main/legal/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#licenseFile1">licenseFile</a> </td> 
                                    <td>File</td> 
                                    <td> The path to the application license file. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.licenseFile </li> 
                                            <li> <em>Default</em> : ${project.basedir}/LICENSE </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#linuxConfiguration1">linuxConfiguration</a> </td> 
                                    <td>LinuxConfiguration</td> 
                                    <td> Linux specific configuration. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#macOSConfiguration1">macOSConfiguration</a> </td> 
                                    <td>MacOSConfiguration</td> 
                                    <td> MacOS specific configuration. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#manDirectory1">manDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing man pages that will be copied to the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.manDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/main/man/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#overWriteIfNewer1">overWriteIfNewer</a> </td> 
                                    <td>boolean</td> 
                                    <td> Overwrite dependencies that don't exist or are older than the source. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.overWriteIfNewer </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#ports">ports</a> </td> 
                                    <td>Set</td> 
                                    <td> The ports exposed by the container at runtime defined as: port_number [ '/' udp/tcp ] 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#projectMainClass1">projectMainClass</a> </td> 
                                    <td>String</td> 
                                    <td> The main class in the project module to use when building the project JMOD package. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.runtime.projectMainClass </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#registry">registry</a> </td> 
                                    <td>String</td> 
                                    <td> The registry part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version} 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.container.registry </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#registryPassword">registryPassword</a> </td> 
                                    <td>String</td> 
                                    <td> The password to use to authenticate to the registry. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.container.registry.password </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#registryUsername">registryUsername</a> </td> 
                                    <td>String</td> 
                                    <td> The user name to use to authenticate to the registry. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.container.registry.username </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#repository">repository</a> </td> 
                                    <td>String</td> 
                                    <td> The repository part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version} 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.container.repository </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#resolveProjectMainClass1">resolveProjectMainClass</a> </td> 
                                    <td>boolean</td> 
                                    <td> Resolve the project main class when not specified explicitly. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.runtime.projectMainClass </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#resourceDirectory1">resourceDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> The path to resources that override resulting package resources. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.resourceDirectory </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#skip1">skip</a> </td> 
                                    <td>boolean</td> 
                                    <td> Skips the generation of the application. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.skip </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#stripDebug1">stripDebug</a> </td> 
                                    <td>boolean</td> 
                                    <td> Strip debug information from the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.stripDebug </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#stripNativeCommands1">stripNativeCommands</a> </td> 
                                    <td>boolean</td> 
                                    <td> Strip native command (eg. java...) from the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.stripNativeCommands </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#user">user</a> </td> 
                                    <td>String</td> 
                                    <td> The user and group used to run the container defined as: user / uid [ ':' group / gid ] 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#vendor1">vendor</a> </td> 
                                    <td>String</td> 
                                    <td> The application vendor. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.vendor </li> 
                                            <li> <em>Default</em> : ${project.organization.name} </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#verbose1">verbose</a> </td> 
                                    <td>boolean</td> 
                                    <td> Enables verbose logging. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.verbose </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#vm1">vm</a> </td> 
                                    <td>String</td> 
                                    <td> Select the HotSpot VM in the output image defined as: 'client' / 'server' / 'minimal' / 'all' 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.vm </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#volumes">volumes</a> </td> 
                                    <td>Set</td> 
                                    <td> The container's mount points. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#windowsConfiguration1">windowsConfiguration</a> </td> 
                                    <td>WindowsConfiguration</td> 
                                    <td> Windows specific configuration. 
                                        <ul></ul> </td> 
                                </tr> 
                            </tbody>
                        </table>
                    </div> 
                    <h5 id="parameter-details-1">Parameter details</h5> 
                    <h6 id="addmodules-1">&lt;addModules&gt;</h6> 
                    <p>The modules to add to the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.addModules</li> 
                    </ul> 
                    <h6 id="addoptions-1">&lt;addOptions&gt;</h6> 
                    <p>The options to prepend before any other options when invoking the JVM in the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.addOptions</li> 
                    </ul> 
                    <h6 id="attach-1">&lt;attach&gt;</h6> 
                    <p>Attach the resulting image archives to the project to install them in the local Maven repository and deploy them to remote repositories.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: yes</li> 
                        <li><strong>User property</strong>: inverno.image.attach</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="automaticlaunchers-1">&lt;automaticLaunchers&gt;</h6> 
                    <p>Enables the automatic generation of launchers based on the main classes extracted from the application module. If enabled, a launcher is generated for all main classes other than the main launcher.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.automaticLaunchers</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="bindservices-1">&lt;bindServices&gt;</h6> 
                    <p>Link in service provider modules and their dependencies.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.bindServices</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="compress-1">&lt;compress&gt;</h6> 
                    <p>The compress level of the resulting image: 0=No compression, 1=constant string sharing, 2=ZIP.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.compress</li> 
                    </ul> 
                    <h6 id="configurationdirectory-1">&lt;configurationDirectory&gt;</h6> 
                    <p>A directory containing user-editable configuration files that will be copied to the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.configurationDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/main/conf/</li> 
                    </ul> 
                    <h6 id="copyright-1">&lt;copyright&gt;</h6> 
                    <p>The application copyright.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.copyright</li> 
                    </ul> 
                    <h6 id="description-1">&lt;description&gt;</h6> 
                    <p>The description of the application.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.description</li> 
                        <li><strong>Default</strong>: ${project.description}</li> 
                    </ul> 
                    <h6 id="environment">&lt;environment&gt;</h6> 
                    <p>The container's environment variables.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.util.Map</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="excludeartifactids-1">&lt;excludeArtifactIds&gt;</h6> 
                    <p>Comma separated list of Artifact names to exclude.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.excludeArtifactIds</li> 
                    </ul> 
                    <h6 id="excludeclassifiers-1">&lt;excludeClassifiers&gt;</h6> 
                    <p>Comma Separated list of Classifiers to exclude. Empty String indicates don't exclude anything (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: excludeClassifiers</li> 
                    </ul> 
                    <h6 id="excludegroupids-1">&lt;excludeGroupIds&gt;</h6> 
                    <p>Comma separated list of GroupId Names to exclude.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.excludeGroupIds</li> 
                    </ul> 
                    <h6 id="excludescope-1">&lt;excludeScope&gt;</h6> 
                    <p>Scope to exclude. An Empty string indicates no scopes (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.excludeScope</li> 
                    </ul> 
                    <h6 id="executable">&lt;executable&gt;</h6> 
                    <p>The executable in the application image to use as image entry point. The specified name should correspond to a declared application image launchers or the project artifact id if no launcher was specified.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: yes</li> 
                        <li><strong>User property</strong>: inverno.app.executable</li> 
                        <li><strong>Default</strong>: ${project.artifactId}</li> 
                    </ul> 
                    <h6 id="formats-1">&lt;formats&gt;</h6> 
                    <p>A list of archive formats to generate (eg. zip, tar.gz...)</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.util.Set</li> 
                        <li><strong>Required</strong>: yes</li> 
                        <li><strong>Default</strong>: zip</li> 
                    </ul> 
                    <h6 id="from">&lt;from&gt;</h6> 
                    <p>The base container image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: yes</li> 
                        <li><strong>User property</strong>: inverno.container.from</li> 
                        <li><strong>Default</strong>: debian:buster-slim</li> 
                    </ul> 
                    <h6 id="ignoresigninginformation-1">&lt;ignoreSigningInformation&gt;</h6> 
                    <p>Suppress a fatal error when signed modular JARs are linked in the image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.ignoreSigningInformation</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="imageformat">&lt;imageFormat&gt;</h6> 
                    <p>The format of the container image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: com.google.cloud.tools.jib.api.buildplan.ImageFormat</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.container.imageFormat</li> 
                        <li><strong>Default</strong>: Docker</li> 
                    </ul> 
                    <h6 id="includeartifactids-1">&lt;includeArtifactIds&gt;</h6> 
                    <p>Comma separated list of Artifact names to include. Empty String indicates include everything (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.includeArtifactIds</li> 
                    </ul> 
                    <h6 id="includeclassifiers-1">&lt;includeClassifiers&gt;</h6> 
                    <p>Comma Separated list of Classifiers to include. Empty String indicates include everything (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.includeClassifiers</li> 
                    </ul> 
                    <h6 id="includegroupids-1">&lt;includeGroupIds&gt;</h6> 
                    <p>Comma separated list of GroupIds to include. Empty String indicates include everything (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.includeGroupIds</li> 
                    </ul> 
                    <h6 id="includescope-1">&lt;includeScope&gt;</h6> 
                    <p>Scope to include. An Empty string indicates all scopes (default). The scopes being interpreted are the scopes as Maven sees them, not as specified in the pom. In summary:</p> 
                    <ul> 
                        <li> <p>runtime scope gives runtime and compile dependencies,</p> </li> 
                        <li> <p>compile scope gives compile, provided, and system dependencies,</p> </li> 
                        <li> <p>test (default) scope gives all dependencies,</p> </li> 
                        <li> <p>provided scope just gives provided dependencies,</p> </li> 
                        <li> <p>system scope just gives system dependencies.</p> </li> 
                        <li> <p><strong>Type</strong>: java.lang.String</p> </li> 
                        <li> <p><strong>Required</strong>: no</p> </li> 
                        <li> <p><strong>User property</strong>: inverno.image.includeScope</p> </li> 
                    </ul> 
                    <h6 id="installdirectory-1">&lt;installDirectory&gt;</h6> 
                    <p>Absolute path of the installation directory of the application on OS X or Linux. Relative sub-path of the installation location of the application such as 'Program Files' or 'AppData' on Windows.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.installDirectory</li> 
                    </ul> 
                    <h6 id="jmodsoverridedirectory-1">&lt;jmodsOverrideDirectory&gt;</h6> 
                    <p>A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.jmodsOverrideDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/jmods/</li> 
                    </ul> 
                    <h6 id="labels">&lt;labels&gt;</h6> 
                    <p>The labels to apply to the container image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.util.Map</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="launchers-1">&lt;launchers&gt;</h6> 
                    <p>A list of extra launchers to include in the resulting application.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.util.List</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="legaldirectory-1">&lt;legalDirectory&gt;</h6> 
                    <p>A directory containing legal notices that will be copied to the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.legalDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/main/legal/</li> 
                    </ul> 
                    <h6 id="licensefile-1">&lt;licenseFile&gt;</h6> 
                    <p>The path to the application license file.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.licenseFile</li> 
                        <li><strong>Default</strong>: ${project.basedir}/LICENSE</li> 
                    </ul> 
                    <h6 id="linuxconfiguration-1">&lt;linuxConfiguration&gt;</h6> 
                    <p>Linux specific configuration.</p> 
                    <ul> 
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$LinuxConfiguration</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="macosconfiguration-1">&lt;macOSConfiguration&gt;</h6> 
                    <p>MacOS specific configuration.</p> 
                    <ul> 
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$MacOSConfiguration</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="mandirectory-1">&lt;manDirectory&gt;</h6> 
                    <p>A directory containing man pages that will be copied to the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.manDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/main/man/</li> 
                    </ul> 
                    <h6 id="overwriteifnewer-1">&lt;overWriteIfNewer&gt;</h6> 
                    <p>Overwrite dependencies that don't exist or are older than the source.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.overWriteIfNewer</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="ports">&lt;ports&gt;</h6> 
                    <p>The ports exposed by the container at runtime defined as: port_number [ '/' udp/tcp ]</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.util.Set</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="projectmainclass-1">&lt;projectMainClass&gt;</h6> 
                    <p>The main class in the project module to use when building the project JMOD package.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.runtime.projectMainClass</li> 
                    </ul> 
                    <h6 id="registry">&lt;registry&gt;</h6> 
                    <p>The registry part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version}</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.container.registry</li> 
                    </ul> 
                    <h6 id="registrypassword">&lt;registryPassword&gt;</h6> 
                    <p>The password to use to authenticate to the registry.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.container.registry.password</li> 
                    </ul> 
                    <h6 id="registryusername">&lt;registryUsername&gt;</h6> 
                    <p>The user name to use to authenticate to the registry.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.container.registry.username</li> 
                    </ul> 
                    <h6 id="repository">&lt;repository&gt;</h6> 
                    <p>The repository part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version}</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.container.repository</li> 
                    </ul> 
                    <h6 id="resolveprojectmainclass-1">&lt;resolveProjectMainClass&gt;</h6> 
                    <p>Resolve the project main class when not specified explicitly.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.runtime.projectMainClass</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="resourcedirectory-1">&lt;resourceDirectory&gt;</h6> 
                    <p>The path to resources that override resulting package resources.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.resourceDirectory</li> 
                    </ul> 
                    <h6 id="skip-1">&lt;skip&gt;</h6> 
                    <p>Skips the generation of the application.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.skip</li> 
                    </ul> 
                    <h6 id="stripdebug-1">&lt;stripDebug&gt;</h6> 
                    <p>Strip debug information from the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.stripDebug</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="stripnativecommands-1">&lt;stripNativeCommands&gt;</h6> 
                    <p>Strip native command (eg. java...) from the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.stripNativeCommands</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="user">&lt;user&gt;</h6> 
                    <p>The user and group used to run the container defined as: user / uid [ ':' group / gid ]</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="vendor-1">&lt;vendor&gt;</h6> 
                    <p>The application vendor.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.vendor</li> 
                        <li><strong>Default</strong>: ${project.organization.name}</li> 
                    </ul> 
                    <h6 id="verbose-1">&lt;verbose&gt;</h6> 
                    <p>Enables verbose logging.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.verbose</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="vm-1">&lt;vm&gt;</h6> 
                    <p>Select the HotSpot VM in the output image defined as: 'client' / 'server' / 'minimal' / 'all'</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.vm</li> 
                    </ul> 
                    <h6 id="volumes">&lt;volumes&gt;</h6> 
                    <p>The container's mount points.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.util.Set</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="windowsconfiguration-1">&lt;windowsConfiguration&gt;</h6> 
                    <p>Windows specific configuration.</p> 
                    <ul> 
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$WindowsConfiguration</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h4 id="invernobuild-image-docker">inverno:build-image-docker</h4> 
                    <p><strong>Full name:</strong></p> 
                    <p>io.inverno.tool:inverno-maven-plugin:1.1.0:build-image-docker</p> 
                    <p><strong>Description:</strong></p> 
                    <p>Builds a Docker container image to a local Docker daemon.</p> 
                    <p><strong>Attributes:</strong></p> 
                    <ul> 
                        <li>Requires a Maven project to be executed.</li> 
                        <li>Requires dependency resolution of artifacts in scope: compile+runtime.</li> 
                        <li>Requires dependency collection of artifacts in scope: compile+runtime.</li> 
                        <li>Since version: 1.0.</li> 
                        <li>Binds by default to the lifecycle phase: install.</li> 
                    </ul> 
                    <h5 id="required-parameters-2">Required parameters</h5> 
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered "> 
                            <tbody>
                                <tr> 
                                    <th>Name</th> 
                                    <th>Type</th> 
                                    <th>Description</th> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#attach2">attach</a> </td> 
                                    <td>boolean</td> 
                                    <td> Attach the resulting image archives to the project to install them in the local Maven repository and deploy them to remote repositories. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.attach </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#executable1">executable</a> </td> 
                                    <td>String</td> 
                                    <td> The executable in the application image to use as image entry point. The specified name should correspond to a declared application image launchers or the project artifact id if no launcher was specified. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.executable </li> 
                                            <li> <em>Default</em> : ${project.artifactId} </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#formats2">formats</a> </td> 
                                    <td>Set</td> 
                                    <td> A list of archive formats to generate (eg. zip, tar.gz...) 
                                        <ul> 
                                            <li> <em>Default</em> : zip </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#from1">from</a> </td> 
                                    <td>String</td> 
                                    <td> The base container image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.container.from </li> 
                                            <li> <em>Default</em> : debian:buster-slim </li> 
                                        </ul> </td> 
                                </tr> 
                            </tbody>
                        </table>
                    </div> 
                    <h5 id="optional-parameters-2">Optional parameters</h5> 
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered "> 
                            <tbody>
                                <tr> 
                                    <th>Name</th> 
                                    <th>Type</th> 
                                    <th>Description</th> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#addModules2">addModules</a> </td> 
                                    <td>String</td> 
                                    <td> The modules to add to the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.addModules </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#addOptions2">addOptions</a> </td> 
                                    <td>String</td> 
                                    <td> The options to prepend before any other options when invoking the JVM in the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.addOptions </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#automaticLaunchers2">automaticLaunchers</a> </td> 
                                    <td>boolean</td> 
                                    <td> Enables the automatic generation of launchers based on the main classes extracted from the application module. If enabled, a launcher is generated for all main classes other than the main launcher. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.automaticLaunchers </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#bindServices2">bindServices</a> </td> 
                                    <td>boolean</td> 
                                    <td> Link in service provider modules and their dependencies. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.bindServices </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#compress2">compress</a> </td> 
                                    <td>String</td> 
                                    <td> The compress level of the resulting image: 0=No compression, 1=constant string sharing, 2=ZIP. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.compress </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#configurationDirectory2">configurationDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing user-editable configuration files that will be copied to the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.configurationDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/main/conf/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#copyright2">copyright</a> </td> 
                                    <td>String</td> 
                                    <td> The application copyright. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.copyright </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#description2">description</a> </td> 
                                    <td>String</td> 
                                    <td> The description of the application. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.description </li> 
                                            <li> <em>Default</em> : ${project.description} </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#dockerEnvironment">dockerEnvironment</a> </td> 
                                    <td>Map</td> 
                                    <td> The Docker environment variables used by the Docker CLI executable. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#dockerExecutable">dockerExecutable</a> </td> 
                                    <td>File</td> 
                                    <td> The path to the Docker CLI executable used to load the image in the Docker daemon. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.container.docker.executable </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#environment1">environment</a> </td> 
                                    <td>Map</td> 
                                    <td> The container's environment variables. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#excludeArtifactIds2">excludeArtifactIds</a> </td> 
                                    <td>String</td> 
                                    <td> Comma separated list of Artifact names to exclude. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.excludeArtifactIds </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#excludeClassifiers2">excludeClassifiers</a> </td> 
                                    <td>String</td> 
                                    <td> Comma Separated list of Classifiers to exclude. Empty String indicates don't exclude anything (default). 
                                        <ul> 
                                            <li> <em>User property</em> : excludeClassifiers </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#excludeGroupIds2">excludeGroupIds</a> </td> 
                                    <td>String</td> 
                                    <td> Comma separated list of GroupId Names to exclude. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.excludeGroupIds </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#excludeScope2">excludeScope</a> </td> 
                                    <td>String</td> 
                                    <td> Scope to exclude. An Empty string indicates no scopes (default). 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.excludeScope </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#ignoreSigningInformation2">ignoreSigningInformation</a> </td> 
                                    <td>boolean</td> 
                                    <td> Suppress a fatal error when signed modular JARs are linked in the image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.ignoreSigningInformation </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#imageFormat1">imageFormat</a> </td> 
                                    <td>ImageFormat</td> 
                                    <td> The format of the container image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.container.imageFormat </li> 
                                            <li> <em>Default</em> : Docker </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#includeArtifactIds2">includeArtifactIds</a> </td> 
                                    <td>String</td> 
                                    <td> Comma separated list of Artifact names to include. Empty String indicates include everything (default). 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.includeArtifactIds </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#includeClassifiers2">includeClassifiers</a> </td> 
                                    <td>String</td> 
                                    <td> Comma Separated list of Classifiers to include. Empty String indicates include everything (default). 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.includeClassifiers </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#includeGroupIds2">includeGroupIds</a> </td> 
                                    <td>String</td> 
                                    <td> Comma separated list of GroupIds to include. Empty String indicates include everything (default). 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.includeGroupIds </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#includeScope2">includeScope</a> </td> 
                                    <td>String</td> 
                                    <td> Scope to include. An Empty string indicates all scopes (default). The scopes being interpreted are the scopes as Maven sees them, not as specified in the pom. In summary: 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.includeScope </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#installDirectory2">installDirectory</a> </td> 
                                    <td>String</td> 
                                    <td> Absolute path of the installation directory of the application on OS X or Linux. Relative sub-path of the installation location of the application such as 'Program Files' or 'AppData' on Windows. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.installDirectory </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#jmodsOverrideDirectory2">jmodsOverrideDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.jmodsOverrideDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/jmods/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#labels1">labels</a> </td> 
                                    <td>Map</td> 
                                    <td> The labels to apply to the container image. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#launchers2">launchers</a> </td> 
                                    <td>List</td> 
                                    <td> A list of extra launchers to include in the resulting application. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#legalDirectory2">legalDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing legal notices that will be copied to the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.legalDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/main/legal/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#licenseFile2">licenseFile</a> </td> 
                                    <td>File</td> 
                                    <td> The path to the application license file. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.licenseFile </li> 
                                            <li> <em>Default</em> : ${project.basedir}/LICENSE </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#linuxConfiguration2">linuxConfiguration</a> </td> 
                                    <td>LinuxConfiguration</td> 
                                    <td> Linux specific configuration. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#macOSConfiguration2">macOSConfiguration</a> </td> 
                                    <td>MacOSConfiguration</td> 
                                    <td> MacOS specific configuration. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#manDirectory2">manDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing man pages that will be copied to the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.manDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/main/man/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#overWriteIfNewer2">overWriteIfNewer</a> </td> 
                                    <td>boolean</td> 
                                    <td> Overwrite dependencies that don't exist or are older than the source. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.overWriteIfNewer </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#ports1">ports</a> </td> 
                                    <td>Set</td> 
                                    <td> The ports exposed by the container at runtime defined as: port_number [ '/' udp/tcp ] 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#projectMainClass2">projectMainClass</a> </td> 
                                    <td>String</td> 
                                    <td> The main class in the project module to use when building the project JMOD package. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.runtime.projectMainClass </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#registry1">registry</a> </td> 
                                    <td>String</td> 
                                    <td> The registry part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version} 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.container.registry </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#repository1">repository</a> </td> 
                                    <td>String</td> 
                                    <td> The repository part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version} 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.container.repository </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#resolveProjectMainClass2">resolveProjectMainClass</a> </td> 
                                    <td>boolean</td> 
                                    <td> Resolve the project main class when not specified explicitly. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.runtime.projectMainClass </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#resourceDirectory2">resourceDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> The path to resources that override resulting package resources. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.resourceDirectory </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#skip2">skip</a> </td> 
                                    <td>boolean</td> 
                                    <td> Skips the generation of the application. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.skip </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#stripDebug2">stripDebug</a> </td> 
                                    <td>boolean</td> 
                                    <td> Strip debug information from the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.stripDebug </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#stripNativeCommands2">stripNativeCommands</a> </td> 
                                    <td>boolean</td> 
                                    <td> Strip native command (eg. java...) from the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.stripNativeCommands </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#user1">user</a> </td> 
                                    <td>String</td> 
                                    <td> The user and group used to run the container defined as: user / uid [ ':' group / gid ] 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#vendor2">vendor</a> </td> 
                                    <td>String</td> 
                                    <td> The application vendor. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.vendor </li> 
                                            <li> <em>Default</em> : ${project.organization.name} </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#verbose2">verbose</a> </td> 
                                    <td>boolean</td> 
                                    <td> Enables verbose logging. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.verbose </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#vm2">vm</a> </td> 
                                    <td>String</td> 
                                    <td> Select the HotSpot VM in the output image defined as: 'client' / 'server' / 'minimal' / 'all' 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.vm </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#volumes1">volumes</a> </td> 
                                    <td>Set</td> 
                                    <td> The container's mount points. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#windowsConfiguration2">windowsConfiguration</a> </td> 
                                    <td>WindowsConfiguration</td> 
                                    <td> Windows specific configuration. 
                                        <ul></ul> </td> 
                                </tr> 
                            </tbody>
                        </table>
                    </div> 
                    <h5 id="parameter-details-2">Parameter details</h5> 
                    <h6 id="addmodules-2">&lt;addModules&gt;</h6> 
                    <p>The modules to add to the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.addModules</li> 
                    </ul> 
                    <h6 id="addoptions-2">&lt;addOptions&gt;</h6> 
                    <p>The options to prepend before any other options when invoking the JVM in the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.addOptions</li> 
                    </ul> 
                    <h6 id="attach-2">&lt;attach&gt;</h6> 
                    <p>Attach the resulting image archives to the project to install them in the local Maven repository and deploy them to remote repositories.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: yes</li> 
                        <li><strong>User property</strong>: inverno.image.attach</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="automaticlaunchers-2">&lt;automaticLaunchers&gt;</h6> 
                    <p>Enables the automatic generation of launchers based on the main classes extracted from the application module. If enabled, a launcher is generated for all main classes other than the main launcher.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.automaticLaunchers</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="bindservices-2">&lt;bindServices&gt;</h6> 
                    <p>Link in service provider modules and their dependencies.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.bindServices</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="compress-2">&lt;compress&gt;</h6> 
                    <p>The compress level of the resulting image: 0=No compression, 1=constant string sharing, 2=ZIP.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.compress</li> 
                    </ul> 
                    <h6 id="configurationdirectory-2">&lt;configurationDirectory&gt;</h6> 
                    <p>A directory containing user-editable configuration files that will be copied to the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.configurationDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/main/conf/</li> 
                    </ul> 
                    <h6 id="copyright-2">&lt;copyright&gt;</h6> 
                    <p>The application copyright.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.copyright</li> 
                    </ul> 
                    <h6 id="description-2">&lt;description&gt;</h6> 
                    <p>The description of the application.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.description</li> 
                        <li><strong>Default</strong>: ${project.description}</li> 
                    </ul> 
                    <h6 id="dockerenvironment">&lt;dockerEnvironment&gt;</h6> 
                    <p>The Docker environment variables used by the Docker CLI executable.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.util.Map</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="dockerexecutable">&lt;dockerExecutable&gt;</h6> 
                    <p>The path to the Docker CLI executable used to load the image in the Docker daemon.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.container.docker.executable</li> 
                    </ul> 
                    <h6 id="environment-1">&lt;environment&gt;</h6> 
                    <p>The container's environment variables.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.util.Map</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="excludeartifactids-2">&lt;excludeArtifactIds&gt;</h6> 
                    <p>Comma separated list of Artifact names to exclude.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.excludeArtifactIds</li> 
                    </ul> 
                    <h6 id="excludeclassifiers-2">&lt;excludeClassifiers&gt;</h6> 
                    <p>Comma Separated list of Classifiers to exclude. Empty String indicates don't exclude anything (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: excludeClassifiers</li> 
                    </ul> 
                    <h6 id="excludegroupids-2">&lt;excludeGroupIds&gt;</h6> 
                    <p>Comma separated list of GroupId Names to exclude.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.excludeGroupIds</li> 
                    </ul> 
                    <h6 id="excludescope-2">&lt;excludeScope&gt;</h6> 
                    <p>Scope to exclude. An Empty string indicates no scopes (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.excludeScope</li> 
                    </ul> 
                    <h6 id="executable-1">&lt;executable&gt;</h6> 
                    <p>The executable in the application image to use as image entry point. The specified name should correspond to a declared application image launchers or the project artifact id if no launcher was specified.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: yes</li> 
                        <li><strong>User property</strong>: inverno.app.executable</li> 
                        <li><strong>Default</strong>: ${project.artifactId}</li> 
                    </ul> 
                    <h6 id="formats-2">&lt;formats&gt;</h6> 
                    <p>A list of archive formats to generate (eg. zip, tar.gz...)</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.util.Set</li> 
                        <li><strong>Required</strong>: yes</li> 
                        <li><strong>Default</strong>: zip</li> 
                    </ul> 
                    <h6 id="from-1">&lt;from&gt;</h6> 
                    <p>The base container image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: yes</li> 
                        <li><strong>User property</strong>: inverno.container.from</li> 
                        <li><strong>Default</strong>: debian:buster-slim</li> 
                    </ul> 
                    <h6 id="ignoresigninginformation-2">&lt;ignoreSigningInformation&gt;</h6> 
                    <p>Suppress a fatal error when signed modular JARs are linked in the image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.ignoreSigningInformation</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="imageformat-1">&lt;imageFormat&gt;</h6> 
                    <p>The format of the container image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: com.google.cloud.tools.jib.api.buildplan.ImageFormat</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.container.imageFormat</li> 
                        <li><strong>Default</strong>: Docker</li> 
                    </ul> 
                    <h6 id="includeartifactids-2">&lt;includeArtifactIds&gt;</h6> 
                    <p>Comma separated list of Artifact names to include. Empty String indicates include everything (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.includeArtifactIds</li> 
                    </ul> 
                    <h6 id="includeclassifiers-2">&lt;includeClassifiers&gt;</h6> 
                    <p>Comma Separated list of Classifiers to include. Empty String indicates include everything (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.includeClassifiers</li> 
                    </ul> 
                    <h6 id="includegroupids-2">&lt;includeGroupIds&gt;</h6> 
                    <p>Comma separated list of GroupIds to include. Empty String indicates include everything (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.includeGroupIds</li> 
                    </ul> 
                    <h6 id="includescope-2">&lt;includeScope&gt;</h6> 
                    <p>Scope to include. An Empty string indicates all scopes (default). The scopes being interpreted are the scopes as Maven sees them, not as specified in the pom. In summary:</p> 
                    <ul> 
                        <li> <p>runtime scope gives runtime and compile dependencies,</p> </li> 
                        <li> <p>compile scope gives compile, provided, and system dependencies,</p> </li> 
                        <li> <p>test (default) scope gives all dependencies,</p> </li> 
                        <li> <p>provided scope just gives provided dependencies,</p> </li> 
                        <li> <p>system scope just gives system dependencies.</p> </li> 
                        <li> <p><strong>Type</strong>: java.lang.String</p> </li> 
                        <li> <p><strong>Required</strong>: no</p> </li> 
                        <li> <p><strong>User property</strong>: inverno.image.includeScope</p> </li> 
                    </ul> 
                    <h6 id="installdirectory-2">&lt;installDirectory&gt;</h6> 
                    <p>Absolute path of the installation directory of the application on OS X or Linux. Relative sub-path of the installation location of the application such as 'Program Files' or 'AppData' on Windows.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.installDirectory</li> 
                    </ul> 
                    <h6 id="jmodsoverridedirectory-2">&lt;jmodsOverrideDirectory&gt;</h6> 
                    <p>A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.jmodsOverrideDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/jmods/</li> 
                    </ul> 
                    <h6 id="labels-1">&lt;labels&gt;</h6> 
                    <p>The labels to apply to the container image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.util.Map</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="launchers-2">&lt;launchers&gt;</h6> 
                    <p>A list of extra launchers to include in the resulting application.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.util.List</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="legaldirectory-2">&lt;legalDirectory&gt;</h6> 
                    <p>A directory containing legal notices that will be copied to the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.legalDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/main/legal/</li> 
                    </ul> 
                    <h6 id="licensefile-2">&lt;licenseFile&gt;</h6> 
                    <p>The path to the application license file.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.licenseFile</li> 
                        <li><strong>Default</strong>: ${project.basedir}/LICENSE</li> 
                    </ul> 
                    <h6 id="linuxconfiguration-2">&lt;linuxConfiguration&gt;</h6> 
                    <p>Linux specific configuration.</p> 
                    <ul> 
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$LinuxConfiguration</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="macosconfiguration-2">&lt;macOSConfiguration&gt;</h6> 
                    <p>MacOS specific configuration.</p> 
                    <ul> 
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$MacOSConfiguration</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="mandirectory-2">&lt;manDirectory&gt;</h6> 
                    <p>A directory containing man pages that will be copied to the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.manDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/main/man/</li> 
                    </ul> 
                    <h6 id="overwriteifnewer-2">&lt;overWriteIfNewer&gt;</h6> 
                    <p>Overwrite dependencies that don't exist or are older than the source.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.overWriteIfNewer</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="ports-1">&lt;ports&gt;</h6> 
                    <p>The ports exposed by the container at runtime defined as: port_number [ '/' udp/tcp ]</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.util.Set</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="projectmainclass-2">&lt;projectMainClass&gt;</h6> 
                    <p>The main class in the project module to use when building the project JMOD package.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.runtime.projectMainClass</li> 
                    </ul> 
                    <h6 id="registry-1">&lt;registry&gt;</h6> 
                    <p>The registry part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version}</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.container.registry</li> 
                    </ul> 
                    <h6 id="repository-1">&lt;repository&gt;</h6> 
                    <p>The repository part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version}</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.container.repository</li> 
                    </ul> 
                    <h6 id="resolveprojectmainclass-2">&lt;resolveProjectMainClass&gt;</h6> 
                    <p>Resolve the project main class when not specified explicitly.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.runtime.projectMainClass</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="resourcedirectory-2">&lt;resourceDirectory&gt;</h6> 
                    <p>The path to resources that override resulting package resources.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.resourceDirectory</li> 
                    </ul> 
                    <h6 id="skip-2">&lt;skip&gt;</h6> 
                    <p>Skips the generation of the application.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.skip</li> 
                    </ul> 
                    <h6 id="stripdebug-2">&lt;stripDebug&gt;</h6> 
                    <p>Strip debug information from the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.stripDebug</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="stripnativecommands-2">&lt;stripNativeCommands&gt;</h6> 
                    <p>Strip native command (eg. java...) from the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.stripNativeCommands</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="user-1">&lt;user&gt;</h6> 
                    <p>The user and group used to run the container defined as: user / uid [ ':' group / gid ]</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="vendor-2">&lt;vendor&gt;</h6> 
                    <p>The application vendor.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.vendor</li> 
                        <li><strong>Default</strong>: ${project.organization.name}</li> 
                    </ul> 
                    <h6 id="verbose-2">&lt;verbose&gt;</h6> 
                    <p>Enables verbose logging.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.verbose</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="vm-2">&lt;vm&gt;</h6> 
                    <p>Select the HotSpot VM in the output image defined as: 'client' / 'server' / 'minimal' / 'all'</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.vm</li> 
                    </ul> 
                    <h6 id="volumes-1">&lt;volumes&gt;</h6> 
                    <p>The container's mount points.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.util.Set</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="windowsconfiguration-2">&lt;windowsConfiguration&gt;</h6> 
                    <p>Windows specific configuration.</p> 
                    <ul> 
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$WindowsConfiguration</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h4 id="invernobuild-image-tar">inverno:build-image-tar</h4> 
                    <p><strong>Full name:</strong></p> 
                    <p>io.inverno.tool:inverno-maven-plugin:1.1.0:build-image-tar</p> 
                    <p><strong>Description:</strong></p> 
                    <p>Builds a container image to a TAR archive that can be later loaded into Docker:</p> 
                    <p>$ docker load --input target/&lt;image&gt;.tar</p> 
                    <p><strong>Attributes:</strong></p> 
                    <ul> 
                        <li>Requires a Maven project to be executed.</li> 
                        <li>Requires dependency resolution of artifacts in scope: compile+runtime.</li> 
                        <li>Requires dependency collection of artifacts in scope: compile+runtime.</li> 
                        <li>Since version: 1.0.</li> 
                        <li>Binds by default to the lifecycle phase: package.</li> 
                    </ul> 
                    <h5 id="required-parameters-3">Required parameters</h5> 
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered "> 
                            <tbody>
                                <tr> 
                                    <th>Name</th> 
                                    <th>Type</th> 
                                    <th>Description</th> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#attach3">attach</a> </td> 
                                    <td>boolean</td> 
                                    <td> Attach the resulting image archives to the project to install them in the local Maven repository and deploy them to remote repositories. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.attach </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#executable2">executable</a> </td> 
                                    <td>String</td> 
                                    <td> The executable in the application image to use as image entry point. The specified name should correspond to a declared application image launchers or the project artifact id if no launcher was specified. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.executable </li> 
                                            <li> <em>Default</em> : ${project.artifactId} </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#formats3">formats</a> </td> 
                                    <td>Set</td> 
                                    <td> A list of archive formats to generate (eg. zip, tar.gz...) 
                                        <ul> 
                                            <li> <em>Default</em> : zip </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#from2">from</a> </td> 
                                    <td>String</td> 
                                    <td> The base container image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.container.from </li> 
                                            <li> <em>Default</em> : debian:buster-slim </li> 
                                        </ul> </td> 
                                </tr> 
                            </tbody>
                        </table>
                    </div> 
                    <h5 id="optional-parameters-3">Optional parameters</h5> 
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered "> 
                            <tbody>
                                <tr> 
                                    <th>Name</th> 
                                    <th>Type</th> 
                                    <th>Description</th> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#addModules3">addModules</a> </td> 
                                    <td>String</td> 
                                    <td> The modules to add to the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.addModules </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#addOptions3">addOptions</a> </td> 
                                    <td>String</td> 
                                    <td> The options to prepend before any other options when invoking the JVM in the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.addOptions </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#automaticLaunchers3">automaticLaunchers</a> </td> 
                                    <td>boolean</td> 
                                    <td> Enables the automatic generation of launchers based on the main classes extracted from the application module. If enabled, a launcher is generated for all main classes other than the main launcher. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.automaticLaunchers </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#bindServices3">bindServices</a> </td> 
                                    <td>boolean</td> 
                                    <td> Link in service provider modules and their dependencies. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.bindServices </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#compress3">compress</a> </td> 
                                    <td>String</td> 
                                    <td> The compress level of the resulting image: 0=No compression, 1=constant string sharing, 2=ZIP. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.compress </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#configurationDirectory3">configurationDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing user-editable configuration files that will be copied to the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.configurationDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/main/conf/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#copyright3">copyright</a> </td> 
                                    <td>String</td> 
                                    <td> The application copyright. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.copyright </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#description3">description</a> </td> 
                                    <td>String</td> 
                                    <td> The description of the application. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.description </li> 
                                            <li> <em>Default</em> : ${project.description} </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#environment2">environment</a> </td> 
                                    <td>Map</td> 
                                    <td> The container's environment variables. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#excludeArtifactIds3">excludeArtifactIds</a> </td> 
                                    <td>String</td> 
                                    <td> Comma separated list of Artifact names to exclude. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.excludeArtifactIds </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#excludeClassifiers3">excludeClassifiers</a> </td> 
                                    <td>String</td> 
                                    <td> Comma Separated list of Classifiers to exclude. Empty String indicates don't exclude anything (default). 
                                        <ul> 
                                            <li> <em>User property</em> : excludeClassifiers </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#excludeGroupIds3">excludeGroupIds</a> </td> 
                                    <td>String</td> 
                                    <td> Comma separated list of GroupId Names to exclude. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.excludeGroupIds </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#excludeScope3">excludeScope</a> </td> 
                                    <td>String</td> 
                                    <td> Scope to exclude. An Empty string indicates no scopes (default). 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.excludeScope </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#ignoreSigningInformation3">ignoreSigningInformation</a> </td> 
                                    <td>boolean</td> 
                                    <td> Suppress a fatal error when signed modular JARs are linked in the image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.ignoreSigningInformation </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#imageFormat2">imageFormat</a> </td> 
                                    <td>ImageFormat</td> 
                                    <td> The format of the container image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.container.imageFormat </li> 
                                            <li> <em>Default</em> : Docker </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#includeArtifactIds3">includeArtifactIds</a> </td> 
                                    <td>String</td> 
                                    <td> Comma separated list of Artifact names to include. Empty String indicates include everything (default). 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.includeArtifactIds </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#includeClassifiers3">includeClassifiers</a> </td> 
                                    <td>String</td> 
                                    <td> Comma Separated list of Classifiers to include. Empty String indicates include everything (default). 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.includeClassifiers </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#includeGroupIds3">includeGroupIds</a> </td> 
                                    <td>String</td> 
                                    <td> Comma separated list of GroupIds to include. Empty String indicates include everything (default). 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.includeGroupIds </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#includeScope3">includeScope</a> </td> 
                                    <td>String</td> 
                                    <td> Scope to include. An Empty string indicates all scopes (default). The scopes being interpreted are the scopes as Maven sees them, not as specified in the pom. In summary: 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.includeScope </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#installDirectory3">installDirectory</a> </td> 
                                    <td>String</td> 
                                    <td> Absolute path of the installation directory of the application on OS X or Linux. Relative sub-path of the installation location of the application such as 'Program Files' or 'AppData' on Windows. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.installDirectory </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#jmodsOverrideDirectory3">jmodsOverrideDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.jmodsOverrideDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/jmods/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#labels2">labels</a> </td> 
                                    <td>Map</td> 
                                    <td> The labels to apply to the container image. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#launchers3">launchers</a> </td> 
                                    <td>List</td> 
                                    <td> A list of extra launchers to include in the resulting application. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#legalDirectory3">legalDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing legal notices that will be copied to the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.legalDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/main/legal/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#licenseFile3">licenseFile</a> </td> 
                                    <td>File</td> 
                                    <td> The path to the application license file. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.licenseFile </li> 
                                            <li> <em>Default</em> : ${project.basedir}/LICENSE </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#linuxConfiguration3">linuxConfiguration</a> </td> 
                                    <td>LinuxConfiguration</td> 
                                    <td> Linux specific configuration. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#macOSConfiguration3">macOSConfiguration</a> </td> 
                                    <td>MacOSConfiguration</td> 
                                    <td> MacOS specific configuration. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#manDirectory3">manDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing man pages that will be copied to the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.manDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/main/man/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#overWriteIfNewer3">overWriteIfNewer</a> </td> 
                                    <td>boolean</td> 
                                    <td> Overwrite dependencies that don't exist or are older than the source. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.overWriteIfNewer </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#ports2">ports</a> </td> 
                                    <td>Set</td> 
                                    <td> The ports exposed by the container at runtime defined as: port_number [ '/' udp/tcp ] 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#projectMainClass3">projectMainClass</a> </td> 
                                    <td>String</td> 
                                    <td> The main class in the project module to use when building the project JMOD package. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.runtime.projectMainClass </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#registry2">registry</a> </td> 
                                    <td>String</td> 
                                    <td> The registry part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version} 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.container.registry </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#repository2">repository</a> </td> 
                                    <td>String</td> 
                                    <td> The repository part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version} 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.container.repository </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#resolveProjectMainClass3">resolveProjectMainClass</a> </td> 
                                    <td>boolean</td> 
                                    <td> Resolve the project main class when not specified explicitly. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.runtime.projectMainClass </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#resourceDirectory3">resourceDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> The path to resources that override resulting package resources. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.resourceDirectory </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#skip3">skip</a> </td> 
                                    <td>boolean</td> 
                                    <td> Skips the generation of the application. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.skip </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#stripDebug3">stripDebug</a> </td> 
                                    <td>boolean</td> 
                                    <td> Strip debug information from the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.stripDebug </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#stripNativeCommands3">stripNativeCommands</a> </td> 
                                    <td>boolean</td> 
                                    <td> Strip native command (eg. java...) from the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.stripNativeCommands </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#user2">user</a> </td> 
                                    <td>String</td> 
                                    <td> The user and group used to run the container defined as: user / uid [ ':' group / gid ] 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#vendor3">vendor</a> </td> 
                                    <td>String</td> 
                                    <td> The application vendor. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.app.vendor </li> 
                                            <li> <em>Default</em> : ${project.organization.name} </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#verbose3">verbose</a> </td> 
                                    <td>boolean</td> 
                                    <td> Enables verbose logging. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.verbose </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#vm3">vm</a> </td> 
                                    <td>String</td> 
                                    <td> Select the HotSpot VM in the output image defined as: 'client' / 'server' / 'minimal' / 'all' 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.vm </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#volumes2">volumes</a> </td> 
                                    <td>Set</td> 
                                    <td> The container's mount points. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#windowsConfiguration3">windowsConfiguration</a> </td> 
                                    <td>WindowsConfiguration</td> 
                                    <td> Windows specific configuration. 
                                        <ul></ul> </td> 
                                </tr> 
                            </tbody>
                        </table>
                    </div> 
                    <h5 id="parameter-details-3">Parameter details</h5> 
                    <h6 id="addmodules-3">&lt;addModules&gt;</h6> 
                    <p>The modules to add to the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.addModules</li> 
                    </ul> 
                    <h6 id="addoptions-3">&lt;addOptions&gt;</h6> 
                    <p>The options to prepend before any other options when invoking the JVM in the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.addOptions</li> 
                    </ul> 
                    <h6 id="attach-3">&lt;attach&gt;</h6> 
                    <p>Attach the resulting image archives to the project to install them in the local Maven repository and deploy them to remote repositories.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: yes</li> 
                        <li><strong>User property</strong>: inverno.image.attach</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="automaticlaunchers-3">&lt;automaticLaunchers&gt;</h6> 
                    <p>Enables the automatic generation of launchers based on the main classes extracted from the application module. If enabled, a launcher is generated for all main classes other than the main launcher.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.automaticLaunchers</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="bindservices-3">&lt;bindServices&gt;</h6> 
                    <p>Link in service provider modules and their dependencies.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.bindServices</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="compress-3">&lt;compress&gt;</h6> 
                    <p>The compress level of the resulting image: 0=No compression, 1=constant string sharing, 2=ZIP.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.compress</li> 
                    </ul> 
                    <h6 id="configurationdirectory-3">&lt;configurationDirectory&gt;</h6> 
                    <p>A directory containing user-editable configuration files that will be copied to the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.configurationDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/main/conf/</li> 
                    </ul> 
                    <h6 id="copyright-3">&lt;copyright&gt;</h6> 
                    <p>The application copyright.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.copyright</li> 
                    </ul> 
                    <h6 id="description-3">&lt;description&gt;</h6> 
                    <p>The description of the application.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.description</li> 
                        <li><strong>Default</strong>: ${project.description}</li> 
                    </ul> 
                    <h6 id="environment-2">&lt;environment&gt;</h6> 
                    <p>The container's environment variables.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.util.Map</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="excludeartifactids-3">&lt;excludeArtifactIds&gt;</h6> 
                    <p>Comma separated list of Artifact names to exclude.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.excludeArtifactIds</li> 
                    </ul> 
                    <h6 id="excludeclassifiers-3">&lt;excludeClassifiers&gt;</h6> 
                    <p>Comma Separated list of Classifiers to exclude. Empty String indicates don't exclude anything (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: excludeClassifiers</li> 
                    </ul> 
                    <h6 id="excludegroupids-3">&lt;excludeGroupIds&gt;</h6> 
                    <p>Comma separated list of GroupId Names to exclude.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.excludeGroupIds</li> 
                    </ul> 
                    <h6 id="excludescope-3">&lt;excludeScope&gt;</h6> 
                    <p>Scope to exclude. An Empty string indicates no scopes (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.excludeScope</li> 
                    </ul> 
                    <h6 id="executable-2">&lt;executable&gt;</h6> 
                    <p>The executable in the application image to use as image entry point. The specified name should correspond to a declared application image launchers or the project artifact id if no launcher was specified.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: yes</li> 
                        <li><strong>User property</strong>: inverno.app.executable</li> 
                        <li><strong>Default</strong>: ${project.artifactId}</li> 
                    </ul> 
                    <h6 id="formats-3">&lt;formats&gt;</h6> 
                    <p>A list of archive formats to generate (eg. zip, tar.gz...)</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.util.Set</li> 
                        <li><strong>Required</strong>: yes</li> 
                        <li><strong>Default</strong>: zip</li> 
                    </ul> 
                    <h6 id="from-2">&lt;from&gt;</h6> 
                    <p>The base container image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: yes</li> 
                        <li><strong>User property</strong>: inverno.container.from</li> 
                        <li><strong>Default</strong>: debian:buster-slim</li> 
                    </ul> 
                    <h6 id="ignoresigninginformation-3">&lt;ignoreSigningInformation&gt;</h6> 
                    <p>Suppress a fatal error when signed modular JARs are linked in the image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.ignoreSigningInformation</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="imageformat-2">&lt;imageFormat&gt;</h6> 
                    <p>The format of the container image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: com.google.cloud.tools.jib.api.buildplan.ImageFormat</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.container.imageFormat</li> 
                        <li><strong>Default</strong>: Docker</li> 
                    </ul> 
                    <h6 id="includeartifactids-3">&lt;includeArtifactIds&gt;</h6> 
                    <p>Comma separated list of Artifact names to include. Empty String indicates include everything (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.includeArtifactIds</li> 
                    </ul> 
                    <h6 id="includeclassifiers-3">&lt;includeClassifiers&gt;</h6> 
                    <p>Comma Separated list of Classifiers to include. Empty String indicates include everything (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.includeClassifiers</li> 
                    </ul> 
                    <h6 id="includegroupids-3">&lt;includeGroupIds&gt;</h6> 
                    <p>Comma separated list of GroupIds to include. Empty String indicates include everything (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.includeGroupIds</li> 
                    </ul> 
                    <h6 id="includescope-3">&lt;includeScope&gt;</h6> 
                    <p>Scope to include. An Empty string indicates all scopes (default). The scopes being interpreted are the scopes as Maven sees them, not as specified in the pom. In summary:</p> 
                    <ul> 
                        <li> <p>runtime scope gives runtime and compile dependencies,</p> </li> 
                        <li> <p>compile scope gives compile, provided, and system dependencies,</p> </li> 
                        <li> <p>test (default) scope gives all dependencies,</p> </li> 
                        <li> <p>provided scope just gives provided dependencies,</p> </li> 
                        <li> <p>system scope just gives system dependencies.</p> </li> 
                        <li> <p><strong>Type</strong>: java.lang.String</p> </li> 
                        <li> <p><strong>Required</strong>: no</p> </li> 
                        <li> <p><strong>User property</strong>: inverno.image.includeScope</p> </li> 
                    </ul> 
                    <h6 id="installdirectory-3">&lt;installDirectory&gt;</h6> 
                    <p>Absolute path of the installation directory of the application on OS X or Linux. Relative sub-path of the installation location of the application such as 'Program Files' or 'AppData' on Windows.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.installDirectory</li> 
                    </ul> 
                    <h6 id="jmodsoverridedirectory-3">&lt;jmodsOverrideDirectory&gt;</h6> 
                    <p>A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.jmodsOverrideDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/jmods/</li> 
                    </ul> 
                    <h6 id="labels-2">&lt;labels&gt;</h6> 
                    <p>The labels to apply to the container image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.util.Map</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="launchers-3">&lt;launchers&gt;</h6> 
                    <p>A list of extra launchers to include in the resulting application.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.util.List</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="legaldirectory-3">&lt;legalDirectory&gt;</h6> 
                    <p>A directory containing legal notices that will be copied to the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.legalDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/main/legal/</li> 
                    </ul> 
                    <h6 id="licensefile-3">&lt;licenseFile&gt;</h6> 
                    <p>The path to the application license file.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.licenseFile</li> 
                        <li><strong>Default</strong>: ${project.basedir}/LICENSE</li> 
                    </ul> 
                    <h6 id="linuxconfiguration-3">&lt;linuxConfiguration&gt;</h6> 
                    <p>Linux specific configuration.</p> 
                    <ul> 
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$LinuxConfiguration</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="macosconfiguration-3">&lt;macOSConfiguration&gt;</h6> 
                    <p>MacOS specific configuration.</p> 
                    <ul> 
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$MacOSConfiguration</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="mandirectory-3">&lt;manDirectory&gt;</h6> 
                    <p>A directory containing man pages that will be copied to the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.manDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/main/man/</li> 
                    </ul> 
                    <h6 id="overwriteifnewer-3">&lt;overWriteIfNewer&gt;</h6> 
                    <p>Overwrite dependencies that don't exist or are older than the source.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.overWriteIfNewer</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="ports-2">&lt;ports&gt;</h6> 
                    <p>The ports exposed by the container at runtime defined as: port_number [ '/' udp/tcp ]</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.util.Set</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="projectmainclass-3">&lt;projectMainClass&gt;</h6> 
                    <p>The main class in the project module to use when building the project JMOD package.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.runtime.projectMainClass</li> 
                    </ul> 
                    <h6 id="registry-2">&lt;registry&gt;</h6> 
                    <p>The registry part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version}</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.container.registry</li> 
                    </ul> 
                    <h6 id="repository-2">&lt;repository&gt;</h6> 
                    <p>The repository part of the target image reference defined as: ${registry}/${repository}/${name}:${project.version}</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.container.repository</li> 
                    </ul> 
                    <h6 id="resolveprojectmainclass-3">&lt;resolveProjectMainClass&gt;</h6> 
                    <p>Resolve the project main class when not specified explicitly.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.runtime.projectMainClass</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="resourcedirectory-3">&lt;resourceDirectory&gt;</h6> 
                    <p>The path to resources that override resulting package resources.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.resourceDirectory</li> 
                    </ul> 
                    <h6 id="skip-3">&lt;skip&gt;</h6> 
                    <p>Skips the generation of the application.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.skip</li> 
                    </ul> 
                    <h6 id="stripdebug-3">&lt;stripDebug&gt;</h6> 
                    <p>Strip debug information from the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.stripDebug</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="stripnativecommands-3">&lt;stripNativeCommands&gt;</h6> 
                    <p>Strip native command (eg. java...) from the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.stripNativeCommands</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="user-2">&lt;user&gt;</h6> 
                    <p>The user and group used to run the container defined as: user / uid [ ':' group / gid ]</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="vendor-3">&lt;vendor&gt;</h6> 
                    <p>The application vendor.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.app.vendor</li> 
                        <li><strong>Default</strong>: ${project.organization.name}</li> 
                    </ul> 
                    <h6 id="verbose-3">&lt;verbose&gt;</h6> 
                    <p>Enables verbose logging.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.verbose</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="vm-3">&lt;vm&gt;</h6> 
                    <p>Select the HotSpot VM in the output image defined as: 'client' / 'server' / 'minimal' / 'all'</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.vm</li> 
                    </ul> 
                    <h6 id="volumes-2">&lt;volumes&gt;</h6> 
                    <p>The container's mount points.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.util.Set</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="windowsconfiguration-3">&lt;windowsConfiguration&gt;</h6> 
                    <p>Windows specific configuration.</p> 
                    <ul> 
                        <li><strong>Type</strong>: io.inverno.tool.maven.internal.task.CreateProjectApplicationTask$WindowsConfiguration</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h4 id="invernobuild-runtime">inverno:build-runtime</h4> 
                    <p><strong>Full name:</strong></p> 
                    <p>io.inverno.tool:inverno-maven-plugin:1.1.0:build-runtime</p> 
                    <p><strong>Description:</strong></p> 
                    <p>Builds the project runtime image.</p> 
                    <p>A runtime image is a custom Java runtime containing a set of modules and their dependencies.</p> 
                    <p><strong>Attributes:</strong></p> 
                    <ul> 
                        <li>Requires a Maven project to be executed.</li> 
                        <li>Requires dependency resolution of artifacts in scope: compile+runtime.</li> 
                        <li>Requires dependency collection of artifacts in scope: compile+runtime.</li> 
                        <li>Since version: 1.0.</li> 
                        <li>Binds by default to the lifecycle phase: package.</li> 
                    </ul> 
                    <h5 id="required-parameters-4">Required parameters</h5> 
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered "> 
                            <tbody>
                                <tr> 
                                    <th>Name</th> 
                                    <th>Type</th> 
                                    <th>Description</th> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#attach4">attach</a> </td> 
                                    <td>boolean</td> 
                                    <td> Attach the resulting image archives to the project to install them in the local Maven repository and deploy them to remote repositories. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.attach </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#formats4">formats</a> </td> 
                                    <td>Set</td> 
                                    <td> A list of archive formats to generate (eg. zip, tar.gz...) 
                                        <ul> 
                                            <li> <em>Default</em> : zip </li> 
                                        </ul> </td> 
                                </tr> 
                            </tbody>
                        </table>
                    </div> 
                    <h5 id="optional-parameters-4">Optional parameters</h5> 
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered "> 
                            <tbody>
                                <tr> 
                                    <th>Name</th> 
                                    <th>Type</th> 
                                    <th>Description</th> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#addModules4">addModules</a> </td> 
                                    <td>String</td> 
                                    <td> The modules to add to the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.addModules </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#addOptions4">addOptions</a> </td> 
                                    <td>String</td> 
                                    <td> The options to prepend before any other options when invoking the JVM in the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.addOptions </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#bindServices4">bindServices</a> </td> 
                                    <td>boolean</td> 
                                    <td> Link in service provider modules and their dependencies. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.bindServices </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#compress4">compress</a> </td> 
                                    <td>String</td> 
                                    <td> The compress level of the resulting image: 0=No compression, 1=constant string sharing, 2=ZIP. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.compress </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#configurationDirectory4">configurationDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing user-editable configuration files that will be copied to the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.configurationDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/main/conf/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#excludeArtifactIds4">excludeArtifactIds</a> </td> 
                                    <td>String</td> 
                                    <td> Comma separated list of Artifact names to exclude. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.excludeArtifactIds </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#excludeClassifiers4">excludeClassifiers</a> </td> 
                                    <td>String</td> 
                                    <td> Comma Separated list of Classifiers to exclude. Empty String indicates don't exclude anything (default). 
                                        <ul> 
                                            <li> <em>User property</em> : excludeClassifiers </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#excludeGroupIds4">excludeGroupIds</a> </td> 
                                    <td>String</td> 
                                    <td> Comma separated list of GroupId Names to exclude. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.excludeGroupIds </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#excludeScope4">excludeScope</a> </td> 
                                    <td>String</td> 
                                    <td> Scope to exclude. An Empty string indicates no scopes (default). 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.excludeScope </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#ignoreSigningInformation4">ignoreSigningInformation</a> </td> 
                                    <td>boolean</td> 
                                    <td> Suppress a fatal error when signed modular JARs are linked in the image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.ignoreSigningInformation </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#includeArtifactIds4">includeArtifactIds</a> </td> 
                                    <td>String</td> 
                                    <td> Comma separated list of Artifact names to include. Empty String indicates include everything (default). 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.includeArtifactIds </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#includeClassifiers4">includeClassifiers</a> </td> 
                                    <td>String</td> 
                                    <td> Comma Separated list of Classifiers to include. Empty String indicates include everything (default). 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.includeClassifiers </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#includeGroupIds4">includeGroupIds</a> </td> 
                                    <td>String</td> 
                                    <td> Comma separated list of GroupIds to include. Empty String indicates include everything (default). 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.includeGroupIds </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#includeScope4">includeScope</a> </td> 
                                    <td>String</td> 
                                    <td> Scope to include. An Empty string indicates all scopes (default). The scopes being interpreted are the scopes as Maven sees them, not as specified in the pom. In summary: 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.includeScope </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#jmodsOverrideDirectory4">jmodsOverrideDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.jmodsOverrideDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/jmods/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#launchers4">launchers</a> </td> 
                                    <td>List</td> 
                                    <td> A list of launchers to include in the resulting runtime. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#legalDirectory4">legalDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing legal notices that will be copied to the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.legalDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/main/legal/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#manDirectory4">manDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing man pages that will be copied to the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.manDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/main/man/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#overWriteIfNewer4">overWriteIfNewer</a> </td> 
                                    <td>boolean</td> 
                                    <td> Overwrite dependencies that don't exist or are older than the source. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.overWriteIfNewer </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#projectMainClass4">projectMainClass</a> </td> 
                                    <td>String</td> 
                                    <td> The main class in the project module to use when building the project JMOD package. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.runtime.projectMainClass </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#resolveProjectMainClass4">resolveProjectMainClass</a> </td> 
                                    <td>boolean</td> 
                                    <td> Resolve the project main class when not specified explicitly. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.runtime.projectMainClass </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#skip4">skip</a> </td> 
                                    <td>boolean</td> 
                                    <td> Skips the generation of the runtime. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.runtime.skip </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#stripDebug4">stripDebug</a> </td> 
                                    <td>boolean</td> 
                                    <td> Strip debug information from the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.stripDebug </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#stripNativeCommands4">stripNativeCommands</a> </td> 
                                    <td>boolean</td> 
                                    <td> Strip native command (eg. java...) from the resulting image. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.stripNativeCommands </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#verbose4">verbose</a> </td> 
                                    <td>boolean</td> 
                                    <td> Enables verbose logging. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.verbose </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#vm4">vm</a> </td> 
                                    <td>String</td> 
                                    <td> Select the HotSpot VM in the output image defined as: 'client' / 'server' / 'minimal' / 'all' 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.image.vm </li> 
                                        </ul> </td> 
                                </tr> 
                            </tbody>
                        </table>
                    </div> 
                    <h5 id="parameter-details-4">Parameter details</h5> 
                    <h6 id="addmodules-4">&lt;addModules&gt;</h6> 
                    <p>The modules to add to the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.addModules</li> 
                    </ul> 
                    <h6 id="addoptions-4">&lt;addOptions&gt;</h6> 
                    <p>The options to prepend before any other options when invoking the JVM in the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.addOptions</li> 
                    </ul> 
                    <h6 id="attach-4">&lt;attach&gt;</h6> 
                    <p>Attach the resulting image archives to the project to install them in the local Maven repository and deploy them to remote repositories.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: yes</li> 
                        <li><strong>User property</strong>: inverno.image.attach</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="bindservices-4">&lt;bindServices&gt;</h6> 
                    <p>Link in service provider modules and their dependencies.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.bindServices</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="compress-4">&lt;compress&gt;</h6> 
                    <p>The compress level of the resulting image: 0=No compression, 1=constant string sharing, 2=ZIP.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.compress</li> 
                    </ul> 
                    <h6 id="configurationdirectory-4">&lt;configurationDirectory&gt;</h6> 
                    <p>A directory containing user-editable configuration files that will be copied to the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.configurationDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/main/conf/</li> 
                    </ul> 
                    <h6 id="excludeartifactids-4">&lt;excludeArtifactIds&gt;</h6> 
                    <p>Comma separated list of Artifact names to exclude.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.excludeArtifactIds</li> 
                    </ul> 
                    <h6 id="excludeclassifiers-4">&lt;excludeClassifiers&gt;</h6> 
                    <p>Comma Separated list of Classifiers to exclude. Empty String indicates don't exclude anything (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: excludeClassifiers</li> 
                    </ul> 
                    <h6 id="excludegroupids-4">&lt;excludeGroupIds&gt;</h6> 
                    <p>Comma separated list of GroupId Names to exclude.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.excludeGroupIds</li> 
                    </ul> 
                    <h6 id="excludescope-4">&lt;excludeScope&gt;</h6> 
                    <p>Scope to exclude. An Empty string indicates no scopes (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.excludeScope</li> 
                    </ul> 
                    <h6 id="formats-4">&lt;formats&gt;</h6> 
                    <p>A list of archive formats to generate (eg. zip, tar.gz...)</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.util.Set</li> 
                        <li><strong>Required</strong>: yes</li> 
                        <li><strong>Default</strong>: zip</li> 
                    </ul> 
                    <h6 id="ignoresigninginformation-4">&lt;ignoreSigningInformation&gt;</h6> 
                    <p>Suppress a fatal error when signed modular JARs are linked in the image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.ignoreSigningInformation</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="includeartifactids-4">&lt;includeArtifactIds&gt;</h6> 
                    <p>Comma separated list of Artifact names to include. Empty String indicates include everything (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.includeArtifactIds</li> 
                    </ul> 
                    <h6 id="includeclassifiers-4">&lt;includeClassifiers&gt;</h6> 
                    <p>Comma Separated list of Classifiers to include. Empty String indicates include everything (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.includeClassifiers</li> 
                    </ul> 
                    <h6 id="includegroupids-4">&lt;includeGroupIds&gt;</h6> 
                    <p>Comma separated list of GroupIds to include. Empty String indicates include everything (default).</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.includeGroupIds</li> 
                    </ul> 
                    <h6 id="includescope-4">&lt;includeScope&gt;</h6> 
                    <p>Scope to include. An Empty string indicates all scopes (default). The scopes being interpreted are the scopes as Maven sees them, not as specified in the pom. In summary:</p> 
                    <ul> 
                        <li> <p>runtime scope gives runtime and compile dependencies,</p> </li> 
                        <li> <p>compile scope gives compile, provided, and system dependencies,</p> </li> 
                        <li> <p>test (default) scope gives all dependencies,</p> </li> 
                        <li> <p>provided scope just gives provided dependencies,</p> </li> 
                        <li> <p>system scope just gives system dependencies.</p> </li> 
                        <li> <p><strong>Type</strong>: java.lang.String</p> </li> 
                        <li> <p><strong>Required</strong>: no</p> </li> 
                        <li> <p><strong>User property</strong>: inverno.image.includeScope</p> </li> 
                    </ul> 
                    <h6 id="jmodsoverridedirectory-4">&lt;jmodsOverrideDirectory&gt;</h6> 
                    <p>A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.jmodsOverrideDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/jmods/</li> 
                    </ul> 
                    <h6 id="launchers-4">&lt;launchers&gt;</h6> 
                    <p>A list of launchers to include in the resulting runtime.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.util.List</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="legaldirectory-4">&lt;legalDirectory&gt;</h6> 
                    <p>A directory containing legal notices that will be copied to the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.legalDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/main/legal/</li> 
                    </ul> 
                    <h6 id="mandirectory-4">&lt;manDirectory&gt;</h6> 
                    <p>A directory containing man pages that will be copied to the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.manDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/main/man/</li> 
                    </ul> 
                    <h6 id="overwriteifnewer-4">&lt;overWriteIfNewer&gt;</h6> 
                    <p>Overwrite dependencies that don't exist or are older than the source.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.overWriteIfNewer</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="projectmainclass-4">&lt;projectMainClass&gt;</h6> 
                    <p>The main class in the project module to use when building the project JMOD package.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.runtime.projectMainClass</li> 
                    </ul> 
                    <h6 id="resolveprojectmainclass-4">&lt;resolveProjectMainClass&gt;</h6> 
                    <p>Resolve the project main class when not specified explicitly.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.runtime.projectMainClass</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="skip-4">&lt;skip&gt;</h6> 
                    <p>Skips the generation of the runtime.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.runtime.skip</li> 
                    </ul> 
                    <h6 id="stripdebug-4">&lt;stripDebug&gt;</h6> 
                    <p>Strip debug information from the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.stripDebug</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="stripnativecommands-4">&lt;stripNativeCommands&gt;</h6> 
                    <p>Strip native command (eg. java...) from the resulting image.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.stripNativeCommands</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="verbose-4">&lt;verbose&gt;</h6> 
                    <p>Enables verbose logging.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.verbose</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="vm-4">&lt;vm&gt;</h6> 
                    <p>Select the HotSpot VM in the output image defined as: 'client' / 'server' / 'minimal' / 'all'</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.image.vm</li> 
                    </ul> 
                    <h4 id="invernohelp">inverno:help</h4> 
                    <p><strong>Full name:</strong></p> 
                    <p>io.inverno.tool:inverno-maven-plugin:1.1.0:help</p> 
                    <p><strong>Description:</strong></p> 
                    <p>Display help information on inverno-maven-plugin. Call mvn inverno:help -Ddetail=true -Dgoal=&lt;goal-name&gt; to display parameter details.</p> 
                    <p><strong>Attributes:</strong></p> 
                    <h5 id="optional-parameters-5">Optional parameters</h5> 
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered "> 
                            <tbody>
                                <tr> 
                                    <th>Name</th> 
                                    <th>Type</th> 
                                    <th>Description</th> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#detail">detail</a> </td> 
                                    <td>boolean</td> 
                                    <td> If true, display all settable properties for each goal. 
                                        <ul> 
                                            <li> <em>User property</em> : detail </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#goal">goal</a> </td> 
                                    <td>String</td> 
                                    <td> The name of the goal for which to show help. If unspecified, all goals will be displayed. 
                                        <ul> 
                                            <li> <em>User property</em> : goal </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#indentSize">indentSize</a> </td> 
                                    <td>int</td> 
                                    <td> The number of spaces per indentation level, should be positive. 
                                        <ul> 
                                            <li> <em>User property</em> : indentSize </li> 
                                            <li> <em>Default</em> : 2 </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#lineLength">lineLength</a> </td> 
                                    <td>int</td> 
                                    <td> The maximum length of a display line, should be positive. 
                                        <ul> 
                                            <li> <em>User property</em> : lineLength </li> 
                                            <li> <em>Default</em> : 80 </li> 
                                        </ul> </td> 
                                </tr> 
                            </tbody>
                        </table>
                    </div> 
                    <h5 id="parameter-details-5">Parameter details</h5> 
                    <h6 id="detail">&lt;detail&gt;</h6> 
                    <p>If true, display all settable properties for each goal.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: detail</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="goal">&lt;goal&gt;</h6> 
                    <p>The name of the goal for which to show help. If unspecified, all goals will be displayed.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: goal</li> 
                    </ul> 
                    <h6 id="indentsize">&lt;indentSize&gt;</h6> 
                    <p>The number of spaces per indentation level, should be positive.</p> 
                    <ul> 
                        <li><strong>Type</strong>: int</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: indentSize</li> 
                        <li><strong>Default</strong>: 2</li> 
                    </ul> 
                    <h6 id="linelength">&lt;lineLength&gt;</h6> 
                    <p>The maximum length of a display line, should be positive.</p> 
                    <ul> 
                        <li><strong>Type</strong>: int</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: lineLength</li> 
                        <li><strong>Default</strong>: 80</li> 
                    </ul> 
                    <h4 id="invernorun">inverno:run</h4> 
                    <p><strong>Full name:</strong></p> 
                    <p>io.inverno.tool:inverno-maven-plugin:1.1.0:run</p> 
                    <p><strong>Description:</strong></p> 
                    <p>Runs the project application.</p> 
                    <p><strong>Attributes:</strong></p> 
                    <ul> 
                        <li>Requires a Maven project to be executed.</li> 
                        <li>Requires dependency resolution of artifacts in scope: compile+runtime.</li> 
                        <li>Requires dependency collection of artifacts in scope: compile+runtime.</li> 
                        <li>Since version: 1.0.</li> 
                        <li>Binds by default to the lifecycle phase: validate.</li> 
                    </ul> 
                    <h5 id="optional-parameters-6">Optional parameters</h5> 
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered "> 
                            <tbody>
                                <tr> 
                                    <th>Name</th> 
                                    <th>Type</th> 
                                    <th>Description</th> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#addUnnamedModules">addUnnamedModules</a> </td> 
                                    <td>boolean</td> 
                                    <td> Adds the unnamed modules when executing the application. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.exec.addUnnamedModules </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#arguments">arguments</a> </td> 
                                    <td>String</td> 
                                    <td> The arguments to pass to the application. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#commandLineArguments">commandLineArguments</a> </td> 
                                    <td>String</td> 
                                    <td> The command line arguments to pass to the application. This parameter overrides AbstractExecMojo.arguments when specified. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.run.arguments </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#configurationDirectory5">configurationDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing user-editable configuration files that will be copied to the image to execute. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.exec.configurationDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/main/conf/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#jmodsOverrideDirectory5">jmodsOverrideDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.exec.jmodsOverrideDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/jmods/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#mainClass">mainClass</a> </td> 
                                    <td>String</td> 
                                    <td> The main class to use to run the application. If not specified, a main class is automatically selected. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.exec.mainClass </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#overWriteIfNewer5">overWriteIfNewer</a> </td> 
                                    <td>boolean</td> 
                                    <td> Overwrites dependencies that don't exist or are older than the source. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.exec.overWriteIfNewer </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#skip5">skip</a> </td> 
                                    <td>boolean</td> 
                                    <td> Skips the execution. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.exec.skip </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#verbose5">verbose</a> </td> 
                                    <td>boolean</td> 
                                    <td> Enables verbose logging. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.verbose </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#vmOptions">vmOptions</a> </td> 
                                    <td>String</td> 
                                    <td> The VM options to use when executing the application. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.exec.vmOptions </li> 
                                            <li> <em>Default</em> : -Dorg.apache.logging.log4j.simplelog.level=INFO -Dorg.apache.logging.log4j.level=INFO </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#workingDirectory">workingDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> The working directory of the application. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.run.workingDirectory </li> 
                                            <li> <em>Default</em> : ${project.build.directory}/maven-inverno/working </li> 
                                        </ul> </td> 
                                </tr> 
                            </tbody>
                        </table>
                    </div> 
                    <h5 id="parameter-details-6">Parameter details</h5> 
                    <h6 id="addunnamedmodules">&lt;addUnnamedModules&gt;</h6> 
                    <p>Adds the unnamed modules when executing the application.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.exec.addUnnamedModules</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="arguments">&lt;arguments&gt;</h6> 
                    <p>The arguments to pass to the application.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="commandlinearguments">&lt;commandLineArguments&gt;</h6> 
                    <p>The command line arguments to pass to the application. This parameter overrides AbstractExecMojo.arguments when specified.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.run.arguments</li> 
                    </ul> 
                    <h6 id="configurationdirectory-5">&lt;configurationDirectory&gt;</h6> 
                    <p>A directory containing user-editable configuration files that will be copied to the image to execute.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.exec.configurationDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/main/conf/</li> 
                    </ul> 
                    <h6 id="jmodsoverridedirectory-5">&lt;jmodsOverrideDirectory&gt;</h6> 
                    <p>A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.exec.jmodsOverrideDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/jmods/</li> 
                    </ul> 
                    <h6 id="mainclass">&lt;mainClass&gt;</h6> 
                    <p>The main class to use to run the application. If not specified, a main class is automatically selected.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.exec.mainClass</li> 
                    </ul> 
                    <h6 id="overwriteifnewer-5">&lt;overWriteIfNewer&gt;</h6> 
                    <p>Overwrites dependencies that don't exist or are older than the source.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.exec.overWriteIfNewer</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="skip-5">&lt;skip&gt;</h6> 
                    <p>Skips the execution.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.exec.skip</li> 
                    </ul> 
                    <h6 id="verbose-5">&lt;verbose&gt;</h6> 
                    <p>Enables verbose logging.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.verbose</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="vmoptions">&lt;vmOptions&gt;</h6> 
                    <p>The VM options to use when executing the application.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.exec.vmOptions</li> 
                        <li><strong>Default</strong>: -Dorg.apache.logging.log4j.simplelog.level=INFO -Dorg.apache.logging.log4j.level=INFO</li> 
                    </ul> 
                    <h6 id="workingdirectory">&lt;workingDirectory&gt;</h6> 
                    <p>The working directory of the application.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.run.workingDirectory</li> 
                        <li><strong>Default</strong>: ${project.build.directory}/maven-inverno/working</li> 
                    </ul> 
                    <h4 id="invernostart">inverno:start</h4> 
                    <p><strong>Full name:</strong></p> 
                    <p>io.inverno.tool:inverno-maven-plugin:1.1.0:start</p> 
                    <p><strong>Description:</strong></p> 
                    <p>Starts the project application without blocking the Maven build.</p> 
                    <p>This goal is used together with the stop goal in the pre-integration-test and post-integration-test phases to run integration tests.</p> 
                    <p><strong>Attributes:</strong></p> 
                    <ul> 
                        <li>Requires a Maven project to be executed.</li> 
                        <li>Requires dependency resolution of artifacts in scope: compile+runtime.</li> 
                        <li>Requires dependency collection of artifacts in scope: compile+runtime.</li> 
                        <li>Since version: 1.0.</li> 
                        <li>Binds by default to the lifecycle phase: pre-integration-test.</li> 
                    </ul> 
                    <h5 id="optional-parameters-7">Optional parameters</h5> 
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered "> 
                            <tbody>
                                <tr> 
                                    <th>Name</th> 
                                    <th>Type</th> 
                                    <th>Description</th> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#addUnnamedModules1">addUnnamedModules</a> </td> 
                                    <td>boolean</td> 
                                    <td> Adds the unnamed modules when executing the application. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.exec.addUnnamedModules </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#arguments1">arguments</a> </td> 
                                    <td>String</td> 
                                    <td> The arguments to pass to the application. 
                                        <ul></ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#configurationDirectory6">configurationDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing user-editable configuration files that will be copied to the image to execute. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.exec.configurationDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/main/conf/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#jmodsOverrideDirectory6">jmodsOverrideDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.exec.jmodsOverrideDirectory </li> 
                                            <li> <em>Default</em> : ${project.basedir}/src/jmods/ </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#mainClass1">mainClass</a> </td> 
                                    <td>String</td> 
                                    <td> The main class to use to run the application. If not specified, a main class is automatically selected. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.exec.mainClass </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#overWriteIfNewer6">overWriteIfNewer</a> </td> 
                                    <td>boolean</td> 
                                    <td> Overwrites dependencies that don't exist or are older than the source. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.exec.overWriteIfNewer </li> 
                                            <li> <em>Default</em> : true </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#skip6">skip</a> </td> 
                                    <td>boolean</td> 
                                    <td> Skips the execution. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.exec.skip </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#timeout">timeout</a> </td> 
                                    <td>long</td> 
                                    <td> The amount of time in milliseconds to wait for the application to start. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.start.timeout </li> 
                                            <li> <em>Default</em> : 60000 </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#verbose6">verbose</a> </td> 
                                    <td>boolean</td> 
                                    <td> Enables verbose logging. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.verbose </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#vmOptions1">vmOptions</a> </td> 
                                    <td>String</td> 
                                    <td> The VM options to use when executing the application. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.exec.vmOptions </li> 
                                            <li> <em>Default</em> : -Dorg.apache.logging.log4j.simplelog.level=INFO -Dorg.apache.logging.log4j.level=INFO </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#workingDirectory1">workingDirectory</a> </td> 
                                    <td>File</td> 
                                    <td> The working directory of the application. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.run.workingDirectory </li> 
                                            <li> <em>Default</em> : ${project.build.directory}/maven-inverno/working </li> 
                                        </ul> </td> 
                                </tr> 
                            </tbody>
                        </table>
                    </div> 
                    <h5 id="parameter-details-7">Parameter details</h5> 
                    <h6 id="addunnamedmodules-1">&lt;addUnnamedModules&gt;</h6> 
                    <p>Adds the unnamed modules when executing the application.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.exec.addUnnamedModules</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="arguments-1">&lt;arguments&gt;</h6> 
                    <p>The arguments to pass to the application.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                    </ul> 
                    <h6 id="configurationdirectory-6">&lt;configurationDirectory&gt;</h6> 
                    <p>A directory containing user-editable configuration files that will be copied to the image to execute.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.exec.configurationDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/main/conf/</li> 
                    </ul> 
                    <h6 id="jmodsoverridedirectory-6">&lt;jmodsOverrideDirectory&gt;</h6> 
                    <p>A directory containing module descriptors to use to modularize unnamed dependency modules and which override the ones that are otherwise generated.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.exec.jmodsOverrideDirectory</li> 
                        <li><strong>Default</strong>: ${project.basedir}/src/jmods/</li> 
                    </ul> 
                    <h6 id="mainclass-1">&lt;mainClass&gt;</h6> 
                    <p>The main class to use to run the application. If not specified, a main class is automatically selected.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.exec.mainClass</li> 
                    </ul> 
                    <h6 id="overwriteifnewer-6">&lt;overWriteIfNewer&gt;</h6> 
                    <p>Overwrites dependencies that don't exist or are older than the source.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.exec.overWriteIfNewer</li> 
                        <li><strong>Default</strong>: true</li> 
                    </ul> 
                    <h6 id="skip-6">&lt;skip&gt;</h6> 
                    <p>Skips the execution.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.exec.skip</li> 
                    </ul> 
                    <h6 id="timeout">&lt;timeout&gt;</h6> 
                    <p>The amount of time in milliseconds to wait for the application to start.</p> 
                    <ul> 
                        <li><strong>Type</strong>: long</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.start.timeout</li> 
                        <li><strong>Default</strong>: 60000</li> 
                    </ul> 
                    <h6 id="verbose-6">&lt;verbose&gt;</h6> 
                    <p>Enables verbose logging.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.verbose</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h6 id="vmoptions-1">&lt;vmOptions&gt;</h6> 
                    <p>The VM options to use when executing the application.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.lang.String</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.exec.vmOptions</li> 
                        <li><strong>Default</strong>: -Dorg.apache.logging.log4j.simplelog.level=INFO -Dorg.apache.logging.log4j.level=INFO</li> 
                    </ul> 
                    <h6 id="workingdirectory-1">&lt;workingDirectory&gt;</h6> 
                    <p>The working directory of the application.</p> 
                    <ul> 
                        <li><strong>Type</strong>: java.io.File</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.run.workingDirectory</li> 
                        <li><strong>Default</strong>: ${project.build.directory}/maven-inverno/working</li> 
                    </ul> 
                    <h4 id="invernostop">inverno:stop</h4> 
                    <p><strong>Full name:</strong></p> 
                    <p>io.inverno.tool:inverno-maven-plugin:1.1.0:stop</p> 
                    <p><strong>Description:</strong></p> 
                    <p>Stops the project application that has been previously started using the start goal.</p> 
                    <p>This goal is used together with the start goal in the pre-integration-test and post-integration-test phases to run integration tests.</p> 
                    <p><strong>Attributes:</strong></p> 
                    <ul> 
                        <li>Requires a Maven project to be executed.</li> 
                        <li>Since version: 1.0.</li> 
                        <li>Binds by default to the lifecycle phase: post-integration-test.</li> 
                    </ul> 
                    <h5 id="optional-parameters-8">Optional parameters</h5> 
                    <div class="overflow-auto">
                        <table class="table table-striped table-bordered "> 
                            <tbody>
                                <tr> 
                                    <th>Name</th> 
                                    <th>Type</th> 
                                    <th>Description</th> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#skip7">skip</a> </td> 
                                    <td>boolean</td> 
                                    <td> Skips the execution. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.stop.skip </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#timeout1">timeout</a> </td> 
                                    <td>long</td> 
                                    <td> The amount of time in milliseconds to wait for the application to stop. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.stop.timeout </li> 
                                            <li> <em>Default</em> : 60000 </li> 
                                        </ul> </td> 
                                </tr> 
                                <tr> 
                                    <td> <a href="#verbose7">verbose</a> </td> 
                                    <td>boolean</td> 
                                    <td> Enables verbose logging. 
                                        <ul> 
                                            <li> <em>User property</em> : inverno.verbose </li> 
                                            <li> <em>Default</em> : false </li> 
                                        </ul> </td> 
                                </tr> 
                            </tbody>
                        </table>
                    </div> 
                    <h5 id="parameter-details-8">Parameter details</h5> 
                    <h6 id="skip-7">&lt;skip&gt;</h6> 
                    <p>Skips the execution.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.stop.skip</li> 
                    </ul> 
                    <h6 id="timeout-1">&lt;timeout&gt;</h6> 
                    <p>The amount of time in milliseconds to wait for the application to stop.</p> 
                    <ul> 
                        <li><strong>Type</strong>: long</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.stop.timeout</li> 
                        <li><strong>Default</strong>: 60000</li> 
                    </ul> 
                    <h6 id="verbose-7">&lt;verbose&gt;</h6> 
                    <p>Enables verbose logging.</p> 
                    <ul> 
                        <li><strong>Type</strong>: boolean</li> 
                        <li><strong>Required</strong>: no</li> 
                        <li><strong>User property</strong>: inverno.verbose</li> 
                        <li><strong>Default</strong>: false</li> 
                    </ul> 
                    <h2 id="inverno-oss-parent">Inverno OSS Parent</h2> 
                    <p>The Inverno OSS parent POM provides OSS dependencies and plugin management to Inverno components and applications.</p> 
                    <h3 id="dependencies">Dependencies</h3> 
                    <div class="overflow-auto">
                        <table style="margin: auto;" class="table table-striped table-bordered "> 
                            <tbody>
                                <tr> 
                                    <th>GroupId</th> 
                                    <th>ArtifactId</th> 
                                    <th>Version</th> 
                                </tr> 
                                <tr> 
                                    <td>com.fasterxml.jackson.core</td> 
                                    <td>jackson-databind</td> 
                                    <td>2.12.3</td> 
                                </tr> 
                                <tr> 
                                    <td>com.google.cloud.tools</td> 
                                    <td>jib-core</td> 
                                    <td>0.18.0</td> 
                                </tr> 
                                <tr> 
                                    <td>io.lettuce</td> 
                                    <td>lettuce-core</td> 
                                    <td>6.1.1.RELEASE</td> 
                                </tr> 
                                <tr> 
                                    <td>io.netty</td> 
                                    <td>netty-all</td> 
                                    <td>4.1.63.Final</td> 
                                </tr> 
                                <tr> 
                                    <td>io.netty</td> 
                                    <td>netty-buffer</td> 
                                    <td>4.1.63.Final</td> 
                                </tr> 
                                <tr> 
                                    <td>io.netty</td> 
                                    <td>netty-codec-http2</td> 
                                    <td>4.1.63.Final</td> 
                                </tr> 
                                <tr> 
                                    <td>io.netty</td> 
                                    <td>netty-common</td> 
                                    <td>4.1.63.Final</td> 
                                </tr> 
                                <tr> 
                                    <td>io.netty</td> 
                                    <td>netty-resolver</td> 
                                    <td>4.1.63.Final</td> 
                                </tr> 
                                <tr> 
                                    <td>io.netty</td> 
                                    <td>netty-tcnative-boringssl-static</td> 
                                    <td>2.0.39.Final</td> 
                                </tr> 
                                <tr> 
                                    <td>io.netty</td> 
                                    <td>netty-transport</td> 
                                    <td>4.1.63.Final</td> 
                                </tr> 
                                <tr> 
                                    <td>io.netty</td> 
                                    <td>netty-transport-native-epoll</td> 
                                    <td>4.1.63.Final</td> 
                                </tr> 
                                <tr> 
                                    <td>io.netty</td> 
                                    <td>netty-transport-native-epoll</td> 
                                    <td>4.1.63.Final</td> 
                                </tr> 
                                <tr> 
                                    <td>io.netty</td> 
                                    <td>netty-transport-native-epoll</td> 
                                    <td>4.1.63.Final</td> 
                                </tr> 
                                <tr> 
                                    <td>io.netty</td> 
                                    <td>netty-transport-native-epoll</td> 
                                    <td>4.1.63.Final</td> 
                                </tr> 
                                <tr> 
                                    <td>io.netty</td> 
                                    <td>netty-transport-native-kqueue</td> 
                                    <td>4.1.63.Final</td> 
                                </tr> 
                                <tr> 
                                    <td>io.netty</td> 
                                    <td>netty-transport-native-kqueue</td> 
                                    <td>4.1.63.Final</td> 
                                </tr> 
                                <tr> 
                                    <td>io.projectreactor</td> 
                                    <td>reactor-core</td> 
                                    <td>3.4.6</td> 
                                </tr> 
                                <tr> 
                                    <td>net.java.dev.javacc</td> 
                                    <td>javacc</td> 
                                    <td>7.0.10</td> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.commons</td> 
                                    <td>commons-compress</td> 
                                    <td>1.20</td> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.commons</td> 
                                    <td>commons-lang3</td> 
                                    <td>3.12.0</td> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.commons</td> 
                                    <td>commons-text</td> 
                                    <td>1.9</td> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.logging.log4j</td> 
                                    <td>log4j-api</td> 
                                    <td>2.14.1</td> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.logging.log4j</td> 
                                    <td>log4j-core</td> 
                                    <td>2.14.1</td> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.maven</td> 
                                    <td>maven-artifact</td> 
                                    <td>${maven.version}</td> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.maven</td> 
                                    <td>maven-compat</td> 
                                    <td>${maven.version}</td> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.maven</td> 
                                    <td>maven-core</td> 
                                    <td>${maven.version}</td> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.maven</td> 
                                    <td>maven-plugin-api</td> 
                                    <td>${maven.version}</td> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.maven.plugin-tools</td> 
                                    <td>maven-plugin-annotations</td> 
                                    <td>3.6.0</td> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.maven.shared</td> 
                                    <td>maven-common-artifact-filters</td> 
                                    <td>3.1.0</td> 
                                </tr> 
                                <tr> 
                                    <td>org.junit.jupiter</td> 
                                    <td>junit-jupiter-api</td> 
                                    <td>5.7.1</td> 
                                </tr> 
                                <tr> 
                                    <td>org.junit.jupiter</td> 
                                    <td>junit-jupiter-engine</td> 
                                    <td>5.7.1</td> 
                                </tr> 
                                <tr> 
                                    <td>org.junit.jupiter</td> 
                                    <td>junit-jupiter-params</td> 
                                    <td>5.7.1</td> 
                                </tr> 
                                <tr> 
                                    <td>org.junit.platform</td> 
                                    <td>junit-platform-commons</td> 
                                    <td>1.7.1</td> 
                                </tr> 
                                <tr> 
                                    <td>org.junit.platform</td> 
                                    <td>junit-platform-launcher</td> 
                                    <td>1.7.1</td> 
                                </tr> 
                                <tr> 
                                    <td>org.mockito</td> 
                                    <td>mockito-core</td> 
                                    <td>3.8.0</td> 
                                </tr> 
                                <tr> 
                                    <td>org.ow2.asm</td> 
                                    <td>asm</td> 
                                    <td>9.1</td> 
                                </tr> 
                                <tr> 
                                    <td>org.webjars</td> 
                                    <td>swagger-ui</td> 
                                    <td>3.48.0</td> 
                                </tr> 
                            </tbody>
                        </table>
                    </div> 
                    <h3 id="maven-plugins">Maven Plugins</h3> 
                    <div class="overflow-auto">
                        <table style="margin: auto;" class="table table-striped table-bordered "> 
                            <tbody>
                                <tr> 
                                    <th>GroupId</th> 
                                    <th>ArtifactId</th> 
                                    <th>Version</th> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.maven.plugins</td> 
                                    <td>maven-antrun-plugin</td> 
                                    <td>3.0.0</td> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.maven.plugins</td> 
                                    <td>maven-clean-plugin</td> 
                                    <td>3.1.0</td> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.maven.plugins</td> 
                                    <td>maven-compiler-plugin</td> 
                                    <td>3.8.1</td> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.maven.plugins</td> 
                                    <td>maven-dependency-plugin</td> 
                                    <td>3.1.2</td> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.maven.plugins</td> 
                                    <td>maven-deploy-plugin</td> 
                                    <td>2.8.2</td> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.maven.plugins</td> 
                                    <td>maven-gpg-plugin</td> 
                                    <td>3.0.1</td> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.maven.plugins</td> 
                                    <td>maven-install-plugin</td> 
                                    <td>2.5.2</td> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.maven.plugins</td> 
                                    <td>maven-jar-plugin</td> 
                                    <td>3.2.0</td> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.maven.plugins</td> 
                                    <td>maven-javadoc-plugin</td> 
                                    <td>3.2.0</td> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.maven.plugins</td> 
                                    <td>maven-plugin-plugin</td> 
                                    <td>3.6.1</td> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.maven.plugins</td> 
                                    <td>maven-resources-plugin</td> 
                                    <td>3.2.0</td> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.maven.plugins</td> 
                                    <td>maven-source-plugin</td> 
                                    <td>3.2.1</td> 
                                </tr> 
                                <tr> 
                                    <td>org.apache.maven.plugins</td> 
                                    <td>maven-surefire-plugin</td> 
                                    <td>2.22.2</td> 
                                </tr> 
                                <tr> 
                                    <td>org.codehaus.mojo</td> 
                                    <td>exec-maven-plugin</td> 
                                    <td>3.0.0</td> 
                                </tr> 
                                <tr> 
                                    <td>org.javacc.plugin</td> 
                                    <td>javacc-maven-plugin</td> 
                                    <td>3.0.3</td> 
                                </tr> 
                                <tr> 
                                    <td>org.sonatype.plugins</td> 
                                    <td>nexus-staging-maven-plugin</td> 
                                    <td>1.6.8</td> 
                                </tr> 
                            </tbody>
                        </table>
                    </div> 
                </section>
            </div>
        </main> 
        <footer class="footer bg-light border-top mt-5"> 
            <div class="container p-5"> 
                <div class="row mb-5"> 
                    <div class="col col-lg-3"> 
                        <h5>Documentation</h5> 
                        <ul class="nav flex-column"> 
                            <li class="nav-item"><a class="nav-link px-0" href="../../../../docs/getting-started/html/index.html">Getting Started</a></li> 
                            <li class="nav-item"><a class="nav-link px-0" href="../../../../docs/release/reference/html/index.html">Reference</a></li> 
                            <li class="nav-item"><a class="nav-link px-0" href="../../../../docs/release/api/index.html">API Doc</a></li> 
                        </ul> 
                    </div> 
                    <div class="col col-lg-3"> 
                        <h5>Projects</h5> 
                        <ul class="nav flex-column"> 
                            <li class="nav-item"><a class="nav-link px-0" href="https://github.com/inverno-io/inverno-core">Core</a></li> 
                            <li class="nav-item"><a class="nav-link px-0" href="https://github.com/inverno-io/inverno-mods">Modules</a></li> 
                            <li class="nav-item"><a class="nav-link px-0" href="https://github.com/inverno-io/inverno-dist">Distribution</a></li> 
                            <li class="nav-item"><a class="nav-link px-0" href="https://github.com/inverno-io/inverno-tools">Tools</a></li> 
                            <li class="nav-item"><a class="nav-link px-0" href="https://github.com/inverno-io/inverno-examples">Examples</a></li> 
                        </ul> 
                    </div> 
                </div> 
            </div> 
            <div class="p-3 mb-5 text-center"> 
                <p class="fw-light fs-6">The Inverno Framework is released under version 2.0 of the <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License</a>.</p> 
                <p class="fw-light fs-6">Copyright Â© 2021, The Inverno Framework</p> 
            </div> 
        </footer> 
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-p34f1UUtsS3wqzfto5wAAmdvj+osOnFyQFpp4Ua3gs/ZVWx6oOypYoCJhGGScy+8" crossorigin="anonymous"></script>  
    </body>
</html>